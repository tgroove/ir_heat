   1               		.file	"ir_heat.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  86               	.global	off_counter
  87               	.global	off_counter
  88               		.section .bss
  91               	off_counter:
  92 0000 00        		.skip 1,0
  93               	.global	t_la_threshold_up
  94               		.data
  97               	t_la_threshold_up:
  98 0000 2C01      		.word	300
  99               	.global	t_abs_threshold_up
 102               	t_abs_threshold_up:
 103 0002 0E01      		.word	270
 104               	.global	t_la_threshold_down
 107               	t_la_threshold_down:
 108 0004 FA00      		.word	250
 109               	.global	t_abs_threshold_down
 112               	t_abs_threshold_down:
 113 0006 FA00      		.word	250
 114               		.lcomm c.1650,1
 115               		.text
 117               	.global	__vector_9
 119               	__vector_9:
   1:ir_heat.c     **** // ***********************************************************
   2:ir_heat.c     **** // Project:
   3:ir_heat.c     **** // Author:
   4:ir_heat.c     **** // Module description:
   5:ir_heat.c     **** // ***********************************************************
   6:ir_heat.c     **** 
   7:ir_heat.c     **** #ifndef F_CPU
   8:ir_heat.c     **** #define F_CPU 1000000UL
   9:ir_heat.c     **** #endif
  10:ir_heat.c     **** 
  11:ir_heat.c     **** #include <avr\io.h>              // Most basic include files
  12:ir_heat.c     **** #include <avr\interrupt.h>       // Add the necessary ones
  13:ir_heat.c     **** #include <avr\signal.h>          // here
  14:ir_heat.c     **** #include <avr\wdt.h>
  15:ir_heat.c     **** 
  16:ir_heat.c     **** #include <stdio.h>
  17:ir_heat.c     **** #include <string.h>
  18:ir_heat.c     **** #include <stdlib.h>
  19:ir_heat.c     **** 
  20:ir_heat.c     **** #include "i2c_master.h"
  21:ir_heat.c     **** 
  22:ir_heat.c     **** #define 	MLX90614_WRITE	(0x5A<<1)
  23:ir_heat.c     **** #define 	MLX90614_READ	(MLX90614_WRITE+1)
  24:ir_heat.c     **** #define	ADR_T_A			0x06
  25:ir_heat.c     **** #define	ADR_T_OBJ1		0x07
  26:ir_heat.c     **** #define	ADR_T_OBJ2		0x08
  27:ir_heat.c     **** 
  28:ir_heat.c     **** 
  29:ir_heat.c     **** #define __STDIO_FDEVOPEN_COMPAT_12						
  30:ir_heat.c     **** // Buffer sizes must be 2^n
  31:ir_heat.c     **** //
  32:ir_heat.c     **** #define TBUFSIZE	32
  33:ir_heat.c     **** #define RBUFSIZE	32
  34:ir_heat.c     **** 
  35:ir_heat.c     **** #define TMASK		(TBUFSIZE-1)
  36:ir_heat.c     **** #define RMASK		(RBUFSIZE-1)
  37:ir_heat.c     **** 
  38:ir_heat.c     **** #define FLASH_LED		PC3
  39:ir_heat.c     **** #define STATUS_LED1	PD4
  40:ir_heat.c     **** #define STATUS_LED2	PD3
  41:ir_heat.c     **** #define RELAIS			PB7
  42:ir_heat.c     **** #define BUZZER			PB6
  43:ir_heat.c     **** #define SWITCH			PD2
  44:ir_heat.c     **** 
  45:ir_heat.c     **** #define RELAIS_ON			PORTB |= (1<<RELAIS)
  46:ir_heat.c     **** #define RELAIS_OFF		PORTB &=~(1<<RELAIS)
  47:ir_heat.c     **** 
  48:ir_heat.c     **** #define BUZZER_ON			PORTB |= (1<<BUZZER)
  49:ir_heat.c     **** #define BUZZER_OFF		PORTB &=~(1<<BUZZER)
  50:ir_heat.c     **** 
  51:ir_heat.c     **** #define STATUS_LED1_ON	PORTD |= (1<<STATUS_LED1)
  52:ir_heat.c     **** #define STATUS_LED1_OFF	PORTD &=~(1<<STATUS_LED1)
  53:ir_heat.c     **** 
  54:ir_heat.c     **** #define FLASH_LED_ON		PORTC |= (1<<FLASH_LED)
  55:ir_heat.c     **** #define FLASH_LED_OFF	PORTC &=~(1<<FLASH_LED)
  56:ir_heat.c     **** 
  57:ir_heat.c     **** #define STATUS_LED2_ON	PORTD |= (1<<STATUS_LED2)
  58:ir_heat.c     **** #define STATUS_LED2_OFF	PORTD &=~(1<<STATUS_LED2)
  59:ir_heat.c     **** 
  60:ir_heat.c     **** #define OFF_COUNTER		20
  61:ir_heat.c     **** 
  62:ir_heat.c     **** #define	MODE_OFF			0
  63:ir_heat.c     **** #define	MODE_ON			1
  64:ir_heat.c     **** #define	MODE_TEMP_PROT	3
  65:ir_heat.c     **** 
  66:ir_heat.c     **** // Define here the global static variables
  67:ir_heat.c     **** //
  68:ir_heat.c     **** volatile unsigned char tbuf[TBUFSIZE];  // TX buffer
  69:ir_heat.c     **** volatile unsigned char rbuf[RBUFSIZE];  // RX buffer
  70:ir_heat.c     **** 
  71:ir_heat.c     **** volatile unsigned char t_in;            // TX buffer in index
  72:ir_heat.c     **** volatile unsigned char t_out;           // TX buffer out index
  73:ir_heat.c     **** 
  74:ir_heat.c     **** volatile unsigned char r_in;            // RX buffer in index
  75:ir_heat.c     **** volatile unsigned char r_out;           // RX buffer out index
  76:ir_heat.c     **** 
  77:ir_heat.c     **** uint8_t	interval;
  78:ir_heat.c     **** uint16_t t_array[6];
  79:ir_heat.c     **** uint8_t	off_counter = 0;
  80:ir_heat.c     **** uint8_t	mode;
  81:ir_heat.c     **** 
  82:ir_heat.c     **** uint16_t	t_la_threshold_up 	=  300;
  83:ir_heat.c     **** uint16_t	t_abs_threshold_up 	=  270;
  84:ir_heat.c     **** uint16_t	t_la_threshold_down 	=  250;
  85:ir_heat.c     **** uint16_t	t_abs_threshold_down	=  250;
  86:ir_heat.c     **** 
  87:ir_heat.c     **** 
  88:ir_heat.c     **** 
  89:ir_heat.c     **** // Clock Timer
  90:ir_heat.c     **** SIGNAL(SIG_OVERFLOW2) {
 120               	
 121               	.LM0:
 122               	.LFBB1:
 123 0000 1F92      		push __zero_reg__
 124 0002 0F92      		push r0
 125 0004 0FB6      		in r0,__SREG__
 126 0006 0F92      		push r0
 127 0008 1124      		clr __zero_reg__
 128 000a 8F93      		push r24
 129 000c DF93      		push r29
 130 000e CF93      		push r28
 131 0010 CDB7      		in r28,__SP_L__
 132 0012 DEB7      		in r29,__SP_H__
 133               	/* prologue: Signal */
 134               	/* frame size = 0 */
  91:ir_heat.c     **** 	static uint8_t c = 0;
  92:ir_heat.c     **** 	interval++;
 135               	2,.LM1-.LFBB1
 136               	.LM1:
 137 0014 8091 0000 		lds r24,interval
 138 0018 8F5F      		subi r24,lo8(-(1))
 139 001a 8093 0000 		sts interval,r24
 140               	/* epilogue start */
  93:ir_heat.c     **** }
 141               	n	68,0,93,.LM2-.LFBB1
 142               	.LM2:
 143 001e CF91      		pop r28
 144 0020 DF91      		pop r29
 145 0022 8F91      		pop r24
 146 0024 0F90      		pop r0
 147 0026 0FBE      		out __SREG__,r0
 148 0028 0F90      		pop r0
 149 002a 1F90      		pop __zero_reg__
 150 002c 1895      		reti
 155               	.Lscope1:
 156               		.lcomm c.1658,1
 158               	.global	__vector_16
 160               	__vector_16:
  94:ir_heat.c     **** 
  95:ir_heat.c     **** SIGNAL(SIG_OVERFLOW0) {
 161               	-.LFBB2
 162               	.LM3:
 163               	.LFBB2:
 164 002e 1F92      		push __zero_reg__
 165 0030 0F92      		push r0
 166 0032 0FB6      		in r0,__SREG__
 167 0034 0F92      		push r0
 168 0036 1124      		clr __zero_reg__
 169 0038 2F93      		push r18
 170 003a 3F93      		push r19
 171 003c 4F93      		push r20
 172 003e 5F93      		push r21
 173 0040 8F93      		push r24
 174 0042 9F93      		push r25
 175 0044 AF93      		push r26
 176 0046 BF93      		push r27
 177 0048 EF93      		push r30
 178 004a FF93      		push r31
 179 004c DF93      		push r29
 180 004e CF93      		push r28
 181 0050 0F92      		push __tmp_reg__
 182 0052 CDB7      		in r28,__SP_L__
 183 0054 DEB7      		in r29,__SP_H__
 184               	/* prologue: Signal */
 185               	/* frame size = 1 */
  96:ir_heat.c     **** 	static uint8_t	c = 0;
  97:ir_heat.c     **** 	uint8_t slow=0;
 186               	B2
 187               	.LM4:
 188 0056 1982      		std Y+1,__zero_reg__
  98:ir_heat.c     **** 	//if (off_counter < OFF_COUNTER-2) slow=1;
  99:ir_heat.c     **** 	c++;
 189               	tabn	68,0,99,.LM5-.LFBB2
 190               	.LM5:
 191 0058 8091 0000 		lds r24,c.1658
 192 005c 8F5F      		subi r24,lo8(-(1))
 193 005e 8093 0000 		sts c.1658,r24
 100:ir_heat.c     **** 	if (mode==MODE_TEMP_PROT) {
 194               	bn	68,0,100,.LM6-.LFBB2
 195               	.LM6:
 196 0062 8091 0000 		lds r24,mode
 197 0066 8330      		cpi r24,lo8(3)
 198 0068 01F4      		brne .L4
 101:ir_heat.c     **** 		if(c>(7<<slow)) {
 199               	bn	68,0,101,.LM7-.LFBB2
 200               	.LM7:
 201 006a 8091 0000 		lds r24,c.1658
 202 006e 482F      		mov r20,r24
 203 0070 50E0      		ldi r21,lo8(0)
 204 0072 8981      		ldd r24,Y+1
 205 0074 282F      		mov r18,r24
 206 0076 30E0      		ldi r19,lo8(0)
 207 0078 87E0      		ldi r24,lo8(7)
 208 007a 90E0      		ldi r25,hi8(7)
 209 007c 022E      		mov r0,r18
 210 007e 00C0      		rjmp 2f
 211 0080 880F      	1:	lsl r24
 212 0082 991F      		rol r25
 213 0084 0A94      	2:	dec r0
 214 0086 02F4      		brpl 1b
 215 0088 8417      		cp r24,r20
 216 008a 9507      		cpc r25,r21
 217 008c 04F4      		brge .L4
 102:ir_heat.c     **** 			FLASH_LED_ON;
 218               	M8-.LFBB2
 219               	.LM8:
 220 008e A8E2      		ldi r26,lo8(40)
 221 0090 B0E0      		ldi r27,hi8(40)
 222 0092 E8E2      		ldi r30,lo8(40)
 223 0094 F0E0      		ldi r31,hi8(40)
 224 0096 8081      		ld r24,Z
 225 0098 8860      		ori r24,lo8(8)
 226 009a 8C93      		st X,r24
 227               	.L4:
 103:ir_heat.c     **** 		}
 104:ir_heat.c     **** 	}
 105:ir_heat.c     **** 	if(c>(15<<slow)) {
 228               	,0,105,.LM9-.LFBB2
 229               	.LM9:
 230 009c 8091 0000 		lds r24,c.1658
 231 00a0 482F      		mov r20,r24
 232 00a2 50E0      		ldi r21,lo8(0)
 233 00a4 8981      		ldd r24,Y+1
 234 00a6 282F      		mov r18,r24
 235 00a8 30E0      		ldi r19,lo8(0)
 236 00aa 8FE0      		ldi r24,lo8(15)
 237 00ac 90E0      		ldi r25,hi8(15)
 238 00ae 022E      		mov r0,r18
 239 00b0 00C0      		rjmp 2f
 240 00b2 880F      	1:	lsl r24
 241 00b4 991F      		rol r25
 242 00b6 0A94      	2:	dec r0
 243 00b8 02F4      		brpl 1b
 244 00ba 8417      		cp r24,r20
 245 00bc 9507      		cpc r25,r21
 246 00be 04F4      		brge .L6
 106:ir_heat.c     **** 		c=0;
 247               	M10-.LFBB2
 248               	.LM10:
 249 00c0 1092 0000 		sts c.1658,__zero_reg__
 107:ir_heat.c     **** 		FLASH_LED_OFF;
 250               	tabn	68,0,107,.LM11-.LFBB2
 251               	.LM11:
 252 00c4 A8E2      		ldi r26,lo8(40)
 253 00c6 B0E0      		ldi r27,hi8(40)
 254 00c8 E8E2      		ldi r30,lo8(40)
 255 00ca F0E0      		ldi r31,hi8(40)
 256 00cc 8081      		ld r24,Z
 257 00ce 877F      		andi r24,lo8(-9)
 258 00d0 8C93      		st X,r24
 259               	.L6:
 260               	/* epilogue start */
 108:ir_heat.c     **** 	}
 109:ir_heat.c     **** }
 261               	0,109,.LM12-.LFBB2
 262               	.LM12:
 263 00d2 0F90      		pop __tmp_reg__
 264 00d4 CF91      		pop r28
 265 00d6 DF91      		pop r29
 266 00d8 FF91      		pop r31
 267 00da EF91      		pop r30
 268 00dc BF91      		pop r27
 269 00de AF91      		pop r26
 270 00e0 9F91      		pop r25
 271 00e2 8F91      		pop r24
 272 00e4 5F91      		pop r21
 273 00e6 4F91      		pop r20
 274 00e8 3F91      		pop r19
 275 00ea 2F91      		pop r18
 276 00ec 0F90      		pop r0
 277 00ee 0FBE      		out __SREG__,r0
 278 00f0 0F90      		pop r0
 279 00f2 1F90      		pop __zero_reg__
 280 00f4 1895      		reti
 286               	.Lscope2:
 287               		.data
 288               	.LC0:
 289 0008 494E 5430 		.string	"INT0 %i\n"
 289      2025 690A 
 289      00
 290               		.text
 292               	.global	__vector_1
 294               	__vector_1:
 110:ir_heat.c     **** 
 111:ir_heat.c     **** 
 112:ir_heat.c     **** SIGNAL(SIG_INTERRUPT0) {
 295               	3:
 296               	.LFBB3:
 297               		push __zero_reg__
 298 00f6 1F92      		push r0
 299 00f8 0F92      		in r0,__SREG__
 300 00fa 0FB6      		push r0
 301 00fc 0F92      		clr __zero_reg__
 302 00fe 1124      		push r18
 303 0100 2F93      		push r19
 304 0102 3F93      		push r20
 305 0104 4F93      		push r21
 306 0106 5F93      		push r22
 307 0108 6F93      		push r23
 308 010a 7F93      		push r24
 309 010c 8F93      		push r25
 310 010e 9F93      		push r26
 311 0110 AF93      		push r27
 312 0112 BF93      		push r30
 313 0114 EF93      		push r31
 314 0116 FF93      		push r29
 315 0118 DF93      		push r28
 316 011a CF93      		rcall .
 317 011c 00D0      		rcall .
 318 011e 00D0      		in r28,__SP_L__
 319 0120 CDB7      		in r29,__SP_H__
 320 0122 DEB7      	/* prologue: Signal */
 321               	/* frame size = 4 */
 113:ir_heat.c     **** 	uint8_t i;
 114:ir_heat.c     **** 	uint8_t c=0;
 323               	
 325 0124 1982      	.LM15:
 115:ir_heat.c     **** 	EIMSK = 0;
 326               	di r30,lo8(61)
 327               		ldi r31,hi8(61)
 328 0126 EDE3      		st Z,__zero_reg__
 330 012a 1082      	.LM16:
 116:ir_heat.c     **** 	sei();
 331               	PP */
 332               	 ;  116 "ir_heat.c" 1
 333               		sei
 334               	 ;  0 "" 2
 336               	.LM17:
 117:ir_heat.c     **** 	
 118:ir_heat.c     **** 	for(i=0;i<250;i++) if((PIND & (1<<SWITCH))) c++;
 337               	APP */
 338               		std Y+2,__zero_reg__
 339               		rjmp .L8
 340 012e 1A82      	.L10:
 341 0130 00C0      		ldi r30,lo8(41)
 342               		ldi r31,hi8(41)
 343 0132 E9E2      		ld r24,Z
 344 0134 F0E0      		mov r24,r24
 345 0136 8081      		ldi r25,lo8(0)
 346 0138 882F      		andi r24,lo8(4)
 347 013a 90E0      		andi r25,hi8(4)
 348 013c 8470      		sbiw r24,0
 349 013e 9070      		breq .L9
 350 0140 0097      		ldd r24,Y+1
 351 0142 01F0      		subi r24,lo8(-(1))
 352 0144 8981      		std Y+1,r24
 353 0146 8F5F      	.L9:
 354 0148 8983      		ldd r24,Y+2
 355               		subi r24,lo8(-(1))
 356 014a 8A81      		std Y+2,r24
 357 014c 8F5F      	.L8:
 358 014e 8A83      		ldd r24,Y+2
 359               		cpi r24,lo8(-6)
 360 0150 8A81      		brlo .L10
 362 0154 00F0      	.LM18:
 119:ir_heat.c     **** 	printf("INT0 %i\n", c);
 363               		ldi r19,lo8(0)
 364               		rcall .
 365 0156 8981      		rcall .
 366 0158 282F      		in r30,__SP_L__
 367 015a 30E0      		in r31,__SP_H__
 368 015c 00D0      		adiw r30,1
 369 015e 00D0      		ldi r24,lo8(.LC0)
 370 0160 EDB7      		ldi r25,hi8(.LC0)
 371 0162 FEB7      		std Z+1,r25
 372 0164 3196      		st Z,r24
 373 0166 80E0      		std Z+3,r19
 374 0168 90E0      		std Z+2,r18
 375 016a 9183      		call printf
 376 016c 8083      		pop __tmp_reg__
 377 016e 3383      		pop __tmp_reg__
 378 0170 2283      		pop __tmp_reg__
 379 0172 0E94 0000 		pop __tmp_reg__
 381 0178 0F90      	.LM19:
 382 017a 0F90      		ldd r24,Y+1
 383 017c 0F90      		cpi r24,lo8(40)
 120:ir_heat.c     **** 
 121:ir_heat.c     **** 	if(c < 40) {
 384               	,0,122,.LM20-.LFBB3
 385               	.LM20:
 386 017e 8981      		lds r24,mode
 387 0180 8832      		mov r18,r24
 388 0182 00F4      		ldi r19,lo8(0)
 122:ir_heat.c     **** 		switch(mode) {
 389               	Y+4,r19
 390               		std Y+3,r18
 391 0184 8091 0000 		ldd r24,Y+3
 392 0188 282F      		ldd r25,Y+4
 393 018a 30E0      		sbiw r24,0
 394 018c 3C83      		breq .L13
 395 018e 2B83      		ldd r18,Y+3
 396 0190 8B81      		ldd r19,Y+4
 397 0192 9C81      		cpi r18,1
 398 0194 0097      		cpc r19,__zero_reg__
 399 0196 01F0      		breq .L14
 400 0198 2B81      		rjmp .L18
 401 019a 3C81      	.L13:
 403 019e 3105      	.LM21:
 404 01a0 01F0      		lds r24,off_counter
 405 01a2 00C0      		tst r24
 406               		breq .L15
 123:ir_heat.c     **** 		case MODE_OFF:
 124:ir_heat.c     **** 			if(off_counter) mode = MODE_TEMP_PROT;
 407               	ts mode,r24
 408               		rjmp .L11
 409 01a4 8091 0000 	.L15:
 411 01aa 01F0      	.LM22:
 412 01ac 83E0      		ldi r24,lo8(1)
 413 01ae 8093 0000 		sts mode,r24
 414 01b2 00C0      		rjmp .L11
 415               	.L14:
 125:ir_heat.c     **** 			else mode = MODE_ON;
 416               	8,0,128,.LM23-.LFBB3
 417               	.LM23:
 418 01b4 81E0      		sts mode,__zero_reg__
 419 01b6 8093 0000 		rjmp .L11
 420 01ba 00C0      	.L18:
 126:ir_heat.c     **** 			break;
 127:ir_heat.c     **** 		case MODE_ON:
 128:ir_heat.c     **** 			mode = MODE_OFF;
 422               	
 423               		sts mode,__zero_reg__
 424 01bc 1092 0000 	.L11:
 426               	.LM25:
 129:ir_heat.c     **** 			break;
 130:ir_heat.c     **** 		case MODE_TEMP_PROT:
 131:ir_heat.c     **** 		default:
 132:ir_heat.c     **** 			mode = MODE_OFF;
 427               	 r30,lo8(61)
 428               		ldi r31,hi8(61)
 429 01c2 1092 0000 		ldi r24,lo8(1)
 430               		st Z,r24
 133:ir_heat.c     **** 		}
 134:ir_heat.c     **** 	}
 135:ir_heat.c     **** 	EIMSK = (1<<INT0);
 431               	pilogue start */
 433 01c6 EDE3      	.LM26:
 434 01c8 F0E0      		pop __tmp_reg__
 435 01ca 81E0      		pop __tmp_reg__
 436 01cc 8083      		pop __tmp_reg__
 437               		pop __tmp_reg__
 136:ir_heat.c     **** }
 438               	8
 439               		pop r29
 440 01ce 0F90      		pop r31
 441 01d0 0F90      		pop r30
 442 01d2 0F90      		pop r27
 443 01d4 0F90      		pop r26
 444 01d6 CF91      		pop r25
 445 01d8 DF91      		pop r24
 446 01da FF91      		pop r23
 447 01dc EF91      		pop r22
 448 01de BF91      		pop r21
 449 01e0 AF91      		pop r20
 450 01e2 9F91      		pop r19
 451 01e4 8F91      		pop r18
 452 01e6 7F91      		pop r0
 453 01e8 6F91      		out __SREG__,r0
 454 01ea 5F91      		pop r0
 455 01ec 4F91      		pop __zero_reg__
 456 01ee 3F91      		reti
 462 01fa 1895      	.Lscope3:
 464               	.global	__vector_18
 466               	__vector_18:
 468               	.LM27:
 469               	.LFBB4:
 470               		push __zero_reg__
 471               		push r0
 472               		in r0,__SREG__
 137:ir_heat.c     **** 
 138:ir_heat.c     **** 
 139:ir_heat.c     **** SIGNAL(SIG_USART_RECV) {
 473               	4
 474               		push r25
 475               		push r30
 476 01fc 1F92      		push r31
 477 01fe 0F92      		push r29
 478 0200 0FB6      		push r28
 479 0202 0F92      		push __tmp_reg__
 480 0204 1124      		in r28,__SP_L__
 481 0206 8F93      		in r29,__SP_H__
 482 0208 9F93      	/* prologue: Signal */
 483 020a EF93      	/* frame size = 1 */
 485 020e DF93      	.LM28:
 486 0210 CF93      		ldi r30,lo8(198)
 487 0212 0F92      		ldi r31,hi8(198)
 488 0214 CDB7      		ld r24,Z
 489 0216 DEB7      		std Y+1,r24
 491               	.LM29:
 140:ir_heat.c     **** //******************
 141:ir_heat.c     **** // RX interrupt handler
 142:ir_heat.c     **** //
 143:ir_heat.c     **** 	char c;	
 144:ir_heat.c     **** 	c = UDR0;							// Get received char
 492               	r24,r24
 493               		ldi r25,lo8(0)
 494 0218 E6EC      		andi r24,lo8(31)
 495 021a F0E0      		andi r25,hi8(31)
 496 021c 8081      		movw r30,r24
 497 021e 8983      		subi r30,lo8(-(rbuf))
 145:ir_heat.c     **** 	rbuf[r_in & RMASK] = c;
 498               	r31,hi8(-(rbuf))
 499               		ldd r24,Y+1
 500 0220 8091 0000 		st Z,r24
 502 0226 90E0      	.LM30:
 503 0228 8F71      		lds r24,r_in
 504 022a 9070      		subi r24,lo8(-(1))
 505 022c FC01      		sts r_in,r24
 506 022e E050      	/* epilogue start */
 508 0232 8981      	.LM31:
 509 0234 8083      		pop __tmp_reg__
 146:ir_heat.c     **** 	r_in++;
 510               	p r29
 511               		pop r31
 512 0236 8091 0000 		pop r30
 513 023a 8F5F      		pop r25
 514 023c 8093 0000 		pop r24
 515               		pop r0
 147:ir_heat.c     **** }
 516               	_SREG__,r0
 517               		pop r0
 518 0240 0F90      		pop __zero_reg__
 519 0242 CF91      		reti
 524 024c 8F91      	.Lscope4:
 526 0250 0FBE      	.global	__vector_19
 528 0254 1F90      	__vector_19:
 530               	.LM32:
 531               	.LFBB5:
 532               		push __zero_reg__
 533               		push r0
 534               		in r0,__SREG__
 535               		push r0
 536               		clr __zero_reg__
 537               		push r24
 538               		push r25
 148:ir_heat.c     **** 
 149:ir_heat.c     **** SIGNAL(SIG_USART_DATA) {
 539               	sh r30
 540               		push r31
 541               		push r29
 542 0258 1F92      		push r28
 543 025a 0F92      		in r28,__SP_L__
 544 025c 0FB6      		in r29,__SP_H__
 545 025e 0F92      	/* prologue: Signal */
 546 0260 1124      	/* frame size = 0 */
 548 0264 9F93      	.LM33:
 549 0266 AF93      		lds r25,t_in
 550 0268 BF93      		lds r24,t_out
 551 026a EF93      		cp r25,r24
 552 026c FF93      		breq .L22
 554 0270 CF93      	.LM34:
 555 0272 CDB7      		ldi r26,lo8(198)
 556 0274 DEB7      		ldi r27,hi8(198)
 557               		lds r24,t_out
 558               		mov r24,r24
 150:ir_heat.c     **** //*******************
 151:ir_heat.c     **** // Data register empty interrupt handler.
 152:ir_heat.c     **** // Indicates that next char can be transmitted
 153:ir_heat.c     **** //
 154:ir_heat.c     **** 	if(t_in != t_out) {
 559               	i r24,lo8(31)
 560               		andi r25,hi8(31)
 561 0276 9091 0000 		movw r30,r24
 562 027a 8091 0000 		subi r30,lo8(-(tbuf))
 563 027e 9817      		sbci r31,hi8(-(tbuf))
 564 0280 01F0      		ld r24,Z
 155:ir_heat.c     **** 		UDR0 = tbuf[t_out & TMASK];
 565               	r24
 567 0282 A6EC      	.LM35:
 568 0284 B0E0      		lds r24,t_out
 569 0286 8091 0000 		subi r24,lo8(-(1))
 570 028a 882F      		sts t_out,r24
 571 028c 90E0      		rjmp .L24
 572 028e 8F71      	.L22:
 574 0292 FC01      	.LM36:
 575 0294 E050      		ldi r26,lo8(193)
 576 0296 F040      		ldi r27,hi8(193)
 577 0298 8081      		ldi r30,lo8(193)
 578 029a 8C93      		ldi r31,hi8(193)
 156:ir_heat.c     **** 		t_out++;	
 579               	i r24,lo8(-33)
 580               		st X,r24
 581 029c 8091 0000 	.L24:
 582 02a0 8F5F      	/* epilogue start */
 584 02a6 00C0      	.LM37:
 585               		pop r28
 157:ir_heat.c     **** 	}
 158:ir_heat.c     **** 	else {
 159:ir_heat.c     **** 		UCSR0B &= ~(1<<UDRIE0);
 586               	9
 587               		pop r31
 588 02a8 A1EC      		pop r30
 589 02aa B0E0      		pop r27
 590 02ac E1EC      		pop r26
 591 02ae F0E0      		pop r25
 592 02b0 8081      		pop r24
 593 02b2 8F7D      		pop r0
 594 02b4 8C93      		out __SREG__,r0
 595               		pop r0
 596               		pop __zero_reg__
 160:ir_heat.c     **** 	}
 161:ir_heat.c     **** }
 597               	e	__vector_19, .-__vector_19
 598               	.Lscope5:
 600 02b8 DF91      	.global	tbuflen
 602 02bc EF91      	tbuflen:
 604 02c0 AF91      	.LM38:
 605 02c2 9F91      	.LFBB6:
 606 02c4 8F91      		push r29
 607 02c6 0F90      		push r28
 608 02c8 0FBE      		in r28,__SP_L__
 609 02ca 0F90      		in r29,__SP_H__
 610 02cc 1F90      	/* prologue: function */
 611 02ce 1895      	/* frame size = 0 */
 613               	.LM39:
 614               		lds r25,t_in
 615               		lds r24,t_out
 616               		mov r18,r25
 617               		sub r18,r24
 162:ir_heat.c     **** 
 163:ir_heat.c     **** char tbuflen(void) {
 618               	gue start */
 620               	.LM40:
 621 02d0 DF93      		pop r28
 622 02d2 CF93      		pop r29
 623 02d4 CDB7      		ret
 625               	.Lscope6:
 164:ir_heat.c     **** //****************
 165:ir_heat.c     **** // Retrieve pending chars in TX buffer
 166:ir_heat.c     **** //
 167:ir_heat.c     **** 	return(t_in - t_out);
 627               	c:p(0,2)",160,0,0,1
 629 02d8 9091 0000 	.global	UART_putchar
 631 02e0 292F      	UART_putchar:
 633 02e4 822F      	.LM41:
 634               	.LFBB7:
 168:ir_heat.c     **** }
 635               	9
 636               		push r28
 637 02e6 CF91      		rcall .
 638 02e8 DF91      		push __tmp_reg__
 639 02ea 0895      		in r28,__SP_L__
 640               		in r29,__SP_H__
 641               	/* prologue: function */
 642               	/* frame size = 3 */
 643               		std Y+1,r24
 644               		std Y+3,r23
 645               		std Y+2,r22
 646               	.L28:
 169:ir_heat.c     **** 
 170:ir_heat.c     **** int UART_putchar(char c, FILE *stream) {
 648               	tbuflen
 649               		mov r18,r24
 650               		ldi r19,lo8(0)
 651 02ec DF93      		ldi r24,lo8(32)
 652 02ee CF93      		ldi r25,hi8(32)
 653 02f0 00D0      		sub r24,r18
 654 02f2 0F92      		sbc r25,r19
 655 02f4 CDB7      		cpi r24,3
 656 02f6 DEB7      		cpc r25,__zero_reg__
 657               		brlt .L28
 659 02f8 8983      	.LM43:
 660 02fa 7B83      		lds r24,t_in
 661 02fc 6A83      		mov r24,r24
 662               		ldi r25,lo8(0)
 171:ir_heat.c     **** //*********************
 172:ir_heat.c     **** // Fills the transmit buffer, if it is full wait
 173:ir_heat.c     **** //
 174:ir_heat.c     **** 	while((TBUFSIZE - tbuflen()) <= 2);  // Wait...
 663               	1)
 664               		andi r25,hi8(31)
 665 02fe 0E94 0000 		movw r30,r24
 666 0302 282F      		subi r30,lo8(-(tbuf))
 667 0304 30E0      		sbci r31,hi8(-(tbuf))
 668 0306 80E2      		ldd r24,Y+1
 669 0308 90E0      		st Z,r24
 671 030c 930B      	.LM44:
 672 030e 8330      		lds r24,t_in
 673 0310 9105      		subi r24,lo8(-(1))
 674 0312 04F0      		sts t_in,r24
 175:ir_heat.c     **** 	
 176:ir_heat.c     **** 	// Add data to the transmit buffer, enable TXCIE
 177:ir_heat.c     **** 	//
 178:ir_heat.c     **** 	tbuf[t_in & TMASK] = c;
 675               	,180,.LM45-.LFBB7
 676               	.LM45:
 677 0314 8091 0000 		ldi r26,lo8(193)
 678 0318 882F      		ldi r27,hi8(193)
 679 031a 90E0      		ldi r30,lo8(193)
 680 031c 8F71      		ldi r31,hi8(193)
 681 031e 9070      		ld r24,Z
 682 0320 FC01      		ori r24,lo8(32)
 683 0322 E050      		st X,r24
 685 0326 8981      	.LM46:
 686 0328 8083      		ldi r24,lo8(0)
 179:ir_heat.c     **** 	t_in++;	
 687               	(0)
 688               	/* epilogue start */
 690 032e 8F5F      	.LM47:
 691 0330 8093 0000 		pop __tmp_reg__
 180:ir_heat.c     **** 	UCSR0B |= (1<<UDRIE0);			// Enable UDR empty interrupt	
 692               	__tmp_reg__
 693               		pop __tmp_reg__
 694 0334 A1EC      		pop r28
 695 0336 B0E0      		pop r29
 696 0338 E1EC      		ret
 698 033c 8081      	.Lscope7:
 700 0340 8C93      	.global	rbuflen
 181:ir_heat.c     **** 	return(0);
 701               	uflen, @function
 702               	rbuflen:
 704 0344 90E0      	.LM48:
 705               	.LFBB8:
 182:ir_heat.c     **** }
 706               	 r29
 707               		push r28
 708 0346 0F90      		in r28,__SP_L__
 709 0348 0F90      		in r29,__SP_H__
 710 034a 0F90      	/* prologue: function */
 711 034c CF91      	/* frame size = 0 */
 713 0350 0895      	.LM49:
 714               		lds r25,r_in
 715               		lds r24,r_out
 716               		mov r18,r25
 717               		sub r18,r24
 718               		mov r24,r18
 719               	/* epilogue start */
 183:ir_heat.c     **** 
 184:ir_heat.c     **** char rbuflen(void) {
 720               	89,.LM50-.LFBB8
 721               	.LM50:
 722               		pop r28
 723 0352 DF93      		pop r29
 724 0354 CF93      		ret
 726 0358 DEB7      	.Lscope8:
 185:ir_heat.c     **** // ***************
 186:ir_heat.c     **** // Retrive pending chars in RX buffer
 187:ir_heat.c     **** //
 188:ir_heat.c     **** 	return(r_in - r_out);
 729               	ART_getchar
 731 035a 9091 0000 	UART_getchar:
 733 0362 292F      	.LM51:
 734 0364 281B      	.LFBB9:
 735 0366 822F      		push r29
 736               		push r28
 189:ir_heat.c     **** }
 737               	
 738               		push __tmp_reg__
 739 0368 CF91      		in r28,__SP_L__
 740 036a DF91      		in r29,__SP_H__
 741 036c 0895      	/* prologue: function */
 742               	/* frame size = 3 */
 743               		std Y+3,r25
 744               		std Y+2,r24
 745               	.L33:
 747               	.LM52:
 748               		call rbuflen
 190:ir_heat.c     **** 
 191:ir_heat.c     **** int UART_getchar(FILE *stream) {
 749               	req .L33
 751               	.LM53:
 752 036e DF93      		lds r24,r_out
 753 0370 CF93      		mov r24,r24
 754 0372 00D0      		ldi r25,lo8(0)
 755 0374 0F92      		andi r24,lo8(31)
 756 0376 CDB7      		andi r25,hi8(31)
 757 0378 DEB7      		movw r30,r24
 758               		subi r30,lo8(-(rbuf))
 759               		sbci r31,hi8(-(rbuf))
 760 037a 9B83      		ld r24,Z
 761 037c 8A83      		std Y+1,r24
 192:ir_heat.c     **** //*******************
 193:ir_heat.c     **** // Retieves character from UART. This function is to be passed
 194:ir_heat.c     **** // to fdevopen
 195:ir_heat.c     **** //
 196:ir_heat.c     **** 	unsigned char c;
 197:ir_heat.c     **** 	while(rbuflen() == 0);	  // Wait...
 763               	4,r_out
 764               		subi r24,lo8(-(1))
 765 037e 0E94 0000 		sts r_out,r24
 767 0384 01F0      	.LM55:
 198:ir_heat.c     **** 	c = rbuf[r_out & RMASK];
 768               	r24,Y+1
 769               		mov r24,r24
 770 0386 8091 0000 		ldi r25,lo8(0)
 771 038a 882F      	/* epilogue start */
 773 038e 8F71      	.LM56:
 774 0390 9070      		pop __tmp_reg__
 775 0392 FC01      		pop __tmp_reg__
 776 0394 E050      		pop __tmp_reg__
 777 0396 F040      		pop r28
 778 0398 8081      		pop r29
 779 039a 8983      		ret
 199:ir_heat.c     **** 	r_out++;	
 780               	getchar, .-UART_getchar
 784 03a2 8093 0000 	.Lscope9:
 200:ir_heat.c     **** 	return(c);
 785               	bs	"UART_first_init:F(0,15)",36,0,0,UART_first_init
 786               	.global	UART_first_init
 788 03a8 882F      	UART_first_init:
 790               	.LM57:
 201:ir_heat.c     **** }
 791               	0:
 792               		push r29
 793 03ac 0F90      		push r28
 794 03ae 0F90      		in r28,__SP_L__
 795 03b0 0F90      		in r29,__SP_H__
 796 03b2 CF91      	/* prologue: function */
 797 03b4 DF91      	/* frame size = 0 */
 799               	.LM58:
 800               		ldi r30,lo8(196)
 801               		ldi r31,hi8(196)
 802               		ldi r24,lo8(12)
 803               		ldi r25,hi8(12)
 804               		std Z+1,r25
 805               		st Z,r24
 807               	.LM59:
 202:ir_heat.c     **** 
 203:ir_heat.c     **** void UART_first_init(void) {
 808               	
 809               		ldi r31,hi8(193)
 810               		ldi r24,lo8(-104)
 811 03b8 DF93      		st Z,r24
 813 03bc CDB7      	.LM60:
 814 03be DEB7      		ldi r30,lo8(194)
 815               		ldi r31,hi8(194)
 816               		ldi r24,lo8(6)
 204:ir_heat.c     **** //***********************
 205:ir_heat.c     **** // The function fdevopen(..) must contain as parameters the
 206:ir_heat.c     **** // corresponding  ..putchar() and  ..getchar() functions, defined before.
 207:ir_heat.c     **** //
 208:ir_heat.c     **** 	UBRR0 = 12;										 // 4800 BPS
 817               	4
 819 03c0 E4EC      	.LM61:
 820 03c2 F0E0      		ldi r24,lo8(gs(UART_putchar))
 821 03c4 8CE0      		ldi r25,hi8(gs(UART_putchar))
 822 03c6 90E0      		ldi r18,lo8(gs(UART_getchar))
 823 03c8 9183      		ldi r19,hi8(gs(UART_getchar))
 824 03ca 8083      		movw r22,r18
 209:ir_heat.c     **** 	
 210:ir_heat.c     **** 	UCSR0B = (1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0);	 // 8 Databits, receive and transmit enabled, receive 
 825               	evopen
 827 03cc E1EC      	.LM62:
 828 03ce F0E0      	/* #APP */
 829 03d0 88E9      	 ;  214 "ir_heat.c" 1
 830 03d2 8083      		sei
 211:ir_heat.c     **** 	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
 831               	"" 2
 832               	/* epilogue start */
 834 03d6 F0E0      	.LM63:
 835 03d8 86E0      	/* #NOAPP */
 836 03da 8083      		pop r28
 212:ir_heat.c     **** 	
 213:ir_heat.c     **** 	fdevopen(UART_putchar, UART_getchar);
 837               	29
 838               		ret
 840 03de 90E0      	.Lscope10:
 841 03e0 20E0      		.data
 842 03e2 30E0      	.LC1:
 843 03e4 B901      		.string	"Array:"
 844 03e6 0E94 0000 	.LC2:
 214:ir_heat.c     **** 	sei();											 // Global interrupt enable
 845               		" %i"
 846               		.text
 848               	.global	print_array
 850               	print_array:
 215:ir_heat.c     **** }
 852               	.LFBB11:
 853               		push r29
 854               		push r28
 855 03ec CF91      		push __tmp_reg__
 856 03ee DF91      		in r28,__SP_L__
 857 03f0 0895      		in r29,__SP_H__
 858               	/* prologue: function */
 859               	/* frame size = 1 */
 861               	.LM65:
 862 0011 4172 7261 		rcall .
 862      793A 00
 863               		in r30,__SP_L__
 864 0018 2025 6900 		in r31,__SP_H__
 865               		adiw r30,1
 866               		ldi r24,lo8(.LC1)
 867               		ldi r25,hi8(.LC1)
 868               		std Z+1,r25
 869               		st Z,r24
 216:ir_heat.c     **** 
 217:ir_heat.c     **** 
 218:ir_heat.c     **** void print_array(){
 870               	__tmp_reg__
 871               		pop __tmp_reg__
 873 03f2 DF93      	.LM66:
 874 03f4 CF93      		std Y+1,__zero_reg__
 875 03f6 0F92      		rjmp .L38
 876 03f8 CDB7      	.L39:
 878               	.LM67:
 879               		ldd r24,Y+1
 219:ir_heat.c     **** 	uint8_t i;
 220:ir_heat.c     ****   	printf("Array:");
 880               	24
 881               		ldi r25,lo8(0)
 882 03fc 00D0      		lsl r24
 883 03fe EDB7      		rol r25
 884 0400 FEB7      		movw r30,r24
 885 0402 3196      		subi r30,lo8(-(t_array))
 886 0404 80E0      		sbci r31,hi8(-(t_array))
 887 0406 90E0      		ld r18,Z
 888 0408 9183      		ldd r19,Z+1
 889 040a 8083      		rcall .
 890 040c 0E94 0000 		rcall .
 891 0410 0F90      		in r30,__SP_L__
 892 0412 0F90      		in r31,__SP_H__
 221:ir_heat.c     **** 	for(i=0;i<6;i++) {
 893               	ldi r24,lo8(.LC2)
 894               		ldi r25,hi8(.LC2)
 895 0414 1982      		std Z+1,r25
 896 0416 00C0      		st Z,r24
 897               		std Z+3,r19
 222:ir_heat.c     ****    	printf(" %i", t_array[i]);
 898               	Z+2,r18
 899               		call printf
 900 0418 8981      		pop __tmp_reg__
 901 041a 882F      		pop __tmp_reg__
 902 041c 90E0      		pop __tmp_reg__
 903 041e 880F      		pop __tmp_reg__
 905 0422 FC01      	.LM68:
 906 0424 E050      		ldd r24,Y+1
 907 0426 F040      		subi r24,lo8(-(1))
 908 0428 2081      		std Y+1,r24
 909 042a 3181      	.L38:
 910 042c 00D0      		ldd r24,Y+1
 911 042e 00D0      		cpi r24,lo8(6)
 912 0430 EDB7      		brlo .L39
 914 0434 3196      	.LM69:
 915 0436 80E0      		ldi r24,lo8(10)
 916 0438 90E0      		ldi r25,hi8(10)
 917 043a 9183      		call putchar
 918 043c 8083      	/* epilogue start */
 920 0440 2283      	.LM70:
 921 0442 0E94 0000 		pop __tmp_reg__
 922 0446 0F90      		pop r28
 923 0448 0F90      		pop r29
 924 044a 0F90      		ret
 929 0450 8F5F      	.Lscope11:
 932 0454 8981      	.global	add_value
 934 0458 00F0      	add_value:
 223:ir_heat.c     **** 	}
 224:ir_heat.c     ****   	printf("\n");
 935               	
 936               	.LFBB12:
 937 045a 8AE0      		push r29
 938 045c 90E0      		push r28
 939 045e 0E94 0000 		rcall .
 940               		push __tmp_reg__
 225:ir_heat.c     **** }
 941               	28,__SP_L__
 942               		in r29,__SP_H__
 943 0462 0F90      	/* prologue: function */
 944 0464 CF91      	/* frame size = 3 */
 945 0466 DF91      		std Y+3,r25
 946 0468 0895      		std Y+2,r24
 948               	.LM72:
 949               		lds r24,t_array
 950               		lds r25,(t_array)+1
 951               		sbiw r24,0
 952               		brne .L42
 954               	.LM73:
 955               		ldd r24,Y+2
 956               		ldd r25,Y+3
 226:ir_heat.c     **** 
 227:ir_heat.c     **** 
 228:ir_heat.c     **** void add_value(uint16_t value) {
 957               	)+1,r25
 958               		sts t_array+10,r24
 959               		lds r24,t_array+10
 960 046a DF93      		lds r25,(t_array+10)+1
 961 046c CF93      		sts (t_array+8)+1,r25
 962 046e 00D0      		sts t_array+8,r24
 963 0470 0F92      		lds r24,t_array+8
 964 0472 CDB7      		lds r25,(t_array+8)+1
 965 0474 DEB7      		sts (t_array+6)+1,r25
 966               		sts t_array+6,r24
 967               		lds r24,t_array+6
 968 0476 9B83      		lds r25,(t_array+6)+1
 969 0478 8A83      		sts (t_array+4)+1,r25
 229:ir_heat.c     **** 	uint8_t i;
 230:ir_heat.c     **** 	if(t_array[0]==0) {
 970               	4,r24
 971               		lds r24,t_array+4
 972 047a 8091 0000 		lds r25,(t_array+4)+1
 973 047e 9091 0000 		sts (t_array+2)+1,r25
 974 0482 0097      		sts t_array+2,r24
 975 0484 01F4      		lds r24,t_array+2
 231:ir_heat.c     **** 	t_array[0]=t_array[1]=t_array[2]=t_array[3]=t_array[4]=t_array[5]=value;
 976               	25,(t_array+2)+1
 977               		sts (t_array)+1,r25
 978 0486 8A81      		sts t_array,r24
 979 0488 9B81      		rjmp .L46
 980 048a 9093 0000 	.L42:
 982 0492 8091 0000 	.LM74:
 983 0496 9091 0000 		std Y+1,__zero_reg__
 984 049a 9093 0000 		rjmp .L44
 985 049e 8093 0000 	.L45:
 987 04a6 9091 0000 	.LM75:
 988 04aa 9093 0000 		ldd r24,Y+1
 989 04ae 8093 0000 		mov r20,r24
 990 04b2 8091 0000 		ldi r21,lo8(0)
 991 04b6 9091 0000 		ldd r24,Y+1
 992 04ba 9093 0000 		mov r24,r24
 993 04be 8093 0000 		ldi r25,lo8(0)
 994 04c2 8091 0000 		adiw r24,1
 995 04c6 9091 0000 		lsl r24
 996 04ca 9093 0000 		rol r25
 997 04ce 8093 0000 		movw r30,r24
 998 04d2 8091 0000 		subi r30,lo8(-(t_array))
 999 04d6 9091 0000 		sbci r31,hi8(-(t_array))
 1000 04da 9093 0000 		ld r18,Z
 1001 04de 8093 0000 		ldd r19,Z+1
 1002 04e2 00C0      		movw r24,r20
 1003               		lsl r24
 232:ir_heat.c     **** 	}
 233:ir_heat.c     **** 	else {
 234:ir_heat.c     **** 		for(i=0;i<=6;i++) {
 1004               	 r30,lo8(-(t_array))
 1005               		sbci r31,hi8(-(t_array))
 1006 04e4 1982      		std Z+1,r19
 1007 04e6 00C0      		st Z,r18
 235:ir_heat.c     **** 			t_array[i]=t_array[i+1];
 1009               	:
 1010               		ldd r24,Y+1
 1011 04e8 8981      		subi r24,lo8(-(1))
 1012 04ea 482F      		std Y+1,r24
 1013 04ec 50E0      	.L44:
 1014 04ee 8981      		ldd r24,Y+1
 1015 04f0 882F      		cpi r24,lo8(7)
 1016 04f2 90E0      		brlo .L45
 1018 04f6 880F      	.LM77:
 1019 04f8 991F      		ldd r24,Y+2
 1020 04fa FC01      		ldd r25,Y+3
 1021 04fc E050      		sts (t_array+10)+1,r25
 1022 04fe F040      		sts t_array+10,r24
 1023 0500 2081      	.L46:
 1024 0502 3181      	/* epilogue start */
 1026 0506 880F      	.LM78:
 1027 0508 991F      		pop __tmp_reg__
 1028 050a FC01      		pop __tmp_reg__
 1029 050c E050      		pop __tmp_reg__
 1030 050e F040      		pop r28
 1031 0510 3183      		pop r29
 1032 0512 2083      		ret
 1037 0518 8983      	.Lscope12:
 1039 051a 8981      	.global	get_slope
 1041 051e 00F0      	get_slope:
 236:ir_heat.c     **** 		}
 237:ir_heat.c     **** 		t_array[5]=value;
 1042               	M79:
 1043               	.LFBB13:
 1044 0520 8A81      		push r29
 1045 0522 9B81      		push r28
 1046 0524 9093 0000 		rcall .
 1047 0528 8093 0000 		rcall .
 1048               		rcall .
 1049               		in r28,__SP_L__
 238:ir_heat.c     **** 	}
 239:ir_heat.c     **** }
 1050               	__SP_H__
 1051               	/* prologue: function */
 1052 052c 0F90      	/* frame size = 6 */
 1054 0530 0F90      	.LM80:
 1055 0532 CF91      		lds r18,t_array+10
 1056 0534 DF91      		lds r19,(t_array+10)+1
 1057 0536 0895      		lds r24,t_array
 1058               		lds r25,(t_array)+1
 1059               		movw r20,r18
 1060               		sub r20,r24
 1061               		sbc r21,r25
 1062               		movw r24,r20
 1063               		std Y+6,r25
 1064               		std Y+5,r24
 1066               	.LM81:
 240:ir_heat.c     **** 
 241:ir_heat.c     **** 
 242:ir_heat.c     **** int8_t get_slope() {
 1067               	8
 1068               		lds r19,(t_array+8)+1
 1069               		lds r24,t_array+2
 1070 0538 DF93      		lds r25,(t_array+2)+1
 1071 053a CF93      		movw r20,r18
 1072 053c 00D0      		sub r20,r24
 1073 053e 00D0      		sbc r21,r25
 1074 0540 00D0      		movw r24,r20
 1075 0542 CDB7      		std Y+4,r25
 1076 0544 DEB7      		std Y+3,r24
 1078               	.LM82:
 243:ir_heat.c     **** 	int16_t s1, s2, s3;
 244:ir_heat.c     **** 
 245:ir_heat.c     **** 	s1 = t_array[5] - t_array[0];
 1079               	rray+6
 1080               		lds r19,(t_array+6)+1
 1081 0546 2091 0000 		lds r24,t_array+4
 1082 054a 3091 0000 		lds r25,(t_array+4)+1
 1083 054e 8091 0000 		movw r20,r18
 1084 0552 9091 0000 		sub r20,r24
 1085 0556 A901      		sbc r21,r25
 1086 0558 481B      		movw r24,r20
 1087 055a 590B      		std Y+2,r25
 1088 055c CA01      		std Y+1,r24
 1090 0560 8D83      	.LM83:
 246:ir_heat.c     **** 	s2 = t_array[4] - t_array[1];
 1091               	
 1092               		ldd r19,Y+6
 1093 0562 2091 0000 		movw r24,r18
 1094 0566 3091 0000 		lsl r24
 1095 056a 8091 0000 		rol r25
 1096 056e 9091 0000 		movw r20,r24
 1097 0572 A901      		add r20,r18
 1098 0574 481B      		adc r21,r19
 1099 0576 590B      		ldd r18,Y+3
 1100 0578 CA01      		ldd r19,Y+4
 1101 057a 9C83      		movw r24,r18
 1102 057c 8B83      		lsl r24
 247:ir_heat.c     **** 	s3 = t_array[3] - t_array[2];
 1103               	sl r24
 1104               		rol r25
 1105 057e 2091 0000 		add r24,r18
 1106 0582 3091 0000 		adc r25,r19
 1107 0586 8091 0000 		add r20,r24
 1108 058a 9091 0000 		adc r21,r25
 1109 058e A901      		ldd r18,Y+1
 1110 0590 481B      		ldd r19,Y+2
 1111 0592 590B      		movw r24,r18
 1112 0594 CA01      		lsl r24
 1113 0596 9A83      		rol r25
 1114 0598 8983      		add r24,r18
 248:ir_heat.c     **** 	
 249:ir_heat.c     **** 	return (int8_t)((3*s1+5*s2+15*s3)/9);
 1115               	
 1116               		movw r18,r24
 1117 059a 2D81      		lsl r18
 1118 059c 3E81      		rol r19
 1119 059e C901      		lsl r18
 1120 05a0 880F      		rol r19
 1121 05a2 991F      		add r24,r18
 1122 05a4 AC01      		adc r25,r19
 1123 05a6 420F      		add r24,r20
 1124 05a8 531F      		adc r25,r21
 1125 05aa 2B81      		ldi r18,lo8(9)
 1126 05ac 3C81      		ldi r19,hi8(9)
 1127 05ae C901      		movw r22,r18
 1128 05b0 880F      		call __divmodhi4
 1129 05b2 991F      		movw r24,r22
 1130 05b4 880F      	/* epilogue start */
 1132 05b8 820F      	.LM84:
 1133 05ba 931F      		adiw r28,6
 1134 05bc 480F      		in __tmp_reg__,__SREG__
 1135 05be 591F      		cli
 1136 05c0 2981      		out __SP_H__,r29
 1137 05c2 3A81      		out __SREG__,__tmp_reg__
 1138 05c4 C901      		out __SP_L__,r28
 1139 05c6 880F      		pop r28
 1140 05c8 991F      		pop r29
 1141 05ca 820F      		ret
 1148 05d8 820F      	.Lscope13:
 1152 05e0 29E0      	.global	lookahead_temp
 1154 05e4 B901      	lookahead_temp:
 1156 05ea CB01      	.LM85:
 1157               	.LFBB14:
 250:ir_heat.c     **** }
 1158               	29,__SP_H__
 1159               		sbiw r28,7
 1160 05ec 2696      		in __tmp_reg__,__SREG__
 1161 05ee 0FB6      		cli
 1162 05f0 F894      		out __SP_H__,r29
 1163 05f2 DEBF      		out __SREG__,__tmp_reg__
 1164 05f4 0FBE      		out __SP_L__,r28
 1165 05f6 CDBF      	/* prologue: function */
 1166 05f8 CF91      	/* frame size = 7 */
 1167 05fa DF91      		std Y+6,r24
 1168 05fc 0895      		std Y+7,r22
 1170               	.LM86:
 1171               		std Y+5,__zero_reg__
 1172               		std Y+4,__zero_reg__
 1174               	.LM87:
 1175               		lds r18,t_array+10
 1176               		lds r19,(t_array+10)+1
 1177               		lds r24,t_array+8
 1178               		lds r25,(t_array+8)+1
 1179               		add r24,r18
 1180               		adc r25,r19
 1181               		lsr r25
 251:ir_heat.c     **** 
 252:ir_heat.c     **** 
 253:ir_heat.c     **** int16_t lookahead_temp(int8_t slope, uint8_t steps) {
 1182               	td Y+2,r24
 1184               	.LM88:
 1185 05fe DF93      		ldd r24,Y+7
 1186 0600 CF93      		mov r18,r24
 1187 0602 CDB7      		ldi r19,lo8(0)
 1188 0604 DEB7      		ldd r24,Y+6
 1189 0606 2797      		clr r25
 1190 0608 0FB6      		sbrc r24,7
 1191 060a F894      		com r25
 1192 060c DEBF      		movw r20,r24
 1193 060e 0FBE      		mul r18,r20
 1194 0610 CDBF      		movw r24,r0
 1195               		mul r18,r21
 1196               		add r25,r0
 1197 0612 8E83      		mul r19,r20
 1198 0614 6F83      		add r25,r0
 254:ir_heat.c     **** 	int16_t max = 0;
 1199               	,r24
 1200               		ldd r24,Y+2
 1201 0616 1D82      		ldd r25,Y+3
 1202 0618 1C82      		add r24,r18
 255:ir_heat.c     **** 	uint16_t av;
 256:ir_heat.c     **** 	uint8_t i;
 257:ir_heat.c     **** //	for(i=0;i<6;i++) {
 258:ir_heat.c     **** //		if(t_array[i]>max) max=t_array[i];
 259:ir_heat.c     **** //	}
 260:ir_heat.c     **** 	av = (t_array[5]+t_array[4])>>1;
 1203               	 r25,r19
 1204               	/* epilogue start */
 1206 061e 3091 0000 	.LM89:
 1207 0622 8091 0000 		adiw r28,7
 1208 0626 9091 0000 		in __tmp_reg__,__SREG__
 1209 062a 820F      		cli
 1210 062c 931F      		out __SP_H__,r29
 1211 062e 9695      		out __SREG__,__tmp_reg__
 1212 0630 8795      		out __SP_L__,r28
 1213 0632 9B83      		pop r28
 1214 0634 8A83      		pop r29
 261:ir_heat.c     **** 	return (av + steps*(int16_t)slope);
 1215               	lookahead_temp, .-lookahead_temp
 1221 063e 9927      	.Lscope14:
 1224 0644 AC01      	.global	get_temperature
 1226 0648 C001      	get_temperature:
 1228 064c 900D      	.LM90:
 1229 064e 349F      	.LFBB15:
 1230 0650 900D      		push r29
 1231 0652 1124      		push r28
 1232 0654 9C01      		in r28,__SP_L__
 1233 0656 8A81      		in r29,__SP_H__
 1234 0658 9B81      		sbiw r28,15
 1235 065a 820F      		in __tmp_reg__,__SREG__
 1236 065c 931F      		cli
 1237               		out __SP_H__,r29
 262:ir_heat.c     **** }
 1238               	__
 1239               		out __SP_L__,r28
 1240 065e 2796      	/* prologue: function */
 1241 0660 0FB6      	/* frame size = 15 */
 1242 0662 F894      		std Y+13,r24
 1244 0666 0FBE      	.LM91:
 1245 0668 CDBF      		ldi r24,lo8(-76)
 1246 066a CF91      		call i2c_start
 1248 066e 0895      	.LM92:
 1249               		ldd r24,Y+13
 1250               		call i2c_write
 1252               	.LM93:
 1253               		ldi r24,lo8(181)
 1254               		ldi r25,hi8(181)
 1255               		call i2c_rep_start
 1256               		std Y+4,r24
 1258               	.LM94:
 1259               		ldd r24,Y+4
 1260               		tst r24
 263:ir_heat.c     **** 
 264:ir_heat.c     **** 
 265:ir_heat.c     **** 
 266:ir_heat.c     **** uint16_t get_temperature(uint8_t adr) {
 1261               	,277,.LM95-.LFBB15
 1262               	.LM95:
 1263               		ldi r24,lo8(181)
 1264 0670 DF93      		ldi r25,hi8(181)
 1265 0672 CF93      		call i2c_rep_start
 1266 0674 CDB7      	.L52:
 1268 0678 2F97      	.LM96:
 1269 067a 0FB6      		call i2c_read_ack
 1270 067c F894      		std Y+3,r24
 1272 0680 0FBE      	.LM97:
 1273 0682 CDBF      		call i2c_read_ack
 1274               		std Y+2,r24
 1276 0684 8D87      	.LM98:
 267:ir_heat.c     **** 	uint16_t raw;
 268:ir_heat.c     **** 	uint8_t 	ret;
 269:ir_heat.c     **** 	uint8_t 	lo, hi, pec;
 270:ir_heat.c     **** 	uint8_t	pec_read[6];
 271:ir_heat.c     **** 
 272:ir_heat.c     **** 	i2c_start(MLX90614_WRITE);
 1277               	v r24,r24
 1278               		ldi r25,lo8(0)
 1279 0686 84EB      		mov r25,r24
 1280 0688 0E94 0000 		clr r24
 273:ir_heat.c     **** 	i2c_write(adr);
 1281               	w r18,r24
 1282               		ldd r24,Y+3
 1283 068c 8D85      		mov r24,r24
 1284 068e 0E94 0000 		ldi r25,lo8(0)
 274:ir_heat.c     **** 	
 275:ir_heat.c     **** 	ret = i2c_rep_start(MLX90614_READ);
 1285               	 r24,r18
 1286               		adc r25,r19
 1287 0692 85EB      		std Y+6,r25
 1288 0694 90E0      		std Y+5,r24
 1290 069a 8C83      	.LM99:
 276:ir_heat.c     **** 	if(ret) {
 1291               	i2c_read_ack
 1292               		std Y+1,r24
 1294 069e 8823      	.LM100:
 1295 06a0 01F0      		call i2c_stop
 277:ir_heat.c     **** 		i2c_rep_start(MLX90614_READ);
 1296               	bn	68,0,287,.LM101-.LFBB15
 1297               	.LM101:
 1298 06a2 85EB      		ldd r24,Y+5
 1299 06a4 90E0      		ldd r25,Y+6
 1300 06a6 0E94 0000 		tst r25
 1301               		brge .L53
 278:ir_heat.c     ****    }
 279:ir_heat.c     **** 
 280:ir_heat.c     **** 	lo = i2c_read_ack();
 1302               	+15,__zero_reg__
 1303               		std Y+14,__zero_reg__
 1304 06aa 0E94 0000 		rjmp .L54
 1305 06ae 8B83      	.L53:
 281:ir_heat.c     **** 	hi = i2c_read_ack();
 1306               	abn	68,0,289,.LM102-.LFBB15
 1307               	.LM102:
 1308 06b0 0E94 0000 		ldd r24,Y+5
 1309 06b4 8A83      		ldd r25,Y+6
 282:ir_heat.c     **** 	raw = (uint16_t)(hi<<8)+lo;
 1310               	 r18,lo8(5)
 1311               		ldi r19,hi8(5)
 1312 06b6 8A81      		movw r22,r18
 1313 06b8 882F      		call __udivmodhi4
 1314 06ba 90E0      		movw r24,r22
 1315 06bc 982F      		movw r18,r24
 1316 06be 8827      		subi r18,lo8(-(-2731))
 1317 06c0 9C01      		sbci r19,hi8(-(-2731))
 1318 06c2 8B81      		std Y+15,r19
 1319 06c4 882F      		std Y+14,r18
 1320 06c6 90E0      	.L54:
 1321 06c8 820F      		ldd r24,Y+14
 1322 06ca 931F      		ldd r25,Y+15
 1323 06cc 9E83      	/* epilogue start */
 283:ir_heat.c     **** 	//printf("0x%04x\n", raw);
 284:ir_heat.c     **** 	pec = i2c_read_ack();
 1325               	28,15
 1326               		in __tmp_reg__,__SREG__
 1327 06d0 0E94 0000 		cli
 1328 06d4 8983      		out __SP_H__,r29
 285:ir_heat.c     **** 	
 286:ir_heat.c     **** 	i2c_stop();
 1329               	 __SREG__,__tmp_reg__
 1330               		out __SP_L__,r28
 1331 06d6 0E94 0000 		pop r28
 287:ir_heat.c     **** 	if(raw & 0x8000) return 0;
 1332               	p r29
 1333               		ret
 288:ir_heat.c     **** 	
 289:ir_heat.c     **** 	return (raw / 5 - 2731);
 1342               	4,0,0,.Lscope15-.LFBB15
 1343               	.Lscope15:
 1344 06e8 8D81      		.lcomm last.1904,1
 1345 06ea 9E81      		.data
 1346 06ec 25E0      	.LC3:
 1347 06ee 30E0      		.string	">>> Relais ON"
 1348 06f0 B901      	.LC4:
 1349 06f2 0E94 0000 		.string	">>> Relais OFF"
 1350 06f6 CB01      		.text
 1353 06fc 3A40      	.global	set_relais
 1355 0700 2E87      	set_relais:
 1357 0702 8E85      	.LM104:
 1358 0704 9F85      	.LFBB16:
 1359               		push r29
 290:ir_heat.c     **** }
 1360               	
 1361               		in r28,__SP_L__
 1362 0706 2F96      		in r29,__SP_H__
 1363 0708 0FB6      	/* prologue: function */
 1364 070a F894      	/* frame size = 2 */
 1365 070c DEBF      		std Y+2,r25
 1366 070e 0FBE      		std Y+1,r24
 1368 0712 CF91      	.LM105:
 1369 0714 DF91      		ldd r24,Y+1
 1370 0716 0895      		ldd r25,Y+2
 1371               		sbiw r24,0
 1372               		breq .L57
 1374               	.LM106:
 1375               		lds r24,last.1904
 1376               		mov r18,r24
 1377               		ldi r19,lo8(0)
 1378               		ldd r24,Y+1
 1379               		ldd r25,Y+2
 1380               		cp r18,r24
 1381               		cpc r19,r25
 1382               		breq .L58
 1383               		ldi r24,lo8(.LC3)
 1384 001c 3E3E 3E20 		ldi r25,hi8(.LC3)
 1384      5265 6C61 
 1384      6973 204F 
 1384      4E00 
 1385               		call puts
 1386 002a 3E3E 3E20 	.L58:
 1386      5265 6C61 
 1386      6973 204F 
 1386      4646 00
 1388               	.LM107:
 1389               		ldi r26,lo8(37)
 1390               		ldi r27,hi8(37)
 1391               		ldi r30,lo8(37)
 1392               		ldi r31,hi8(37)
 291:ir_heat.c     **** 
 292:ir_heat.c     **** void set_relais(on) {
 1393               	 X,r24
 1394               		rjmp .L59
 1395               	.L57:
 1397 071a CF93      	.LM108:
 1398 071c 00D0      		lds r24,last.1904
 1399 071e CDB7      		mov r18,r24
 1400 0720 DEB7      		ldi r19,lo8(0)
 1401               		ldd r24,Y+1
 1402               		ldd r25,Y+2
 1403 0722 9A83      		cp r18,r24
 1404 0724 8983      		cpc r19,r25
 293:ir_heat.c     **** 	static uint8_t last = 0;
 294:ir_heat.c     **** 	if(on) {
 1405               	ldi r24,lo8(.LC4)
 1406               		ldi r25,hi8(.LC4)
 1407 0726 8981      		call puts
 1408 0728 9A81      	.L60:
 1410 072c 01F0      	.LM109:
 295:ir_heat.c     **** 		if(on != last) printf(">>> Relais ON\n");
 1411               	26,lo8(37)
 1412               		ldi r27,hi8(37)
 1413 072e 8091 0000 		ldi r30,lo8(37)
 1414 0732 282F      		ldi r31,hi8(37)
 1415 0734 30E0      		ld r24,Z
 1416 0736 8981      		andi r24,lo8(127)
 1417 0738 9A81      		st X,r24
 1418 073a 2817      	.L59:
 1420 073e 01F0      	.LM110:
 1421 0740 80E0      		ldd r24,Y+1
 1422 0742 90E0      		sts last.1904,r24
 1423 0744 0E94 0000 	/* epilogue start */
 296:ir_heat.c     **** 		RELAIS_ON;
 1425               	_tmp_reg__
 1426               		pop __tmp_reg__
 1427 0748 A5E2      		pop r28
 1428 074a B0E0      		pop r29
 1429 074c E5E2      		ret
 1434 0756 00C0      	.Lscope16:
 297:ir_heat.c     **** 	}
 298:ir_heat.c     **** 	else {
 299:ir_heat.c     **** 		if(on != last) printf(">>> Relais OFF\n");
 1436               	function
 1438 0758 8091 0000 	my_function:
 1440 075e 30E0      	.LM112:
 1441 0760 8981      	.LFBB17:
 1442 0762 9A81      		push r29
 1443 0764 2817      		push r28
 1444 0766 3907      		in r28,__SP_L__
 1445 0768 01F0      		in r29,__SP_H__
 1446 076a 80E0      	/* prologue: function */
 1447 076c 90E0      	/* frame size = 0 */
 1449               	.LM113:
 300:ir_heat.c     **** 		RELAIS_OFF;
 1450               	 311 "ir_heat.c" 1
 1451               		nop
 1452 0772 A5E2      	 ;  0 "" 2
 1453 0774 B0E0      	/* epilogue start */
 1455 0778 F0E0      	.LM114:
 1456 077a 8081      	/* #NOAPP */
 1457 077c 8F77      		pop r28
 1458 077e 8C93      		pop r29
 1459               		ret
 301:ir_heat.c     **** 	}
 302:ir_heat.c     **** 	last = on;
 1460               	function, .-my_function
 1461               	.Lscope17:
 1462 0780 8981      		.data
 1463 0782 8093 0000 	.LC5:
 1464               		.string	"\nStartup"
 303:ir_heat.c     **** }
 1465               	
 1466               		.string	"Error Temp=0"
 1467 0786 0F90      	.LC7:
 1468 0788 0F90      		.string	"Temp: %i, "
 1469 078a CF91      	.LC8:
 1470 078c DF91      		.string	"slope: %i, "
 1471 078e 0895      	.LC9:
 1472               		.string	"Prognose: %i\n"
 1473               	.LC10:
 1474               		.string	"Counter: %i; "
 1475               		.text
 1477               	.global	main
 1479               	main:
 304:ir_heat.c     **** 
 305:ir_heat.c     **** // It is recommended to use this coding style to
 306:ir_heat.c     **** // follow better the mixed C-assembly code in the
 307:ir_heat.c     **** // Program Memory window
 308:ir_heat.c     **** //
 309:ir_heat.c     **** void my_function(void) {  // Put the open brace '{' here
 1481               	:
 1482               		push r16
 1483               		push r17
 1484 0790 DF93      		push r29
 1485 0792 CF93      		push r28
 1486 0794 CDB7      		in r28,__SP_L__
 1487 0796 DEB7      		in r29,__SP_H__
 1488               		sbiw r28,17
 1489               		in __tmp_reg__,__SREG__
 310:ir_heat.c     **** 
 311:ir_heat.c     ****    asm("nop");          // Inline assembly example
 1490               	 __SP_H__,r29
 1491               		out __SREG__,__tmp_reg__
 1492               		out __SP_L__,r28
 1493               	/* prologue: function */
 1494 0798 0000      	/* frame size = 17 */
 1496               	.LM116:
 312:ir_heat.c     **** }
 1497               	0,lo8(36)
 1498               		ldi r31,hi8(36)
 1499               		ldi r24,lo8(-64)
 1500 079a CF91      		st Z,r24
 1502 079e 0895      	.LM117:
 1503               		ldi r30,lo8(39)
 1504               		ldi r31,hi8(39)
 1505               		ldi r24,lo8(8)
 1506               		st Z,r24
 1508               	.LM118:
 1509 0042 4572 726F 		ldi r30,lo8(42)
 1509      7220 5465 
 1509      6D70 3D30 
 1509      00
 1510               		ldi r31,hi8(42)
 1511 004f 5465 6D70 		ldi r24,lo8(24)
 1511      3A20 2569 
 1511      2C20 00
 1512               		st Z,r24
 1514               	.LM119:
 1515 0066 5072 6F67 		ldi r30,lo8(37)
 1515      6E6F 7365 
 1515      3A20 2569 
 1515      0A00 
 1516               		ldi r31,hi8(37)
 1517 0074 436F 756E 		ldi r24,lo8(63)
 1517      7465 723A 
 1517      2025 693B 
 1517      2000 
 1518               		st Z,r24
 1520               	.LM120:
 1521               		ldi r30,lo8(40)
 1522               		ldi r31,hi8(40)
 313:ir_heat.c     **** 
 314:ir_heat.c     **** 
 315:ir_heat.c     **** 
 316:ir_heat.c     **** 
 317:ir_heat.c     **** // ***********************************************************
 318:ir_heat.c     **** // Main program
 319:ir_heat.c     **** //
 320:ir_heat.c     **** int main(void) {
 1523               	
 1525               	.LM121:
 1526 07a0 0F93      		ldi r30,lo8(43)
 1527 07a2 1F93      		ldi r31,hi8(43)
 1528 07a4 DF93      		ldi r24,lo8(-25)
 1529 07a6 CF93      		st Z,r24
 1531 07aa DEB7      	.LM122:
 1532 07ac 6197      		ldi r30,lo8(100)
 1533 07ae 0FB6      		ldi r31,hi8(100)
 1534 07b0 F894      		ld r18,Z
 1536 07b4 0FBE      	.LM123:
 1537 07b6 CDBF      	/* #APP */
 1538               	 ;  332 "ir_heat.c" 1
 1539               		wdr
 321:ir_heat.c     **** 
 322:ir_heat.c     **** 	DDRB = 0x00 | (1<<RELAIS) | (1<<BUZZER);
 1540               	bn	68,0,333,.LM124-.LFBB18
 1541               	.LM124:
 1542 07b8 E4E2      	/* #NOAPP */
 1543 07ba F0E0      		ldi r24,lo8(24)
 1544 07bc 80EC      		ldi r25,hi8(24)
 1545 07be 8083      		ldi r18,lo8(15)
 323:ir_heat.c     **** 	DDRC = 0x00 | (1<<FLASH_LED);
 1546               	P */
 1547               	 ;  333 "ir_heat.c" 1
 1548 07c0 E7E2      		in __tmp_reg__,__SREG__
 1549 07c2 F0E0      		cli
 1550 07c4 88E0      		wdr
 1551 07c6 8083      		sts 96,r24
 324:ir_heat.c     **** 	DDRD = 0x00 | (1<<STATUS_LED1) | (1<<STATUS_LED2);
 1552               	_SREG__,__tmp_reg__
 1553               		sts 96,r18
 1554 07c8 EAE2      		
 1555 07ca F0E0      	 ;  0 "" 2
 1557 07ce 8083      	.LM125:
 325:ir_heat.c     **** 
 326:ir_heat.c     **** 	PORTB = ~((1<<RELAIS) | (1<<BUZZER));
 1558               	APP */
 1559               		call UART_first_init
 1561 07d2 F0E0      	.LM126:
 1562 07d4 8FE3      		call i2c_init
 327:ir_heat.c     **** 	PORTC = ~(1<<FLASH_LED);
 1564               	:
 1565               		sts interval,__zero_reg__
 1567 07da F0E0      	.LM128:
 1568 07dc 87EF      		ldi r30,lo8(177)
 1569 07de 8083      		ldi r31,hi8(177)
 328:ir_heat.c     **** 	PORTD = ~((1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED));
 1570               	24,lo8(7)
 1571               		st Z,r24
 1573 07e2 F0E0      	.LM129:
 1574 07e4 87EE      		ldi r30,lo8(112)
 1575 07e6 8083      		ldi r31,hi8(112)
 329:ir_heat.c     **** 
 330:ir_heat.c     **** 	PRR != ~(1<<PRTWI);
 1576               	24,lo8(1)
 1577               		st Z,r24
 1579 07ea F0E0      	.LM130:
 1580 07ec 2081      		ldi r30,lo8(68)
 331:ir_heat.c     **** 
 332:ir_heat.c     **** 	wdt_reset();
 1581               	r31,hi8(68)
 1582               		st Z,__zero_reg__
 1584               	.LM131:
 1585 07ee A895      		ldi r30,lo8(69)
 1586               		ldi r31,hi8(69)
 333:ir_heat.c     **** 	wdt_enable(WDTO_2S);
 1587               	24,lo8(3)
 1588               		st Z,r24
 1590 07f0 88E1      	.LM132:
 1591 07f2 90E0      		ldi r30,lo8(110)
 1592 07f4 2FE0      		ldi r31,hi8(110)
 1593               		ldi r24,lo8(1)
 1594               		st Z,r24
 1596 07f8 F894      	.LM133:
 1597 07fa A895      		ldi r30,lo8(105)
 1598 07fc 8093 6000 		ldi r31,hi8(105)
 1599 0800 0FBE      		ldi r24,lo8(2)
 1600 0802 2093 6000 		st Z,r24
 1602               	.LM134:
 334:ir_heat.c     **** 	
 335:ir_heat.c     **** 	UART_first_init();
 1603               	
 1604               		ldi r31,hi8(61)
 1605               		ldi r24,lo8(1)
 1606 0806 0E94 0000 		st Z,r24
 336:ir_heat.c     **** 	i2c_init();
 1607               	tabn	68,0,351,.LM135-.LFBB18
 1608               	.LM135:
 1609 080a 0E94 0000 		ldi r26,lo8(43)
 337:ir_heat.c     **** 	
 338:ir_heat.c     **** 	interval=0;
 1610               	i r27,hi8(43)
 1611               		ldi r30,lo8(43)
 1612 080e 1092 0000 		ldi r31,hi8(43)
 339:ir_heat.c     **** 	// Timer 2 config (RTC)
 340:ir_heat.c     ****    TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);	// clk/256
 1613               	 r24,Z
 1614               		ori r24,lo8(16)
 1615 0812 E1EB      		st X,r24
 1617 0816 87E0      	.LM136:
 1618 0818 8083      		ldi r26,lo8(43)
 341:ir_heat.c     ****    TIMSK2 = (1<<TOIE2);
 1619               	27,hi8(43)
 1620               		ldi r30,lo8(43)
 1621 081a E0E7      		ldi r31,hi8(43)
 1622 081c F0E0      		ld r24,Z
 1623 081e 81E0      		andi r24,lo8(-9)
 1624 0820 8083      		st X,r24
 342:ir_heat.c     **** 
 343:ir_heat.c     **** 	TCCR0A = 0;
 1625               	n	68,0,353,.LM137-.LFBB18
 1626               	.LM137:
 1627 0822 E4E4      		ldi r24,lo8(.LC5)
 1628 0824 F0E0      		ldi r25,hi8(.LC5)
 1629 0826 1082      		call puts
 344:ir_heat.c     **** 	TCCR0B = (0<<CS02) | (1<<CS01) | (1<<CS00);
 1630               	bn	68,0,354,.LM138-.LFBB18
 1631               	.LM138:
 1632 0828 E5E4      		ldi r24,lo8(0)
 1633 082a F0E0      		ldi r25,hi8(0)
 1634 082c 83E0      		call set_relais
 345:ir_heat.c     **** 	TIMSK0 = (1<<TOIE0);
 1636               	:
 1637               		sts mode,__zero_reg__
 1639 0832 F0E0      	.LM140:
 1640 0834 81E0      		ldi r24,lo8(-1)
 1641 0836 8083      		std Y+1,r24
 346:ir_heat.c     **** 	
 347:ir_heat.c     **** 	EICRA = (1<<ISC01);
 1642               	n	68,0,362,.LM141-.LFBB18
 1643               	.LM141:
 1644 0838 E9E6      		std Y+6,__zero_reg__
 1645 083a F0E0      		std Y+5,__zero_reg__
 1647 083e 8083      	.LM142:
 348:ir_heat.c     **** 	EIMSK = (1<<INT0);
 1648               	P */
 1649               	 ;  364 "ir_heat.c" 1
 1650 0840 EDE3      		sei
 1651 0842 F0E0      	 ;  0 "" 2
 1652 0844 81E0      	/* #NOAPP */
 1653 0846 8083      	.L82:
 349:ir_heat.c     **** 	
 350:ir_heat.c     **** 
 351:ir_heat.c     **** 	STATUS_LED1_ON;
 1654               	n	68,0,367,.LM143-.LFBB18
 1655               	.LM143:
 1656 0848 ABE2      		lds r24,interval
 1657 084a B0E0      		cpi r24,lo8(8)
 1658 084c EBE2      		brsh .+2
 1659 084e F0E0      		rjmp .L65
 1661 0852 8061      	.LM144:
 1662 0854 8C93      	/* #APP */
 352:ir_heat.c     **** 	STATUS_LED2_OFF;
 1663               	ir_heat.c" 1
 1664               		wdr
 1665 0856 ABE2      	 ;  0 "" 2
 1667 085a EBE2      	.LM145:
 1668 085c F0E0      	/* #NOAPP */
 1669 085e 8081      		sts interval,__zero_reg__
 1671 0862 8C93      	.LM146:
 353:ir_heat.c     **** 	printf("\nStartup\n");
 1672               	Y+5
 1673               		ldd r25,Y+6
 1674 0864 80E0      		lsr r25
 1675 0866 90E0      		ror r24
 1676 0868 0E94 0000 		lsr r25
 354:ir_heat.c     **** 	set_relais(0);
 1677               	r24
 1678               		lsr r25
 1679 086c 80E0      		ror r24
 1680 086e 90E0      		std Y+8,r25
 1681 0870 0E94 0000 		std Y+7,r24
 355:ir_heat.c     **** 	mode = MODE_OFF;
 1682               	bn	68,0,374,.LM147-.LFBB18
 1683               	.LM147:
 1684 0874 1092 0000 		std Y+6,__zero_reg__
 356:ir_heat.c     **** 	
 357:ir_heat.c     **** 	uint16_t temp, temp_sum;
 358:ir_heat.c     **** 	int16_t	lookahead;
 359:ir_heat.c     **** 	int8_t 	slope;
 360:ir_heat.c     **** 	uint8_t  last_interval = 0xff;
 1685               	d Y+5,__zero_reg__
 1687 0878 8FEF      	.LM148:
 1688 087a 8983      		ldd r24,Y+7
 361:ir_heat.c     **** 	
 362:ir_heat.c     **** 	temp_sum = 0;
 1689               	 r25,Y+8
 1690               		sbiw r24,0
 1691 087c 1E82      		brne .L66
 363:ir_heat.c     **** 	
 364:ir_heat.c     **** 	sei();
 1693               	49:
 1694               		rcall .
 1695               		in r30,__SP_L__
 1696               		in r31,__SP_H__
 1697 0880 7894      		adiw r30,1
 1698               		ldi r24,lo8(.LC6)
 1699               		ldi r25,hi8(.LC6)
 1700               		std Z+1,r25
 365:ir_heat.c     **** 
 366:ir_heat.c     ****    while(1) {             // Infinite loop; define here the
 367:ir_heat.c     ****    	if(!(interval < 8)) {
 1701               	4
 1702               		call printf
 1703 0882 8091 0000 		pop __tmp_reg__
 1704 0886 8830      		pop __tmp_reg__
 1705 0888 00F4      		rjmp .L67
 1706 088a 00C0      	.L66:
 368:ir_heat.c     ****    		wdt_reset();
 1707               	n	68,0,381,.LM150-.LFBB18
 1708               	.LM150:
 1709               		rcall .
 1710               		rcall .
 1711 088c A895      		in r30,__SP_L__
 1712               		in r31,__SP_H__
 369:ir_heat.c     ****    		interval=0;
 1713               	r30,1
 1714               		ldi r24,lo8(.LC7)
 1715               		ldi r25,hi8(.LC7)
 1716 088e 1092 0000 		std Z+1,r25
 370:ir_heat.c     ****    		//printf("Messen\n");
 371:ir_heat.c     ****    		// Temperatur einlesen
 372:ir_heat.c     **** //	      temp = get_temperature(ADR_T_OBJ1);
 373:ir_heat.c     **** 			temp = temp_sum >> 3;
 1717               	Z,r24
 1718               		ldd r24,Y+7
 1719 0892 8D81      		ldd r25,Y+8
 1720 0894 9E81      		std Z+3,r25
 1721 0896 9695      		std Z+2,r24
 1722 0898 8795      		call printf
 1723 089a 9695      		pop __tmp_reg__
 1724 089c 8795      		pop __tmp_reg__
 1725 089e 9695      		pop __tmp_reg__
 1726 08a0 8795      		pop __tmp_reg__
 1728 08a4 8F83      	.LM151:
 374:ir_heat.c     **** 			temp_sum = 0;
 1729               	
 1730               		ldd r25,Y+8
 1731 08a6 1E82      		call add_value
 375:ir_heat.c     **** 	      //printf("Temp: %i\n", temp);
 376:ir_heat.c     **** 	      if(temp==0) {
 1733               	152:
 1734               		ldd r24,Y+2
 1735 08aa 8F81      		mov r18,r24
 1736 08ac 9885      		clr r19
 1737 08ae 0097      		sbrc r18,7
 1738 08b0 01F4      		com r19
 377:ir_heat.c     **** 	      // error!
 378:ir_heat.c     **** 	      	printf("Error Temp=0");
 1739               	r24,r18
 1740               		lsl r24
 1741 08b2 00D0      		rol r25
 1742 08b4 EDB7      		movw r16,r24
 1743 08b6 FEB7      		add r16,r18
 1744 08b8 3196      		adc r17,r19
 1745 08ba 80E0      		call get_slope
 1746 08bc 90E0      		clr r25
 1747 08be 9183      		sbrc r24,7
 1748 08c0 8083      		com r25
 1749 08c2 0E94 0000 		add r24,r16
 1750 08c6 0F90      		adc r25,r17
 1751 08c8 0F90      		std Y+17,r25
 1752 08ca 00C0      		std Y+16,r24
 1753               		ldd r24,Y+16
 379:ir_heat.c     **** 	      }
 380:ir_heat.c     **** 	      else {
 381:ir_heat.c     ****    	   	printf("Temp: %i, ", temp);
 1754               	tst r25
 1755               		brge .L68
 1756 08cc 00D0      		ldd r18,Y+16
 1757 08ce 00D0      		ldd r19,Y+17
 1758 08d0 EDB7      		subi r18,lo8(-(3))
 1759 08d2 FEB7      		sbci r19,hi8(-(3))
 1760 08d4 3196      		std Y+17,r19
 1761 08d6 80E0      		std Y+16,r18
 1762 08d8 90E0      	.L68:
 1763 08da 9183      		ldd r24,Y+16
 1764 08dc 8083      		ldd r25,Y+17
 1765 08de 8F81      		asr r25
 1766 08e0 9885      		ror r24
 1767 08e2 9383      		asr r25
 1768 08e4 8283      		ror r24
 1769 08e6 0E94 0000 		std Y+2,r24
 1771 08ec 0F90      	.LM153:
 1772 08ee 0F90      		ldd r24,Y+2
 1773 08f0 0F90      		mov r18,r24
 382:ir_heat.c     ****    	   	// Temperaturverlauf auswerten
 383:ir_heat.c     ****    	   	add_value(temp);
 1774               	
 1775               		com r19
 1776 08f2 8F81      		rcall .
 1777 08f4 9885      		rcall .
 1778 08f6 0E94 0000 		in r30,__SP_L__
 384:ir_heat.c     ****    	   	//print_array();
 385:ir_heat.c     ****    	   	slope = (3*slope + get_slope())/4;
 1779               	r31,__SP_H__
 1780               		adiw r30,1
 1781 08fa 8A81      		ldi r24,lo8(.LC8)
 1782 08fc 282F      		ldi r25,hi8(.LC8)
 1783 08fe 3327      		std Z+1,r25
 1784 0900 27FD      		st Z,r24
 1785 0902 3095      		std Z+3,r19
 1786 0904 C901      		std Z+2,r18
 1787 0906 880F      		call printf
 1788 0908 991F      		pop __tmp_reg__
 1789 090a 8C01      		pop __tmp_reg__
 1790 090c 020F      		pop __tmp_reg__
 1791 090e 131F      		pop __tmp_reg__
 1793 0914 9927      	.LM154:
 1794 0916 87FD      		ldd r24,Y+2
 1795 0918 9095      		ldi r22,lo8(5)
 1796 091a 800F      		call lookahead_temp
 1797 091c 911F      		std Y+4,r25
 1798 091e 998B      		std Y+3,r24
 1800 0922 8889      	.LM155:
 1801 0924 9989      		rcall .
 1802 0926 9923      		rcall .
 1803 0928 04F4      		in r30,__SP_L__
 1804 092a 2889      		in r31,__SP_H__
 1805 092c 3989      		adiw r30,1
 1806 092e 2D5F      		ldi r24,lo8(.LC9)
 1807 0930 3F4F      		ldi r25,hi8(.LC9)
 1808 0932 398B      		std Z+1,r25
 1809 0934 288B      		st Z,r24
 1810               		ldd r24,Y+3
 1811 0936 8889      		ldd r25,Y+4
 1812 0938 9989      		std Z+3,r25
 1813 093a 9595      		std Z+2,r24
 1814 093c 8795      		call printf
 1815 093e 9595      		pop __tmp_reg__
 1816 0940 8795      		pop __tmp_reg__
 1817 0942 8A83      		pop __tmp_reg__
 386:ir_heat.c     ****    	   	printf("slope: %i, ", slope);
 1818               	6-.LFBB18
 1819               	.LM156:
 1820 0944 8A81      		ldd r18,Y+3
 1821 0946 282F      		ldd r19,Y+4
 1822 0948 3327      		lds r24,t_la_threshold_up
 1823 094a 27FD      		lds r25,(t_la_threshold_up)+1
 1824 094c 3095      		std Y+14,__zero_reg__
 1825 094e 00D0      		cp r24,r18
 1826 0950 00D0      		cpc r25,r19
 1827 0952 EDB7      		brsh .L69
 1828 0954 FEB7      		ldi r19,lo8(1)
 1829 0956 3196      		std Y+14,r19
 1830 0958 80E0      	.L69:
 1831 095a 90E0      		lds r18,t_abs_threshold_up
 1832 095c 9183      		lds r19,(t_abs_threshold_up)+1
 1833 095e 8083      		std Y+13,__zero_reg__
 1834 0960 3383      		ldd r24,Y+7
 1835 0962 2283      		ldd r25,Y+8
 1836 0964 0E94 0000 		cp r18,r24
 1837 0968 0F90      		cpc r19,r25
 1838 096a 0F90      		brsh .L70
 1839 096c 0F90      		ldi r24,lo8(1)
 1840 096e 0F90      		std Y+13,r24
 387:ir_heat.c     **** 				lookahead=lookahead_temp(slope, 5);   	   	
 1841               	d r25,Y+13
 1842               		or r24,r25
 1843 0970 8A81      		tst r24
 1844 0972 65E0      		breq .L67
 1845 0974 0E94 0000 		ldi r24,lo8(21)
 1846 0978 9C83      		sts off_counter,r24
 1847 097a 8B83      	.L67:
 388:ir_heat.c     ****    	   	printf("Prognose: %i\n", lookahead);
 1848               		68,0,393,.LM157-.LFBB18
 1849               	.LM157:
 1850 097c 00D0      		lds r24,off_counter
 1851 097e 00D0      		tst r24
 1852 0980 EDB7      		breq .L71
 1854 0984 3196      	.LM158:
 1855 0986 80E0      		lds r24,off_counter
 1856 0988 90E0      		subi r24,lo8(-(-1))
 1857 098a 9183      		sts off_counter,r24
 1859 098e 8B81      	.LM159:
 1860 0990 9C81      		lds r24,mode
 1861 0992 9383      		cpi r24,lo8(1)
 1862 0994 8283      		brne .L72
 1863 0996 0E94 0000 		ldi r24,lo8(3)
 1864 099a 0F90      		sts mode,r24
 1865 099c 0F90      	.L72:
 1867 09a0 0F90      	.LM160:
 389:ir_heat.c     **** 				
 390:ir_heat.c     ****    	   	// Relais sperren, wenn ein Wert ber dem Grenzwert
 391:ir_heat.c     **** 	   	   if((lookahead > t_la_threshold_up) | (temp > t_abs_threshold_up)) off_counter = OFF_COUNTER
 1868               	
 1869               		mov r18,r24
 1870 09a2 2B81      		ldi r19,lo8(0)
 1871 09a4 3C81      		rcall .
 1872 09a6 8091 0000 		rcall .
 1873 09aa 9091 0000 		in r30,__SP_L__
 1874 09ae 1E86      		in r31,__SP_H__
 1875 09b0 8217      		adiw r30,1
 1876 09b2 9307      		ldi r24,lo8(.LC10)
 1877 09b4 00F4      		ldi r25,hi8(.LC10)
 1878 09b6 31E0      		std Z+1,r25
 1879 09b8 3E87      		st Z,r24
 1880               		std Z+3,r19
 1881 09ba 2091 0000 		std Z+2,r18
 1882 09be 3091 0000 		call printf
 1883 09c2 1D86      		pop __tmp_reg__
 1884 09c4 8F81      		pop __tmp_reg__
 1885 09c6 9885      		pop __tmp_reg__
 1886 09c8 2817      		pop __tmp_reg__
 1887 09ca 3907      		rjmp .L76
 1888 09cc 00F4      	.L71:
 1890 09d0 8D87      	.LM161:
 1891               		ldd r18,Y+3
 1892 09d2 8E85      		ldd r19,Y+4
 1893 09d4 9D85      		lds r24,t_la_threshold_down
 1894 09d6 892B      		lds r25,(t_la_threshold_down)+1
 1895 09d8 8823      		std Y+12,__zero_reg__
 1896 09da 01F0      		cp r18,r24
 1897 09dc 85E1      		cpc r19,r25
 1898 09de 8093 0000 		brsh .L74
 1899               		ldi r18,lo8(1)
 392:ir_heat.c     ****    	   }
 393:ir_heat.c     ****    		if(off_counter) {
 1900               	02,.LM161-.LFBB18
 1901               	.LM161:
 1902 09e2 8091 0000 		ldd r18,Y+3
 1903 09e6 8823      		ldd r19,Y+4
 1904 09e8 01F0      		lds r24,t_la_threshold_down
 394:ir_heat.c     ****   				off_counter--;
 1905               	8
 1906               		call printf
 1907 09ea 8091 0000 		pop __tmp_reg__
 1908 09ee 8150      		pop __tmp_reg__
 1909 09f0 8093 0000 		pop __tmp_reg__
 395:ir_heat.c     ****   				if(mode == MODE_ON) mode = MODE_TEMP_PROT;
 1910               	l .
 1911               		in r30,__SP_L__
 1912 09f4 8091 0000 		in r31,__SP_H__
 1913 09f8 8130      		adiw r30,1
 1914 09fa 01F4      		ldi r24,lo8(.LC10)
 1915 09fc 83E0      		ldi r25,hi8(.LC10)
 1916 09fe 8093 0000 		std Z+1,r25
 1917               		st Z,r24
 396:ir_heat.c     ****   				//RELAIS_OFF;
 397:ir_heat.c     **** 				//STATUS_LED1_OFF;
 398:ir_heat.c     **** 				//STATUS_LED2_ON;
 399:ir_heat.c     **** 				printf("Counter: %i; ", off_counter);
 1918               	68,0,399,.LM160-.LFBB18
 1919               	.LM160:
 1920 0a02 8091 0000 		lds r24,off_counter
 1921 0a06 282F      		mov r18,r24
 1922 0a08 30E0      		ldi r19,lo8(0)
 1923 0a0a 00D0      		rcall .
 1924 0a0c 00D0      		rcall .
 1925 0a0e EDB7      		in r30,__SP_L__
 1926 0a10 FEB7      		in r31,__SP_H__
 1927 0a12 3196      		adiw r30,1
 1928 0a14 80E0      		ldi r24,lo8(.LC10)
 1929 0a16 90E0      		ldi r25,hi8(.LC10)
 1930 0a18 9183      		std Z+1,r25
 1931 0a1a 8083      		st Z,r24
 1932 0a1c 3383      		std Z+3,r19
 1933 0a1e 2283      		std Z+2,r18
 1934 0a20 0E94 0000 		call printf
 1935 0a24 0F90      		pop __tmp_reg__
 1936 0a26 0F90      		pop __tmp_reg__
 1937 0a28 0F90      		pop __tmp_reg__
 1938 0a2a 0F90      		pop __tmp_reg__
 1939 0a2c 00C0      		rjmp .L76
 1940               	.L71:
 400:ir_heat.c     ****    		}
 401:ir_heat.c     ****    		else {
 402:ir_heat.c     **** 	   	   if((lookahead < t_la_threshold_down) & (temp < t_abs_threshold_down)) {
 1941               	
 1942               		adiw r30,1
 1943 0a2e 2B81      		ldi r24,lo8(.LC10)
 1944 0a30 3C81      		ldi r25,hi8(.LC10)
 1945 0a32 8091 0000 		std Z+1,r25
 1946 0a36 9091 0000 		st Z,r24
 1947 0a3a 1C86      		std Z+3,r19
 1948 0a3c 2817      		std Z+2,r18
 1949 0a3e 3907      		call printf
 1950 0a40 00F4      		pop __tmp_reg__
 1951 0a42 21E0      		pop __tmp_reg__
 1952 0a44 2C87      		pop __tmp_reg__
 1953               		pop __tmp_reg__
 1954 0a46 2091 0000 		rjmp .L76
 1955 0a4a 3091 0000 	.L71:
 1957 0a50 8F81      	.LM161:
 1958 0a52 9885      		ldd r18,Y+3
 1959 0a54 8217      		ldd r19,Y+4
 1960 0a56 9307      		lds r24,t_la_threshold_down
 1961 0a58 00F4      		lds r25,(t_la_threshold_down)+1
 1962 0a5a 31E0      		std Y+12,__zero_reg__
 1963 0a5c 3B87      		cp r18,r24
 1964               		cpc r19,r25
 1965 0a5e 8C85      		brsh .L74
 1966 0a60 9B85      		ldi r18,lo8(1)
 1967 0a62 8923      		std Y+12,r18
 1968 0a64 8823      	.L74:
 1969 0a66 01F0      		lds r18,t_abs_threshold_down
 403:ir_heat.c     **** 	   	   	// Relais wieder einschalten, wenn alle Temperaturen unter der unteren Schwelle
 404:ir_heat.c     **** 	   	   	if(mode == MODE_TEMP_PROT) mode = MODE_ON;
 1970               	lds r24,t_la_threshold_down
 1971               		lds r25,(t_la_threshold_down)+1
 1972 0a68 8091 0000 		std Y+12,__zero_reg__
 1973 0a6c 8330      		cp r18,r24
 1974 0a6e 01F4      		cpc r19,r25
 1975 0a70 81E0      		brsh .L74
 1976 0a72 8093 0000 		ldi r18,lo8(1)
 1977 0a76 00C0      		std Y+12,r18
 1978               	.L74:
 405:ir_heat.c     **** 					//printf("ON\n");
 406:ir_heat.c     **** 	   		}
 407:ir_heat.c     ****    		}
 408:ir_heat.c     **** 		}
 409:ir_heat.c     **** 		else if(interval != last_interval) {
 1979               	61:
 1980               		ldd r18,Y+3
 1981 0a78 9091 0000 		ldd r19,Y+4
 1982 0a7c 8981      		lds r24,t_la_threshold_down
 1983 0a7e 9817      		lds r25,(t_la_threshold_down)+1
 1984 0a80 01F0      		std Y+12,__zero_reg__
 410:ir_heat.c     ****    		last_interval = interval;
 1985               	p_reg__
 1986               		pop __tmp_reg__
 1987 0a82 8091 0000 		rjmp .L76
 1988 0a86 8983      	.L71:
 411:ir_heat.c     ****    		temp_sum += get_temperature(ADR_T_OBJ1);
 1989               	
 1990               		adiw r30,1
 1991 0a88 87E0      		ldi r24,lo8(.LC10)
 1992 0a8a 0E94 0000 		ldi r25,hi8(.LC10)
 1993 0a8e 9C01      		std Z+1,r25
 1994 0a90 8D81      		st Z,r24
 1995 0a92 9E81      		std Z+3,r19
 1996 0a94 820F      		std Z+2,r18
 1997 0a96 931F      		call printf
 1998 0a98 9E83      		pop __tmp_reg__
 1999 0a9a 8D83      		pop __tmp_reg__
 2000               		pop __tmp_reg__
 412:ir_heat.c     ****    		//printf("Sum:%i\n", temp_sum);
 413:ir_heat.c     ****    	}
 414:ir_heat.c     **** 
 415:ir_heat.c     **** 		
 416:ir_heat.c     **** 		switch(mode) {
 2001               	l .
 2002               		in r30,__SP_L__
 2003 0a9c 8091 0000 		in r31,__SP_H__
 2004 0aa0 282F      		adiw r30,1
 2005 0aa2 30E0      		ldi r24,lo8(.LC10)
 2006 0aa4 3A87      		ldi r25,hi8(.LC10)
 2007 0aa6 2987      		std Z+1,r25
 2008 0aa8 8985      		st Z,r24
 2009 0aaa 9A85      		std Z+3,r19
 2010 0aac 8130      		std Z+2,r18
 2011 0aae 9105      		call printf
 2012 0ab0 01F0      		pop __tmp_reg__
 2013 0ab2 2985      		pop __tmp_reg__
 2014 0ab4 3A85      		pop __tmp_reg__
 2015 0ab6 2330      		pop __tmp_reg__
 2016 0ab8 3105      		rjmp .L76
 2017 0aba 01F0      	.L71:
 2019 0abe 9A85      	.LM161:
 2020 0ac0 0097      		ldd r18,Y+3
 2021 0ac2 01F4      		ldd r19,Y+4
 2022               		lds r24,t_la_threshold_down
 417:ir_heat.c     **** 		case MODE_OFF:
 418:ir_heat.c     **** 			set_relais(0);
 2023               	8
 2024               		call printf
 2025 0ac4 80E0      		pop __tmp_reg__
 2026 0ac6 90E0      		pop __tmp_reg__
 2027 0ac8 0E94 0000 		pop __tmp_reg__
 419:ir_heat.c     **** 			STATUS_LED1_OFF;
 2028               	l .
 2029               		in r30,__SP_L__
 2030 0acc ABE2      		in r31,__SP_H__
 2031 0ace B0E0      		adiw r30,1
 2032 0ad0 EBE2      		ldi r24,lo8(.LC10)
 2033 0ad2 F0E0      		ldi r25,hi8(.LC10)
 2034 0ad4 8081      		std Z+1,r25
 2035 0ad6 8F7E      		st Z,r24
 2036 0ad8 8C93      		std Z+3,r19
 420:ir_heat.c     **** 			STATUS_LED2_ON;
 2037               	0-.LFBB18
 2038               	.LM160:
 2039 0ada ABE2      		lds r24,off_counter
 2040 0adc B0E0      		mov r18,r24
 2041 0ade EBE2      		ldi r19,lo8(0)
 2042 0ae0 F0E0      		rcall .
 2043 0ae2 8081      		rcall .
 2044 0ae4 8860      		in r30,__SP_L__
 2045 0ae6 8C93      		in r31,__SP_H__
 2046 0ae8 00C0      		adiw r30,1
 2047               		ldi r24,lo8(.LC10)
 421:ir_heat.c     **** 			break;
 422:ir_heat.c     **** 		case MODE_ON:
 423:ir_heat.c     **** 			set_relais(1);
 2048               	2
 2049               		ldi r24,lo8(3)
 2050 0aea 81E0      		sts mode,r24
 2051 0aec 90E0      	.L72:
 424:ir_heat.c     **** 			STATUS_LED1_ON;
 2053               	8
 2054               	.LM158:
 2055 0af2 ABE2      		lds r24,off_counter
 2056 0af4 B0E0      		subi r24,lo8(-(-1))
 2057 0af6 EBE2      		sts off_counter,r24
 2059 0afa 8081      	.LM159:
 2060 0afc 8061      		lds r24,mode
 2061 0afe 8C93      		cpi r24,lo8(1)
 425:ir_heat.c     **** 			STATUS_LED2_OFF;
 2062               	2
 2063               		ldi r24,lo8(3)
 2064 0b00 ABE2      		sts mode,r24
 2065 0b02 B0E0      	.L72:
 2067 0b06 F0E0      	.LM160:
 2068 0b08 8081      		lds r24,off_counter
 2069 0b0a 877F      		mov r18,r24
 2070 0b0c 8C93      		ldi r19,lo8(0)
 2071 0b0e 00C0      		rcall .
 2072               		rcall .
 426:ir_heat.c     **** 
 427:ir_heat.c     **** 			break;
 428:ir_heat.c     **** 		case MODE_TEMP_PROT:
 429:ir_heat.c     **** 			set_relais(0);
 2073               	8,0,395,.LM159-.LFBB18
 2074               	.LM159:
 2075 0b10 80E0      		lds r24,mode
 2076 0b12 90E0      		cpi r24,lo8(1)
 2077 0b14 0E94 0000 		brne .L72
 430:ir_heat.c     **** 			STATUS_LED1_OFF;
 2078               	r24,lo8(3)
 2079               		sts mode,r24
 2080 0b18 ABE2      	.L72:
 2082 0b1c EBE2      	.LM160:
 2083 0b1e F0E0      		lds r24,off_counter
 2084 0b20 8081      		mov r18,r24
 2085 0b22 8F7E      		ldi r19,lo8(0)
 2086 0b24 8C93      		rcall .
 431:ir_heat.c     **** 			STATUS_LED2_ON;
 2087               	
 2089 0b26 ABE2      	.LM159:
 2090 0b28 B0E0      		lds r24,mode
 2091 0b2a EBE2      		cpi r24,lo8(1)
 2092 0b2c F0E0      		brne .L72
 2093 0b2e 8081      		ldi r24,lo8(3)
 2094 0b30 8860      		sts mode,r24
 2095 0b32 8C93      	.L72:
 2097               	.LM160:
 432:ir_heat.c     **** 
 433:ir_heat.c     **** 			break;
 434:ir_heat.c     **** 		default:
 435:ir_heat.c     **** 			mode = MODE_OFF;
 2098               	ff_counter
 2099               		mov r18,r24
 2100 0b36 1092 0000 		ldi r19,lo8(0)
 2101 0b3a 00C0      		rcall .
 2102               		rcall .
 2103               		in r30,__SP_L__
 2104               		in r31,__SP_H__
 2105               		adiw r30,1
 2106               		ldi r24,lo8(.LC10)
 2107               		ldi r25,hi8(.LC10)
 2108               		std Z+1,r25
 2109               		st Z,r24
 2110               		std Z+3,r19
 2111               		std Z+2,r18
 2112               		call printf
 2113               		pop __tmp_reg__
 2114               		pop __tmp_reg__
 2115               		pop __tmp_reg__
 2116               		pop __tmp_reg__
 2117               		rjmp .L76
 2118               	.L71:
 2120               	.LM161:
 2121               		ldd r18,Y+3
 2122               		ldd r19,Y+4
 2123               		lds r24,t_la_threshold_down
 2124               		lds r25,(t_la_threshold_down)+1
 2125               		std Y+12,__zero_reg__
 2126               		cp r18,r24
 2127               		cpc r19,r25
 2128               		brsh .L74
 2129               		ldi r18,lo8(1)
 2130               		std Y+12,r18
 2131               	.L74:
 2132               		lds r18,t_abs_threshold_down
 2133               		lds r19,(t_abs_threshold_down)+1
 2134               		std Y+11,__zero_reg__
 2135               		ldd r24,Y+7
 2136               		ldd r25,Y+8
 2137               		cp r24,r18
 2138               		cpc r25,r19
 2139               		brsh .L75
 2140               		ldi r19,lo8(1)
DEFINED SYMBOLS
                            *ABS*:00000000 ir_heat.c
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:2      *ABS*:0000003f __SREG__
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:3      *ABS*:0000003e __SP_H__
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:4      *ABS*:0000003d __SP_L__
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:5      *ABS*:00000034 __CCP__
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:91     .bss:00000000 off_counter
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:97     .data:00000000 t_la_threshold_up
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:102    .data:00000002 t_abs_threshold_up
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:107    .data:00000004 t_la_threshold_down
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:112    .data:00000006 t_abs_threshold_down
                             .bss:00000001 c.1650
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:119    .text:00000000 __vector_9
                            *COM*:00000001 interval
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:114    .bss:00000002 c.1658
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:160    .text:0000002e __vector_16
                            *COM*:00000001 mode
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:294    .text:000000f6 __vector_1
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:472    .text:000001fc __vector_18
                            *COM*:00000001 r_in
                            *COM*:00000020 rbuf
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:538    .text:00000258 __vector_19
                            *COM*:00000001 t_in
                            *COM*:00000001 t_out
                            *COM*:00000020 tbuf
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:617    .text:000002d0 tbuflen
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:647    .text:000002ec UART_putchar
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:719    .text:00000352 rbuflen
                            *COM*:00000001 r_out
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:748    .text:0000036e UART_getchar
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:807    .text:000003b8 UART_first_init
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:869    .text:000003f2 print_array
                            *COM*:0000000c t_array
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:956    .text:0000046a add_value
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:1066   .text:00000538 get_slope
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:1181   .text:000005fe lookahead_temp
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:1260   .text:00000670 get_temperature
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:156    .bss:00000003 last.1904
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:1392   .text:00000718 set_relais
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:1480   .text:00000790 my_function
C:\Users\Thorsten\AppData\Local\Temp/ccOopbdK.s:1522   .text:000007a0 main

UNDEFINED SYMBOLS
printf
fdevopen
putchar
__divmodhi4
i2c_start
i2c_write
i2c_rep_start
i2c_read_ack
i2c_stop
__udivmodhi4
puts
i2c_init
__do_copy_data
__do_clear_bss
