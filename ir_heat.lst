   1               		.file	"ir_heat.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  86               	.global	interval
  87               		.data
  90               	interval:
  91 0000 F4        		.byte	-12
  92               	.global	off_counter
  93               	.global	off_counter
  94               		.section .bss
  97               	off_counter:
  98 0000 00        		.skip 1,0
  99               	.global	t_la_threshold_up
 100               		.data
 103               	t_la_threshold_up:
 104 0001 2C01      		.word	300
 105               	.global	t_abs_threshold_up
 108               	t_abs_threshold_up:
 109 0003 0E01      		.word	270
 110               	.global	t_la_threshold_down
 113               	t_la_threshold_down:
 114 0005 FA00      		.word	250
 115               	.global	t_abs_threshold_down
 118               	t_abs_threshold_down:
 119 0007 FA00      		.word	250
 120               		.text
 122               	.global	__vector_9
 124               	__vector_9:
   1:ir_heat.c     **** // ***********************************************************
   2:ir_heat.c     **** // Project:
   3:ir_heat.c     **** // Author:
   4:ir_heat.c     **** // Module description:
   5:ir_heat.c     **** // ***********************************************************
   6:ir_heat.c     **** 
   7:ir_heat.c     **** #ifndef F_CPU
   8:ir_heat.c     **** #define F_CPU 1000000UL
   9:ir_heat.c     **** #endif
  10:ir_heat.c     **** 
  11:ir_heat.c     **** #include <avr\io.h>              // Most basic include files
  12:ir_heat.c     **** #include <avr\interrupt.h>       // Add the necessary ones
  13:ir_heat.c     **** #include <avr\signal.h>          // here
  14:ir_heat.c     **** #include <avr\wdt.h>
  15:ir_heat.c     **** 
  16:ir_heat.c     **** #include <stdio.h>
  17:ir_heat.c     **** #include <string.h>
  18:ir_heat.c     **** #include <stdlib.h>
  19:ir_heat.c     **** 
  20:ir_heat.c     **** #include "i2c_mstr.h"
  21:ir_heat.c     **** #include "ir_heat.h"
  22:ir_heat.c     **** 
  23:ir_heat.c     **** #define 	MLX90614_WRITE	(0x5A<<1)
  24:ir_heat.c     **** #define 	MLX90614_READ	(MLX90614_WRITE+1)
  25:ir_heat.c     **** #define	ADR_T_A			0x06
  26:ir_heat.c     **** #define	ADR_T_OBJ1		0x07
  27:ir_heat.c     **** #define	ADR_T_OBJ2		0x08
  28:ir_heat.c     **** 
  29:ir_heat.c     **** 
  30:ir_heat.c     **** #define __STDIO_FDEVOPEN_COMPAT_12						
  31:ir_heat.c     **** // Buffer sizes must be 2^n
  32:ir_heat.c     **** //
  33:ir_heat.c     **** #define TBUFSIZE	32
  34:ir_heat.c     **** #define RBUFSIZE	32
  35:ir_heat.c     **** 
  36:ir_heat.c     **** #define TMASK		(TBUFSIZE-1)
  37:ir_heat.c     **** #define RMASK		(RBUFSIZE-1)
  38:ir_heat.c     **** 
  39:ir_heat.c     **** #define FLASH_LED		PC3
  40:ir_heat.c     **** #define STATUS_LED1	PD4
  41:ir_heat.c     **** #define STATUS_LED2	PD3
  42:ir_heat.c     **** #define RELAIS			PB6
  43:ir_heat.c     **** #define BUZZER			PB7
  44:ir_heat.c     **** #define SWITCH			PD2
  45:ir_heat.c     **** 
  46:ir_heat.c     **** #define RELAIS_ON			PORTB |= (1<<RELAIS)
  47:ir_heat.c     **** #define RELAIS_OFF		PORTB &=~(1<<RELAIS)
  48:ir_heat.c     **** 
  49:ir_heat.c     **** #define BUZZER_ON			PORTB |= (1<<BUZZER)
  50:ir_heat.c     **** #define BUZZER_OFF		PORTB &=~(1<<BUZZER)
  51:ir_heat.c     **** 
  52:ir_heat.c     **** #define STATUS_LED1_ON	PORTD |= (1<<STATUS_LED1)
  53:ir_heat.c     **** #define STATUS_LED1_OFF	PORTD &=~(1<<STATUS_LED1)
  54:ir_heat.c     **** 
  55:ir_heat.c     **** #define FLASH_LED_ON		PORTC |= (1<<FLASH_LED)
  56:ir_heat.c     **** #define FLASH_LED_OFF	PORTC &=~(1<<FLASH_LED)
  57:ir_heat.c     **** 
  58:ir_heat.c     **** #define STATUS_LED2_ON	PORTD |= (1<<STATUS_LED2)
  59:ir_heat.c     **** #define STATUS_LED2_OFF	PORTD &=~(1<<STATUS_LED2)
  60:ir_heat.c     **** 
  61:ir_heat.c     **** #define OFF_COUNTER		5
  62:ir_heat.c     **** 
  63:ir_heat.c     **** #define	MODE_OFF			0
  64:ir_heat.c     **** #define	MODE_ON			1
  65:ir_heat.c     **** #define	MODE_TEMP_PROT	3
  66:ir_heat.c     **** 
  67:ir_heat.c     **** // Define here the global static variables
  68:ir_heat.c     **** //
  69:ir_heat.c     **** volatile unsigned char tbuf[TBUFSIZE];  // TX buffer
  70:ir_heat.c     **** volatile unsigned char rbuf[RBUFSIZE];  // RX buffer
  71:ir_heat.c     **** 
  72:ir_heat.c     **** volatile unsigned char t_in;            // TX buffer in index
  73:ir_heat.c     **** volatile unsigned char t_out;           // TX buffer out index
  74:ir_heat.c     **** 
  75:ir_heat.c     **** volatile unsigned char r_in;            // RX buffer in index
  76:ir_heat.c     **** volatile unsigned char r_out;           // RX buffer out index
  77:ir_heat.c     **** 
  78:ir_heat.c     **** int8_t	interval = -12;
  79:ir_heat.c     **** int16_t 	t_array[6];
  80:ir_heat.c     **** uint8_t	off_counter = 0;
  81:ir_heat.c     **** uint8_t	mode;
  82:ir_heat.c     **** int16_t	slope2;
  83:ir_heat.c     **** 
  84:ir_heat.c     **** uint16_t	t_la_threshold_up 	=  300;
  85:ir_heat.c     **** uint16_t	t_abs_threshold_up 	=  270;
  86:ir_heat.c     **** uint16_t	t_la_threshold_down 	=  250;
  87:ir_heat.c     **** uint16_t	t_abs_threshold_down	=  250;
  88:ir_heat.c     **** 
  89:ir_heat.c     **** 
  90:ir_heat.c     **** 
  91:ir_heat.c     **** // Clock Timer
  92:ir_heat.c     **** SIGNAL(SIG_OVERFLOW2) {
 125               	M0:
 126               	.LFBB1:
 127               		push __zero_reg__
 128 0000 1F92      		push r0
 129 0002 0F92      		in r0,__SREG__
 130 0004 0FB6      		push r0
 131 0006 0F92      		clr __zero_reg__
 132 0008 1124      		push r24
 133 000a 8F93      		push r29
 134 000c DF93      		push r28
 135 000e CF93      		in r28,__SP_L__
 136 0010 CDB7      		in r29,__SP_H__
 137 0012 DEB7      	/* prologue: Signal */
 138               	/* frame size = 0 */
  93:ir_heat.c     **** 	interval++;
 140               	interval
 141               		subi r24,lo8(-(1))
 142 0014 8091 0000 		sts interval,r24
 143 0018 8F5F      	/* epilogue start */
 145               	.LM2:
  94:ir_heat.c     **** }
 146               	28
 147               		pop r29
 148 001e CF91      		pop r24
 149 0020 DF91      		pop r0
 150 0022 8F91      		out __SREG__,r0
 151 0024 0F90      		pop r0
 152 0026 0FBE      		pop __zero_reg__
 153 0028 0F90      		reti
 155 002c 1895      	.Lscope1:
 156               		.lcomm c.1686,1
 158               	.global	__vector_16
 160               	__vector_16:
 162               	.LM3:
  95:ir_heat.c     **** 
  96:ir_heat.c     **** SIGNAL(SIG_OVERFLOW0) {
 163               	ero_reg__
 164               		push r0
 165               		in r0,__SREG__
 166 002e 1F92      		push r0
 167 0030 0F92      		clr __zero_reg__
 168 0032 0FB6      		push r18
 169 0034 0F92      		push r19
 170 0036 1124      		push r20
 171 0038 2F93      		push r21
 172 003a 3F93      		push r24
 173 003c 4F93      		push r25
 174 003e 5F93      		push r26
 175 0040 8F93      		push r27
 176 0042 9F93      		push r30
 177 0044 AF93      		push r31
 178 0046 BF93      		push r29
 179 0048 EF93      		push r28
 180 004a FF93      		push __tmp_reg__
 181 004c DF93      		in r28,__SP_L__
 182 004e CF93      		in r29,__SP_H__
 183 0050 0F92      	/* prologue: Signal */
 184 0052 CDB7      	/* frame size = 1 */
 186               	.LM4:
 187               		std Y+1,__zero_reg__
  97:ir_heat.c     **** 	static uint8_t	c = 0;
  98:ir_heat.c     **** 	uint8_t slow=0;
 188               	BB2
 189               	.LM5:
 190 0056 1982      		lds r24,c.1686
  99:ir_heat.c     **** 	//if (off_counter < OFF_COUNTER-2) slow=1;
 100:ir_heat.c     **** 	c++;
 191               	bi r24,lo8(-(1))
 192               		sts c.1686,r24
 194 005c 8F5F      	.LM6:
 195 005e 8093 0000 		lds r24,mode
 101:ir_heat.c     **** 	if (mode==MODE_TEMP_PROT) {
 196               	r24,lo8(3)
 197               		brne .L4
 199 0066 8330      	.LM7:
 200 0068 01F4      		lds r24,c.1686
 102:ir_heat.c     **** 		if(c > (6<<slow)) {
 201               	r20,r24
 202               		ldi r21,lo8(0)
 203 006a 8091 0000 		ldd r24,Y+1
 204 006e 482F      		mov r18,r24
 205 0070 50E0      		ldi r19,lo8(0)
 206 0072 8981      		ldi r24,lo8(6)
 207 0074 282F      		ldi r25,hi8(6)
 208 0076 30E0      		mov r0,r18
 209 0078 86E0      		rjmp 2f
 210 007a 90E0      	1:	lsl r24
 211 007c 022E      		rol r25
 212 007e 00C0      	2:	dec r0
 213 0080 880F      		brpl 1b
 214 0082 991F      		cp r24,r20
 215 0084 0A94      		cpc r25,r21
 216 0086 02F4      		brge .L4
 218 008a 9507      	.LM8:
 219 008c 04F4      		ldi r26,lo8(40)
 103:ir_heat.c     **** 			FLASH_LED_ON;
 220               	di r30,lo8(40)
 221               		ldi r31,hi8(40)
 222 008e A8E2      		ld r24,Z
 223 0090 B0E0      		ori r24,lo8(8)
 224 0092 E8E2      		st X,r24
 225 0094 F0E0      	.L4:
 227 0098 8860      	.LM9:
 228 009a 8C93      		lds r24,c.1686
 229               		mov r20,r24
 104:ir_heat.c     **** 		}
 105:ir_heat.c     **** 	}
 106:ir_heat.c     **** 	if(c > (10<<slow)) {
 230               	o8(0)
 231               		ldd r24,Y+1
 232 009c 8091 0000 		mov r18,r24
 233 00a0 482F      		ldi r19,lo8(0)
 234 00a2 50E0      		ldi r24,lo8(10)
 235 00a4 8981      		ldi r25,hi8(10)
 236 00a6 282F      		mov r0,r18
 237 00a8 30E0      		rjmp 2f
 238 00aa 8AE0      	1:	lsl r24
 239 00ac 90E0      		rol r25
 240 00ae 022E      	2:	dec r0
 241 00b0 00C0      		brpl 1b
 242 00b2 880F      		cp r24,r20
 243 00b4 991F      		cpc r25,r21
 244 00b6 0A94      		brge .L6
 246 00ba 8417      	.LM10:
 247 00bc 9507      		sts c.1686,__zero_reg__
 107:ir_heat.c     **** 		c=0;
 249               	(40)
 250               		ldi r27,hi8(40)
 251 00c0 1092 0000 		ldi r30,lo8(40)
 108:ir_heat.c     **** 		FLASH_LED_OFF;
 252               	i r31,hi8(40)
 253               		ld r24,Z
 254 00c4 A8E2      		andi r24,lo8(-9)
 255 00c6 B0E0      		st X,r24
 256 00c8 E8E2      	.L6:
 257 00ca F0E0      	/* epilogue start */
 259 00ce 877F      	.LM12:
 260 00d0 8C93      		pop __tmp_reg__
 261               		pop r28
 262               		pop r29
 109:ir_heat.c     **** 	}
 110:ir_heat.c     **** }
 263               	op r30
 264               		pop r27
 265 00d2 0F90      		pop r26
 266 00d4 CF91      		pop r25
 267 00d6 DF91      		pop r24
 268 00d8 FF91      		pop r21
 269 00da EF91      		pop r20
 270 00dc BF91      		pop r19
 271 00de AF91      		pop r18
 272 00e0 9F91      		pop r0
 273 00e2 8F91      		out __SREG__,r0
 274 00e4 5F91      		pop r0
 275 00e6 4F91      		pop __zero_reg__
 276 00e8 3F91      		reti
 282 00f4 1895      	.Lscope2:
 283               		.lcomm running.1718,1
 285               	.global	__vector_1
 287               	__vector_1:
 289               	.LM13:
 290               	.LFBB3:
 291               		push __zero_reg__
 292               		push r0
 293               		in r0,__SREG__
 111:ir_heat.c     **** 
 112:ir_heat.c     **** 
 113:ir_heat.c     **** SIGNAL(SIG_INTERRUPT0) {
 294               	h r18
 295               		push r24
 296               		push r25
 297 00f6 1F92      		push r30
 298 00f8 0F92      		push r31
 299 00fa 0FB6      		push r29
 300 00fc 0F92      		push r28
 301 00fe 1124      		rcall .
 302 0100 2F93      		push __tmp_reg__
 303 0102 8F93      		in r28,__SP_L__
 304 0104 9F93      		in r29,__SP_H__
 305 0106 EF93      	/* prologue: Signal */
 306 0108 FF93      	/* frame size = 3 */
 308 010c CF93      	.LM14:
 309 010e 00D0      		lds r24,running.1718
 310 0110 0F92      		tst r24
 311 0112 CDB7      		breq .+2
 312 0114 DEB7      		rjmp .L17
 314               	.LM15:
 114:ir_heat.c     **** 	static uint8_t running = 0;
 115:ir_heat.c     **** 	
 116:ir_heat.c     **** 	if(running){
 315               	running.1718,r24
 317 0116 8091 0000 	.LM16:
 318 011a 8823      		std Y+1,__zero_reg__
 320 011e 00C0      	.LM17:
 117:ir_heat.c     **** //		printf("X");
 118:ir_heat.c     **** 		return;
 119:ir_heat.c     **** 	}
 120:ir_heat.c     **** 	running = 1;
 321               	30,lo8(61)
 322               		ldi r31,hi8(61)
 323 0120 81E0      		st Z,__zero_reg__
 121:ir_heat.c     **** 	
 122:ir_heat.c     **** 	uint16_t i;
 123:ir_heat.c     **** 	uint8_t c=0;
 325               	8:
 326               	/* #APP */
 327 0126 1982      	 ;  125 "ir_heat.c" 1
 124:ir_heat.c     **** 	EIMSK = 0;
 328               	i
 329               	 ;  0 "" 2
 331 012a F0E0      	.LM19:
 332 012c 1082      	/* #NOAPP */
 125:ir_heat.c     **** 	sei();
 333               	Y+3,__zero_reg__
 334               		std Y+2,__zero_reg__
 335               		rjmp .L9
 336               	.L11:
 337 012e 7894      		ldi r30,lo8(41)
 338               		ldi r31,hi8(41)
 126:ir_heat.c     **** //	printf("In");
 127:ir_heat.c     **** 	for(i=0;i<2000;i++) if((PIND & (1<<SWITCH))) c++;
 339               	4,Z
 340               		mov r24,r24
 341               		ldi r25,lo8(0)
 342 0130 1B82      		andi r24,lo8(4)
 343 0132 1A82      		andi r25,hi8(4)
 344 0134 00C0      		sbiw r24,0
 345               		breq .L10
 346 0136 E9E2      		ldd r24,Y+1
 347 0138 F0E0      		subi r24,lo8(-(1))
 348 013a 8081      		std Y+1,r24
 349 013c 882F      	.L10:
 350 013e 90E0      		ldd r24,Y+2
 351 0140 8470      		ldd r25,Y+3
 352 0142 9070      		adiw r24,1
 353 0144 0097      		std Y+3,r25
 354 0146 01F0      		std Y+2,r24
 355 0148 8981      	.L9:
 356 014a 8F5F      		ldd r24,Y+2
 357 014c 8983      		ldd r25,Y+3
 358               		ldi r18,hi8(2000)
 359 014e 8A81      		cpi r24,lo8(2000)
 360 0150 9B81      		cpc r25,r18
 361 0152 0196      		brlo .L11
 363 0156 8A83      	.LM20:
 364               		ldd r24,Y+1
 365 0158 8A81      		cpi r24,lo8(100)
 366 015a 9B81      		brsh .L12
 368 015e 803D      	.LM21:
 369 0160 9207      		lds r24,mode
 370 0162 00F0      		mov r24,r24
 128:ir_heat.c     **** //	printf(" %i ", c);
 129:ir_heat.c     **** 
 130:ir_heat.c     **** 	if(c < 100) {
 371               	e .L18
 372               	.L14:
 374 0166 8436      	.LM22:
 375 0168 00F4      		lds r24,off_counter
 131:ir_heat.c     **** 		switch(mode) {
 376               	r24
 377               		breq .L15
 378 016a 8091 0000 		ldi r24,lo8(3)
 379 016e 882F      		sts mode,r24
 380 0170 90E0      		rjmp .L12
 381 0172 0097      	.L15:
 383               	.LM23:
 132:ir_heat.c     **** 		case MODE_OFF:
 133:ir_heat.c     **** 			if(off_counter) mode = MODE_TEMP_PROT;
 384               	,lo8(1)
 385               		sts mode,r24
 386 0176 8091 0000 		rjmp .L12
 387 017a 8823      	.L18:
 389 017e 83E0      	.LM24:
 390 0180 8093 0000 		sts mode,__zero_reg__
 391 0184 00C0      	.L12:
 134:ir_heat.c     **** 			else mode = MODE_ON;
 393               	di r30,lo8(60)
 394               		ldi r31,hi8(60)
 395 0186 81E0      		ldi r24,lo8(1)
 396 0188 8093 0000 		st Z,r24
 398               	.LM26:
 135:ir_heat.c     **** 			break;
 136:ir_heat.c     **** 		case MODE_ON:
 137:ir_heat.c     **** 		case MODE_TEMP_PROT:
 138:ir_heat.c     **** 		default:
 139:ir_heat.c     **** 			mode = MODE_OFF;
 399               	30,lo8(61)
 400               		ldi r31,hi8(61)
 401 018e 1092 0000 		ldi r24,lo8(1)
 402               		st Z,r24
 140:ir_heat.c     **** 		}
 141:ir_heat.c     **** 	}
 142:ir_heat.c     **** //	printf("Out\n");
 143:ir_heat.c     **** 	EIFR = (1<<INTF0);
 403               	abn	68,0,145,.LM27-.LFBB3
 404               	.LM27:
 405 0192 ECE3      		sts running.1718,__zero_reg__
 406 0194 F0E0      	.L17:
 407 0196 81E0      	/* epilogue start */
 144:ir_heat.c     **** 	EIMSK = (1<<INT0);
 409               	
 410               		pop __tmp_reg__
 411 019a EDE3      		pop __tmp_reg__
 412 019c F0E0      		pop __tmp_reg__
 413 019e 81E0      		pop r28
 414 01a0 8083      		pop r29
 145:ir_heat.c     **** 	running = 0;
 415               	r31
 416               		pop r30
 417 01a2 1092 0000 		pop r25
 418               		pop r24
 419               		pop r18
 146:ir_heat.c     **** }
 420               	r0
 421               		out __SREG__,r0
 422 01a6 0F90      		pop r0
 423 01a8 0F90      		pop __zero_reg__
 424 01aa 0F90      		reti
 431 01b8 2F91      	.Lscope3:
 433 01bc 0FBE      	.global	__vector_18
 435 01c0 1F90      	__vector_18:
 437               	.LM29:
 438               	.LFBB4:
 439               		push __zero_reg__
 440               		push r0
 441               		in r0,__SREG__
 442               		push r0
 443               		clr __zero_reg__
 444               		push r24
 445               		push r25
 446               		push r30
 447               		push r31
 147:ir_heat.c     **** 
 148:ir_heat.c     **** 
 149:ir_heat.c     **** SIGNAL(SIG_USART_RECV) {
 448               	tmp_reg__
 449               		in r28,__SP_L__
 450               		in r29,__SP_H__
 451 01c4 1F92      	/* prologue: Signal */
 452 01c6 0F92      	/* frame size = 1 */
 454 01ca 0F92      	.LM30:
 455 01cc 1124      		ldi r30,lo8(198)
 456 01ce 8F93      		ldi r31,hi8(198)
 457 01d0 9F93      		ld r24,Z
 458 01d2 EF93      		std Y+1,r24
 460 01d6 DF93      	.LM31:
 461 01d8 CF93      		lds r24,r_in
 462 01da 0F92      		mov r24,r24
 463 01dc CDB7      		ldi r25,lo8(0)
 464 01de DEB7      		andi r24,lo8(31)
 465               		andi r25,hi8(31)
 466               		movw r30,r24
 150:ir_heat.c     **** //******************
 151:ir_heat.c     **** // RX interrupt handler
 152:ir_heat.c     **** //
 153:ir_heat.c     **** 	char c;	
 154:ir_heat.c     **** 	c = UDR0;							// Get received char
 467               	f))
 468               		sbci r31,hi8(-(rbuf))
 469 01e0 E6EC      		ldd r24,Y+1
 470 01e2 F0E0      		st Z,r24
 472 01e6 8983      	.LM32:
 155:ir_heat.c     **** 	rbuf[r_in & RMASK] = c;
 473               	24,r_in
 474               		subi r24,lo8(-(1))
 475 01e8 8091 0000 		sts r_in,r24
 476 01ec 882F      	/* epilogue start */
 478 01f0 8F71      	.LM33:
 479 01f2 9070      		pop __tmp_reg__
 480 01f4 FC01      		pop r28
 481 01f6 E050      		pop r29
 482 01f8 F040      		pop r31
 483 01fa 8981      		pop r30
 484 01fc 8083      		pop r25
 156:ir_heat.c     **** 	r_in++;
 485               	p r0
 486               		out __SREG__,r0
 487 01fe 8091 0000 		pop r0
 488 0202 8F5F      		pop __zero_reg__
 489 0204 8093 0000 		reti
 157:ir_heat.c     **** }
 491               	s	"c:(0,2)",128,0,0,1
 494 020a CF91      	.Lscope4:
 496 020e FF91      	.global	__vector_19
 498 0212 9F91      	__vector_19:
 500 0216 0F90      	.LM34:
 501 0218 0FBE      	.LFBB5:
 502 021a 0F90      		push __zero_reg__
 503 021c 1F90      		push r0
 504 021e 1895      		in r0,__SREG__
 505               		push r0
 506               		clr __zero_reg__
 507               		push r24
 508               		push r25
 509               		push r26
 510               		push r27
 511               		push r30
 512               		push r31
 513               		push r29
 158:ir_heat.c     **** 
 159:ir_heat.c     **** SIGNAL(SIG_USART_DATA) {
 514               	L__
 515               		in r29,__SP_H__
 516               	/* prologue: Signal */
 517 0220 1F92      	/* frame size = 0 */
 519 0224 0FB6      	.LM35:
 520 0226 0F92      		lds r25,t_in
 521 0228 1124      		lds r24,t_out
 522 022a 8F93      		cp r25,r24
 523 022c 9F93      		breq .L22
 525 0230 BF93      	.LM36:
 526 0232 EF93      		ldi r26,lo8(198)
 527 0234 FF93      		ldi r27,hi8(198)
 528 0236 DF93      		lds r24,t_out
 529 0238 CF93      		mov r24,r24
 530 023a CDB7      		ldi r25,lo8(0)
 531 023c DEB7      		andi r24,lo8(31)
 532               		andi r25,hi8(31)
 533               		movw r30,r24
 160:ir_heat.c     **** //*******************
 161:ir_heat.c     **** // Data register empty interrupt handler.
 162:ir_heat.c     **** // Indicates that next char can be transmitted
 163:ir_heat.c     **** //
 164:ir_heat.c     **** 	if(t_in != t_out) {
 534               	))
 535               		sbci r31,hi8(-(tbuf))
 536 023e 9091 0000 		ld r24,Z
 537 0242 8091 0000 		st X,r24
 539 0248 01F0      	.LM37:
 165:ir_heat.c     **** 		UDR0 = tbuf[t_out & TMASK];
 540               	24,t_out
 541               		subi r24,lo8(-(1))
 542 024a A6EC      		sts t_out,r24
 543 024c B0E0      		rjmp .L24
 544 024e 8091 0000 	.L22:
 546 0254 90E0      	.LM38:
 547 0256 8F71      		ldi r26,lo8(193)
 548 0258 9070      		ldi r27,hi8(193)
 549 025a FC01      		ldi r30,lo8(193)
 550 025c E050      		ldi r31,hi8(193)
 551 025e F040      		ld r24,Z
 552 0260 8081      		andi r24,lo8(-33)
 553 0262 8C93      		st X,r24
 166:ir_heat.c     **** 		t_out++;	
 554               	gue start */
 556 0264 8091 0000 	.LM39:
 557 0268 8F5F      		pop r28
 558 026a 8093 0000 		pop r29
 559 026e 00C0      		pop r31
 560               		pop r30
 167:ir_heat.c     **** 	}
 168:ir_heat.c     **** 	else {
 169:ir_heat.c     **** 		UCSR0B &= ~(1<<UDRIE0);
 561               	7
 562               		pop r26
 563 0270 A1EC      		pop r25
 564 0272 B0E0      		pop r24
 565 0274 E1EC      		pop r0
 566 0276 F0E0      		out __SREG__,r0
 567 0278 8081      		pop r0
 568 027a 8F7D      		pop __zero_reg__
 569 027c 8C93      		reti
 571               	.Lscope5:
 170:ir_heat.c     **** 	}
 171:ir_heat.c     **** }
 572               	uflen:F(0,2)",36,0,0,tbuflen
 573               	.global	tbuflen
 575 0280 DF91      	tbuflen:
 577 0284 EF91      	.LM40:
 578 0286 BF91      	.LFBB6:
 579 0288 AF91      		push r29
 580 028a 9F91      		push r28
 581 028c 8F91      		in r28,__SP_L__
 582 028e 0F90      		in r29,__SP_H__
 583 0290 0FBE      	/* prologue: function */
 584 0292 0F90      	/* frame size = 0 */
 586 0296 1895      	.LM41:
 587               		lds r25,t_in
 588               		lds r24,t_out
 589               		mov r18,r25
 590               		sub r18,r24
 591               		mov r24,r18
 592               	/* epilogue start */
 172:ir_heat.c     **** 
 173:ir_heat.c     **** char tbuflen(void) {
 593               	2-.LFBB6
 594               	.LM42:
 595               		pop r28
 596 0298 DF93      		pop r29
 597 029a CF93      		ret
 599 029e DEB7      	.Lscope6:
 174:ir_heat.c     **** //****************
 175:ir_heat.c     **** // Retrieve pending chars in TX buffer
 176:ir_heat.c     **** //
 177:ir_heat.c     **** 	return(t_in - t_out);
 602               	stream:p(0,16)=*(6,1)",160,0,0,2
 603               	.global	UART_putchar
 605 02a4 8091 0000 	UART_putchar:
 607 02aa 281B      	.LM43:
 608 02ac 822F      	.LFBB7:
 609               		push r29
 178:ir_heat.c     **** }
 610               	8
 611               		rcall .
 612 02ae CF91      		push __tmp_reg__
 613 02b0 DF91      		in r28,__SP_L__
 614 02b2 0895      		in r29,__SP_H__
 615               	/* prologue: function */
 616               	/* frame size = 3 */
 617               		std Y+1,r24
 618               		std Y+3,r23
 619               		std Y+2,r22
 620               	.L28:
 622               	.LM44:
 179:ir_heat.c     **** 
 180:ir_heat.c     **** int UART_putchar(char c, FILE *stream) {
 623               	
 624               		mov r18,r24
 625               		ldi r19,lo8(0)
 626 02b4 DF93      		ldi r24,lo8(32)
 627 02b6 CF93      		ldi r25,hi8(32)
 628 02b8 00D0      		sub r24,r18
 629 02ba 0F92      		sbc r25,r19
 630 02bc CDB7      		cpi r24,3
 631 02be DEB7      		cpc r25,__zero_reg__
 632               		brlt .L28
 634 02c0 8983      	.LM45:
 635 02c2 7B83      		lds r24,t_in
 636 02c4 6A83      		mov r24,r24
 637               		ldi r25,lo8(0)
 181:ir_heat.c     **** //*********************
 182:ir_heat.c     **** // Fills the transmit buffer, if it is full wait
 183:ir_heat.c     **** //
 184:ir_heat.c     **** 	while((TBUFSIZE - tbuflen()) <= 2);  // Wait...
 638               	31)
 639               		andi r25,hi8(31)
 640 02c6 0E94 0000 		movw r30,r24
 641 02ca 282F      		subi r30,lo8(-(tbuf))
 642 02cc 30E0      		sbci r31,hi8(-(tbuf))
 643 02ce 80E2      		ldd r24,Y+1
 644 02d0 90E0      		st Z,r24
 646 02d4 930B      	.LM46:
 647 02d6 8330      		lds r24,t_in
 648 02d8 9105      		subi r24,lo8(-(1))
 649 02da 04F0      		sts t_in,r24
 185:ir_heat.c     **** 	
 186:ir_heat.c     **** 	// Add data to the transmit buffer, enable TXCIE
 187:ir_heat.c     **** 	//
 188:ir_heat.c     **** 	tbuf[t_in & TMASK] = c;
 650               	,190,.LM47-.LFBB7
 651               	.LM47:
 652 02dc 8091 0000 		ldi r26,lo8(193)
 653 02e0 882F      		ldi r27,hi8(193)
 654 02e2 90E0      		ldi r30,lo8(193)
 655 02e4 8F71      		ldi r31,hi8(193)
 656 02e6 9070      		ld r24,Z
 657 02e8 FC01      		ori r24,lo8(32)
 658 02ea E050      		st X,r24
 660 02ee 8981      	.LM48:
 661 02f0 8083      		ldi r24,lo8(0)
 189:ir_heat.c     **** 	t_in++;	
 662               	(0)
 663               	/* epilogue start */
 665 02f6 8F5F      	.LM49:
 666 02f8 8093 0000 		pop __tmp_reg__
 190:ir_heat.c     **** 	UCSR0B |= (1<<UDRIE0);			// Enable UDR empty interrupt	
 667               	__tmp_reg__
 668               		pop __tmp_reg__
 669 02fc A1EC      		pop r28
 670 02fe B0E0      		pop r29
 671 0300 E1EC      		ret
 673 0304 8081      	.Lscope7:
 675 0308 8C93      	.global	rbuflen
 191:ir_heat.c     **** 	return(0);
 676               	uflen, @function
 677               	rbuflen:
 679 030c 90E0      	.LM50:
 680               	.LFBB8:
 192:ir_heat.c     **** }
 681               	 r29
 682               		push r28
 683 030e 0F90      		in r28,__SP_L__
 684 0310 0F90      		in r29,__SP_H__
 685 0312 0F90      	/* prologue: function */
 686 0314 CF91      	/* frame size = 0 */
 688 0318 0895      	.LM51:
 689               		lds r25,r_in
 690               		lds r24,r_out
 691               		mov r18,r25
 692               		sub r18,r24
 693               		mov r24,r18
 694               	/* epilogue start */
 193:ir_heat.c     **** 
 194:ir_heat.c     **** char rbuflen(void) {
 695               	99,.LM52-.LFBB8
 696               	.LM52:
 697               		pop r28
 698 031a DF93      		pop r29
 699 031c CF93      		ret
 701 0320 DEB7      	.Lscope8:
 195:ir_heat.c     **** // ***************
 196:ir_heat.c     **** // Retrive pending chars in RX buffer
 197:ir_heat.c     **** //
 198:ir_heat.c     **** 	return(r_in - r_out);
 704               	ART_getchar
 706 0322 9091 0000 	UART_getchar:
 708 032a 292F      	.LM53:
 709 032c 281B      	.LFBB9:
 710 032e 822F      		push r29
 711               		push r28
 199:ir_heat.c     **** }
 712               	
 713               		push __tmp_reg__
 714 0330 CF91      		in r28,__SP_L__
 715 0332 DF91      		in r29,__SP_H__
 716 0334 0895      	/* prologue: function */
 717               	/* frame size = 3 */
 718               		std Y+3,r25
 719               		std Y+2,r24
 720               	.L33:
 722               	.LM54:
 723               		call rbuflen
 200:ir_heat.c     **** 
 201:ir_heat.c     **** int UART_getchar(FILE *stream) {
 724               	req .L33
 726               	.LM55:
 727 0336 DF93      		lds r24,r_out
 728 0338 CF93      		mov r24,r24
 729 033a 00D0      		ldi r25,lo8(0)
 730 033c 0F92      		andi r24,lo8(31)
 731 033e CDB7      		andi r25,hi8(31)
 732 0340 DEB7      		movw r30,r24
 733               		subi r30,lo8(-(rbuf))
 734               		sbci r31,hi8(-(rbuf))
 735 0342 9B83      		ld r24,Z
 736 0344 8A83      		std Y+1,r24
 202:ir_heat.c     **** //*******************
 203:ir_heat.c     **** // Retieves character from UART. This function is to be passed
 204:ir_heat.c     **** // to fdevopen
 205:ir_heat.c     **** //
 206:ir_heat.c     **** 	unsigned char c;
 207:ir_heat.c     **** 	while(rbuflen() == 0);	  // Wait...
 738               	4,r_out
 739               		subi r24,lo8(-(1))
 740 0346 0E94 0000 		sts r_out,r24
 742 034c 01F0      	.LM57:
 208:ir_heat.c     **** 	c = rbuf[r_out & RMASK];
 743               	r24,Y+1
 744               		mov r24,r24
 745 034e 8091 0000 		ldi r25,lo8(0)
 746 0352 882F      	/* epilogue start */
 748 0356 8F71      	.LM58:
 749 0358 9070      		pop __tmp_reg__
 750 035a FC01      		pop __tmp_reg__
 751 035c E050      		pop __tmp_reg__
 752 035e F040      		pop r28
 753 0360 8081      		pop r29
 754 0362 8983      		ret
 209:ir_heat.c     **** 	r_out++;	
 755               	getchar, .-UART_getchar
 759 036a 8093 0000 	.Lscope9:
 210:ir_heat.c     **** 	return(c);
 760               	bs	"UART_first_init:F(0,15)",36,0,0,UART_first_init
 761               	.global	UART_first_init
 763 0370 882F      	UART_first_init:
 765               	.LM59:
 211:ir_heat.c     **** }
 766               	0:
 767               		push r29
 768 0374 0F90      		push r28
 769 0376 0F90      		in r28,__SP_L__
 770 0378 0F90      		in r29,__SP_H__
 771 037a CF91      	/* prologue: function */
 772 037c DF91      	/* frame size = 0 */
 774               	.LM60:
 775               		ldi r30,lo8(196)
 776               		ldi r31,hi8(196)
 777               		ldi r24,lo8(12)
 778               		ldi r25,hi8(12)
 779               		std Z+1,r25
 780               		st Z,r24
 782               	.LM61:
 212:ir_heat.c     **** 
 213:ir_heat.c     **** void UART_first_init(void) {
 783               	
 784               		ldi r31,hi8(193)
 785               		ldi r24,lo8(-104)
 786 0380 DF93      		st Z,r24
 788 0384 CDB7      	.LM62:
 789 0386 DEB7      		ldi r30,lo8(194)
 790               		ldi r31,hi8(194)
 791               		ldi r24,lo8(6)
 214:ir_heat.c     **** //***********************
 215:ir_heat.c     **** // The function fdevopen(..) must contain as parameters the
 216:ir_heat.c     **** // corresponding  ..putchar() and  ..getchar() functions, defined before.
 217:ir_heat.c     **** //
 218:ir_heat.c     **** 	UBRR0 = 12;										 // 4800 BPS
 792               	4
 794 0388 E4EC      	.LM63:
 795 038a F0E0      		ldi r24,lo8(gs(UART_putchar))
 796 038c 8CE0      		ldi r25,hi8(gs(UART_putchar))
 797 038e 90E0      		ldi r18,lo8(gs(UART_getchar))
 798 0390 9183      		ldi r19,hi8(gs(UART_getchar))
 799 0392 8083      		movw r22,r18
 219:ir_heat.c     **** 	
 220:ir_heat.c     **** 	UCSR0B = (1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0);	 // 8 Databits, receive and transmit enabled, receive 
 800               	evopen
 802 0394 E1EC      	.LM64:
 803 0396 F0E0      	/* #APP */
 804 0398 88E9      	 ;  224 "ir_heat.c" 1
 805 039a 8083      		sei
 221:ir_heat.c     **** 	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
 806               	"" 2
 807               	/* epilogue start */
 809 039e F0E0      	.LM65:
 810 03a0 86E0      	/* #NOAPP */
 811 03a2 8083      		pop r28
 222:ir_heat.c     **** 	
 223:ir_heat.c     **** 	fdevopen(UART_putchar, UART_getchar);
 812               	29
 813               		ret
 815 03a6 90E0      	.Lscope10:
 816 03a8 20E0      		.data
 817 03aa 30E0      	.LC0:
 818 03ac B901      		.string	"Array:"
 819 03ae 0E94 0000 	.LC1:
 224:ir_heat.c     **** 	sei();											 // Global interrupt enable
 820               		" %i"
 821               		.text
 823               	.global	print_array
 825               	print_array:
 225:ir_heat.c     **** }
 827               	.LFBB11:
 828               		push r29
 829               		push r28
 830 03b4 CF91      		push __tmp_reg__
 831 03b6 DF91      		in r28,__SP_L__
 832 03b8 0895      		in r29,__SP_H__
 833               	/* prologue: function */
 834               	/* frame size = 1 */
 836               	.LM67:
 837 0009 4172 7261 		rcall .
 837      793A 00
 838               		in r30,__SP_L__
 839 0010 2025 6900 		in r31,__SP_H__
 840               		adiw r30,1
 841               		ldi r24,lo8(.LC0)
 842               		ldi r25,hi8(.LC0)
 843               		std Z+1,r25
 844               		st Z,r24
 226:ir_heat.c     **** 
 227:ir_heat.c     **** 
 228:ir_heat.c     **** void print_array(){
 845               	__tmp_reg__
 846               		pop __tmp_reg__
 848 03ba DF93      	.LM68:
 849 03bc CF93      		std Y+1,__zero_reg__
 850 03be 0F92      		rjmp .L38
 851 03c0 CDB7      	.L39:
 853               	.LM69:
 854               		ldd r24,Y+1
 229:ir_heat.c     **** 	uint8_t i;
 230:ir_heat.c     ****   	printf("Array:");
 855               	24
 856               		ldi r25,lo8(0)
 857 03c4 00D0      		lsl r24
 858 03c6 EDB7      		rol r25
 859 03c8 FEB7      		movw r30,r24
 860 03ca 3196      		subi r30,lo8(-(t_array))
 861 03cc 80E0      		sbci r31,hi8(-(t_array))
 862 03ce 90E0      		ld r18,Z
 863 03d0 9183      		ldd r19,Z+1
 864 03d2 8083      		rcall .
 865 03d4 0E94 0000 		rcall .
 866 03d8 0F90      		in r30,__SP_L__
 867 03da 0F90      		in r31,__SP_H__
 231:ir_heat.c     **** 	for(i=0;i<6;i++) {
 868               	ldi r24,lo8(.LC1)
 869               		ldi r25,hi8(.LC1)
 870 03dc 1982      		std Z+1,r25
 871 03de 00C0      		st Z,r24
 872               		std Z+3,r19
 232:ir_heat.c     ****    	printf(" %i", t_array[i]);
 873               	Z+2,r18
 874               		call printf
 875 03e0 8981      		pop __tmp_reg__
 876 03e2 882F      		pop __tmp_reg__
 877 03e4 90E0      		pop __tmp_reg__
 878 03e6 880F      		pop __tmp_reg__
 880 03ea FC01      	.LM70:
 881 03ec E050      		ldd r24,Y+1
 882 03ee F040      		subi r24,lo8(-(1))
 883 03f0 2081      		std Y+1,r24
 884 03f2 3181      	.L38:
 885 03f4 00D0      		ldd r24,Y+1
 886 03f6 00D0      		cpi r24,lo8(6)
 887 03f8 EDB7      		brlo .L39
 889 03fc 3196      	.LM71:
 890 03fe 80E0      		ldi r24,lo8(10)
 891 0400 90E0      		ldi r25,hi8(10)
 892 0402 9183      		call putchar
 893 0404 8083      	/* epilogue start */
 895 0408 2283      	.LM72:
 896 040a 0E94 0000 		pop __tmp_reg__
 897 040e 0F90      		pop r28
 898 0410 0F90      		pop r29
 899 0412 0F90      		ret
 904 0418 8F5F      	.Lscope11:
 907 041c 8981      	.global	add_value
 909 0420 00F0      	add_value:
 233:ir_heat.c     **** 	}
 234:ir_heat.c     ****   	printf("\n");
 910               	
 911               	.LFBB12:
 912 0422 8AE0      		push r29
 913 0424 90E0      		push r28
 914 0426 0E94 0000 		rcall .
 915               		push __tmp_reg__
 235:ir_heat.c     **** }
 916               	28,__SP_L__
 917               		in r29,__SP_H__
 918 042a 0F90      	/* prologue: function */
 919 042c CF91      	/* frame size = 3 */
 920 042e DF91      		std Y+3,r25
 921 0430 0895      		std Y+2,r24
 923               	.LM74:
 924               		lds r24,t_array
 925               		lds r25,(t_array)+1
 926               		sbiw r24,0
 927               		brne .L42
 929               	.LM75:
 930               		ldd r24,Y+2
 931               		ldd r25,Y+3
 236:ir_heat.c     **** 
 237:ir_heat.c     **** 
 238:ir_heat.c     **** void add_value(uint16_t value) {
 932               	)+1,r25
 933               		sts t_array+10,r24
 934               		lds r24,t_array+10
 935 0432 DF93      		lds r25,(t_array+10)+1
 936 0434 CF93      		sts (t_array+8)+1,r25
 937 0436 00D0      		sts t_array+8,r24
 938 0438 0F92      		lds r24,t_array+8
 939 043a CDB7      		lds r25,(t_array+8)+1
 940 043c DEB7      		sts (t_array+6)+1,r25
 941               		sts t_array+6,r24
 942               		lds r24,t_array+6
 943 043e 9B83      		lds r25,(t_array+6)+1
 944 0440 8A83      		sts (t_array+4)+1,r25
 239:ir_heat.c     **** 	uint8_t i;
 240:ir_heat.c     **** 	if(t_array[0]==0) {
 945               	4,r24
 946               		lds r24,t_array+4
 947 0442 8091 0000 		lds r25,(t_array+4)+1
 948 0446 9091 0000 		sts (t_array+2)+1,r25
 949 044a 0097      		sts t_array+2,r24
 950 044c 01F4      		lds r24,t_array+2
 241:ir_heat.c     **** 		t_array[0]=t_array[1]=t_array[2]=t_array[3]=t_array[4]=t_array[5]=value;
 951               	25,(t_array+2)+1
 952               		sts (t_array)+1,r25
 953 044e 8A81      		sts t_array,r24
 954 0450 9B81      		rjmp .L46
 955 0452 9093 0000 	.L42:
 957 045a 8091 0000 	.LM76:
 958 045e 9091 0000 		std Y+1,__zero_reg__
 959 0462 9093 0000 		rjmp .L44
 960 0466 8093 0000 	.L45:
 962 046e 9091 0000 	.LM77:
 963 0472 9093 0000 		ldd r24,Y+1
 964 0476 8093 0000 		mov r20,r24
 965 047a 8091 0000 		ldi r21,lo8(0)
 966 047e 9091 0000 		ldd r24,Y+1
 967 0482 9093 0000 		mov r24,r24
 968 0486 8093 0000 		ldi r25,lo8(0)
 969 048a 8091 0000 		adiw r24,1
 970 048e 9091 0000 		lsl r24
 971 0492 9093 0000 		rol r25
 972 0496 8093 0000 		movw r30,r24
 973 049a 8091 0000 		subi r30,lo8(-(t_array))
 974 049e 9091 0000 		sbci r31,hi8(-(t_array))
 975 04a2 9093 0000 		ld r18,Z
 976 04a6 8093 0000 		ldd r19,Z+1
 977 04aa 00C0      		movw r24,r20
 978               		lsl r24
 242:ir_heat.c     **** 	}
 243:ir_heat.c     **** 	else {
 244:ir_heat.c     **** 		for(i=0;i<5;i++) {
 979               	 r30,lo8(-(t_array))
 980               		sbci r31,hi8(-(t_array))
 981 04ac 1982      		std Z+1,r19
 982 04ae 00C0      		st Z,r18
 245:ir_heat.c     **** 			t_array[i]=t_array[i+1];
 984               	:
 985               		ldd r24,Y+1
 986 04b0 8981      		subi r24,lo8(-(1))
 987 04b2 482F      		std Y+1,r24
 988 04b4 50E0      	.L44:
 989 04b6 8981      		ldd r24,Y+1
 990 04b8 882F      		cpi r24,lo8(5)
 991 04ba 90E0      		brlo .L45
 993 04be 880F      	.LM79:
 994 04c0 991F      		ldd r24,Y+2
 995 04c2 FC01      		ldd r25,Y+3
 996 04c4 E050      		sts (t_array+10)+1,r25
 997 04c6 F040      		sts t_array+10,r24
 999 04ca 3181      	.LM80:
 1000 04cc CA01      		lds r18,t_array+10
 1001 04ce 880F      		lds r19,(t_array+10)+1
 1002 04d0 991F      		lds r24,t_array+8
 1003 04d2 FC01      		lds r25,(t_array+8)+1
 1004 04d4 E050      		movw r20,r18
 1005 04d6 F040      		sub r20,r24
 1006 04d8 3183      		sbc r21,r25
 1007 04da 2083      		movw r24,r20
 1008               		movw r18,r24
 1009               		lsl r18
 1010 04dc 8981      		rol r19
 1011 04de 8F5F      		movw r24,r18
 1012 04e0 8983      		lsl r24
 1013               		rol r25
 1014 04e2 8981      		lsl r24
 1015 04e4 8530      		rol r25
 1016 04e6 00F0      		movw r22,r18
 246:ir_heat.c     **** 		}
 247:ir_heat.c     **** 		t_array[5] = value;
 1017               	0,slope2
 1018               		lds r21,(slope2)+1
 1019 04e8 8A81      		movw r24,r20
 1020 04ea 9B81      		lsl r24
 1021 04ec 9093 0000 		rol r25
 1022 04f0 8093 0000 		movw r18,r24
 248:ir_heat.c     **** 		slope2 = (10*(t_array[5]-t_array[4]) + 19*slope2) / 20;
 1023               	18
 1024               		rol r19
 1025 04f4 2091 0000 		lsl r18
 1026 04f8 3091 0000 		rol r19
 1027 04fc 8091 0000 		lsl r18
 1028 0500 9091 0000 		rol r19
 1029 0504 A901      		add r24,r18
 1030 0506 481B      		adc r25,r19
 1031 0508 590B      		add r24,r20
 1032 050a CA01      		adc r25,r21
 1033 050c 9C01      		add r24,r22
 1034 050e 220F      		adc r25,r23
 1035 0510 331F      		ldi r18,lo8(20)
 1036 0512 C901      		ldi r19,hi8(20)
 1037 0514 880F      		movw r22,r18
 1038 0516 991F      		call __divmodhi4
 1039 0518 880F      		movw r24,r22
 1040 051a 991F      		sts (slope2)+1,r25
 1041 051c B901      		sts slope2,r24
 1042 051e 680F      	.L46:
 1043 0520 791F      	/* epilogue start */
 1045 0526 5091 0000 	.LM81:
 1046 052a CA01      		pop __tmp_reg__
 1047 052c 880F      		pop __tmp_reg__
 1048 052e 991F      		pop __tmp_reg__
 1049 0530 9C01      		pop r28
 1050 0532 220F      		pop r29
 1051 0534 331F      		ret
 1056 053e 820F      	.Lscope12:
 1058 0542 840F      	.global	get_slope
 1060 0546 860F      	get_slope:
 1062 054a 24E1      	.LM82:
 1063 054c 30E0      	.LFBB13:
 1064 054e B901      		push r29
 1065 0550 0E94 0000 		push r28
 1066 0554 CB01      		rcall .
 1067 0556 9093 0000 		rcall .
 1068 055a 8093 0000 		rcall .
 1069               		in r28,__SP_L__
 1070               		in r29,__SP_H__
 249:ir_heat.c     **** 	}
 250:ir_heat.c     **** }
 1071               	stabn	68,0,256,.LM83-.LFBB13
 1072               	.LM83:
 1073 055e 0F90      		lds r18,t_array+10
 1074 0560 0F90      		lds r19,(t_array+10)+1
 1075 0562 0F90      		lds r24,t_array
 1076 0564 CF91      		lds r25,(t_array)+1
 1077 0566 DF91      		movw r20,r18
 1078 0568 0895      		sub r20,r24
 1079               		sbc r21,r25
 1080               		movw r24,r20
 1081               		std Y+6,r25
 1082               		std Y+5,r24
 1084               	.LM84:
 1085               		lds r18,t_array+8
 1086               		lds r19,(t_array+8)+1
 1087               		lds r24,t_array+2
 251:ir_heat.c     **** 
 252:ir_heat.c     **** 
 253:ir_heat.c     **** int16_t get_slope() {
 1088               	+2)+1
 1089               		movw r20,r18
 1090               		sub r20,r24
 1091 056a DF93      		sbc r21,r25
 1092 056c CF93      		movw r24,r20
 1093 056e 00D0      		std Y+4,r25
 1094 0570 00D0      		std Y+3,r24
 1096 0574 CDB7      	.LM85:
 1097 0576 DEB7      		lds r18,t_array+6
 1098               		lds r19,(t_array+6)+1
 1099               		lds r24,t_array+4
 254:ir_heat.c     **** 	int16_t s1, s2, s3;
 255:ir_heat.c     **** 
 256:ir_heat.c     **** 	s1 = t_array[5] - t_array[0];
 1100               	array+4)+1
 1101               		movw r20,r18
 1102 0578 2091 0000 		sub r20,r24
 1103 057c 3091 0000 		sbc r21,r25
 1104 0580 8091 0000 		movw r24,r20
 1105 0584 9091 0000 		std Y+2,r25
 1106 0588 A901      		std Y+1,r24
 1108 058c 590B      	.LM86:
 1109 058e CA01      		ldd r18,Y+5
 1110 0590 9E83      		ldd r19,Y+6
 1111 0592 8D83      		movw r24,r18
 257:ir_heat.c     **** 	s2 = t_array[4] - t_array[1];
 1112               	l r25
 1113               		movw r20,r24
 1114 0594 2091 0000 		add r20,r18
 1115 0598 3091 0000 		adc r21,r19
 1116 059c 8091 0000 		ldd r18,Y+3
 1117 05a0 9091 0000 		ldd r19,Y+4
 1118 05a4 A901      		movw r24,r18
 1119 05a6 481B      		lsl r24
 1120 05a8 590B      		rol r25
 1121 05aa CA01      		lsl r24
 1122 05ac 9C83      		rol r25
 1123 05ae 8B83      		add r24,r18
 258:ir_heat.c     **** 	s3 = t_array[3] - t_array[2];
 1124               	
 1125               		add r20,r24
 1126 05b0 2091 0000 		adc r21,r25
 1127 05b4 3091 0000 		ldd r18,Y+1
 1128 05b8 8091 0000 		ldd r19,Y+2
 1129 05bc 9091 0000 		movw r24,r18
 1130 05c0 A901      		lsl r24
 1131 05c2 481B      		rol r25
 1132 05c4 590B      		add r24,r18
 1133 05c6 CA01      		adc r25,r19
 1134 05c8 9A83      		movw r18,r24
 1135 05ca 8983      		lsl r18
 259:ir_heat.c     **** 	
 260:ir_heat.c     **** 	return ((3*s1+5*s2+15*s3)/9);
 1136               	sl r18
 1137               		rol r19
 1138 05cc 2D81      		add r24,r18
 1139 05ce 3E81      		adc r25,r19
 1140 05d0 C901      		add r24,r20
 1141 05d2 880F      		adc r25,r21
 1142 05d4 991F      		ldi r18,lo8(9)
 1143 05d6 AC01      		ldi r19,hi8(9)
 1144 05d8 420F      		movw r22,r18
 1145 05da 531F      		call __divmodhi4
 1146 05dc 2B81      		movw r24,r22
 1147 05de 3C81      	/* epilogue start */
 1149 05e2 880F      	.LM87:
 1150 05e4 991F      		adiw r28,6
 1151 05e6 880F      		in __tmp_reg__,__SREG__
 1152 05e8 991F      		cli
 1153 05ea 820F      		out __SP_H__,r29
 1154 05ec 931F      		out __SREG__,__tmp_reg__
 1155 05ee 480F      		out __SP_L__,r28
 1156 05f0 591F      		pop r28
 1157 05f2 2981      		pop r29
 1158 05f4 3A81      		ret
 1165 0602 220F      	.Lscope13:
 1169 060a 820F      	.global	lookahead_temp
 1171 060e 840F      	lookahead_temp:
 1173 0612 29E0      	.LM88:
 1174 0614 30E0      	.LFBB14:
 1175 0616 B901      		push r29
 1176 0618 0E94 0000 		push r28
 1177 061c CB01      		rcall .
 1178               		rcall .
 261:ir_heat.c     **** }
 1179               	ue: function */
 1180               	/* frame size = 4 */
 1181 061e 2696      		std Y+3,r24
 1182 0620 0FB6      		std Y+4,r22
 1184 0624 DEBF      	.LM89:
 1185 0626 0FBE      		lds r18,t_array+10
 1186 0628 CDBF      		lds r19,(t_array+10)+1
 1187 062a CF91      		lds r24,t_array+8
 1188 062c DF91      		lds r25,(t_array+8)+1
 1189 062e 0895      		add r24,r18
 1190               		adc r25,r19
 1191               		asr r25
 1192               		ror r24
 1193               		std Y+2,r25
 1194               		std Y+1,r24
 1196               	.LM90:
 1197               		ldd r24,Y+4
 1198               		mov r18,r24
 1199               		ldi r19,lo8(0)
 1200               		ldd r24,Y+3
 1201               		clr r25
 1202               		sbrc r24,7
 262:ir_heat.c     **** 
 263:ir_heat.c     **** 
 264:ir_heat.c     **** int16_t lookahead_temp(int8_t slope, uint8_t steps) {
 1203               	mul r18,r20
 1204               		movw r24,r0
 1205               		mul r18,r21
 1206 0630 DF93      		add r25,r0
 1207 0632 CF93      		mul r19,r20
 1208 0634 00D0      		add r25,r0
 1209 0636 00D0      		clr r1
 1210 0638 CDB7      		movw r18,r24
 1211 063a DEB7      		ldd r24,Y+1
 1212               		ldd r25,Y+2
 1213               		add r24,r18
 1214 063c 8B83      		adc r25,r19
 1215 063e 6C83      	/* epilogue start */
 265:ir_heat.c     **** 	uint16_t av;
 266:ir_heat.c     **** //	for(i=0;i<6;i++) {
 267:ir_heat.c     **** //		if(t_array[i]>max) max=t_array[i];
 268:ir_heat.c     **** //	}
 269:ir_heat.c     **** 	av = (t_array[5]+t_array[4])>>1;
 1216               	271,.LM91-.LFBB14
 1217               	.LM91:
 1218 0640 2091 0000 		pop __tmp_reg__
 1219 0644 3091 0000 		pop __tmp_reg__
 1220 0648 8091 0000 		pop __tmp_reg__
 1221 064c 9091 0000 		pop __tmp_reg__
 1222 0650 820F      		pop r28
 1223 0652 931F      		pop r29
 1224 0654 9595      		ret
 270:ir_heat.c     **** 	return (av + steps*(int16_t)slope);
 1228               	0,0,.Lscope14-.LFBB14
 1229               	.Lscope14:
 1232 0660 30E0      	.global	get_temperature
 1234 0664 9927      	get_temperature:
 1236 0668 9095      	.LM92:
 1237 066a AC01      	.LFBB15:
 1238 066c 249F      		push r29
 1239 066e C001      		push r28
 1240 0670 259F      		in r28,__SP_L__
 1241 0672 900D      		in r29,__SP_H__
 1242 0674 349F      		sbiw r28,15
 1243 0676 900D      		in __tmp_reg__,__SREG__
 1244 0678 1124      		cli
 1245 067a 9C01      		out __SP_H__,r29
 1246 067c 8981      		out __SREG__,__tmp_reg__
 1247 067e 9A81      		out __SP_L__,r28
 1248 0680 820F      	/* prologue: function */
 1249 0682 931F      	/* frame size = 15 */
 1250               		std Y+13,r24
 271:ir_heat.c     **** }
 1251               	.LFBB15
 1252               	.LM93:
 1253 0684 0F90      		ldi r24,lo8(-76)
 1254 0686 0F90      		call i2c_start
 1256 068a 0F90      	.LM94:
 1257 068c CF91      		ldd r24,Y+13
 1258 068e DF91      		call i2c_write
 1260               	.LM95:
 1261               		ldi r24,lo8(-75)
 1262               		call i2c_rep_start
 1263               		std Y+4,r24
 1265               	.LM96:
 1266               		ldd r24,Y+4
 1267               		tst r24
 1268               		breq .L52
 272:ir_heat.c     **** 
 273:ir_heat.c     **** 
 274:ir_heat.c     **** 
 275:ir_heat.c     **** uint16_t get_temperature(uint8_t adr) {
 1270               	(-75)
 1271               		call i2c_rep_start
 1272               	.L52:
 1274 0694 CF93      	.LM98:
 1275 0696 CDB7      		call i2c_read_ack
 1276 0698 DEB7      		std Y+3,r24
 1278 069c 0FB6      	.LM99:
 1279 069e F894      		call i2c_read_ack
 1280 06a0 DEBF      		std Y+2,r24
 1282 06a4 CDBF      	.LM100:
 1283               		ldd r24,Y+2
 1284               		mov r24,r24
 1285 06a6 8D87      		ldi r25,lo8(0)
 276:ir_heat.c     **** 	uint16_t raw;
 277:ir_heat.c     **** 	uint8_t 	ret;
 278:ir_heat.c     **** 	uint8_t 	lo, hi, pec;
 279:ir_heat.c     **** 	uint8_t	pec_read[6];
 280:ir_heat.c     **** 
 281:ir_heat.c     **** 	i2c_start(MLX90614_WRITE);
 1286               	r r24
 1287               		movw r18,r24
 1288 06a8 84EB      		ldd r24,Y+3
 1289 06aa 0E94 0000 		mov r24,r24
 282:ir_heat.c     **** 	i2c_write(adr);
 1290               	 r25,lo8(0)
 1291               		add r24,r18
 1292 06ae 8D85      		adc r25,r19
 1293 06b0 0E94 0000 		std Y+6,r25
 283:ir_heat.c     **** 	
 284:ir_heat.c     **** 	ret = i2c_rep_start(MLX90614_READ);
 1294               	 Y+5,r24
 1296 06b4 85EB      	.LM101:
 1297 06b6 0E94 0000 		call i2c_read_ack
 1298 06ba 8C83      		std Y+1,r24
 285:ir_heat.c     **** 	if(ret) {
 1299               	bn	68,0,295,.LM102-.LFBB15
 1300               	.LM102:
 1301 06bc 8C81      		call i2c_stop
 1303 06c0 01F0      	.LM103:
 286:ir_heat.c     **** 		i2c_rep_start(MLX90614_READ);
 1304               	r24,Y+5
 1305               		ldd r25,Y+6
 1306 06c2 85EB      		tst r25
 1307 06c4 0E94 0000 		brge .L53
 1308               		std Y+15,__zero_reg__
 287:ir_heat.c     ****    }
 288:ir_heat.c     **** 
 289:ir_heat.c     **** 	lo = i2c_read_ack();
 1309               	Y+14,__zero_reg__
 1310               		rjmp .L54
 1311 06c8 0E94 0000 	.L53:
 290:ir_heat.c     **** 	hi = i2c_read_ack();
 1313               	04:
 1314               		ldd r24,Y+5
 1315 06ce 0E94 0000 		ldd r25,Y+6
 1316 06d2 8A83      		ldi r18,lo8(5)
 291:ir_heat.c     **** 	raw = (uint16_t)(hi<<8)+lo;
 1317               	 r19,hi8(5)
 1318               		movw r22,r18
 1319 06d4 8A81      		call __udivmodhi4
 1320 06d6 882F      		movw r24,r22
 1321 06d8 90E0      		movw r18,r24
 1322 06da 982F      		subi r18,lo8(-(-2731))
 1323 06dc 8827      		sbci r19,hi8(-(-2731))
 1324 06de 9C01      		std Y+15,r19
 1325 06e0 8B81      		std Y+14,r18
 1326 06e2 882F      	.L54:
 1327 06e4 90E0      		ldd r24,Y+14
 1328 06e6 820F      		ldd r25,Y+15
 1329 06e8 931F      	/* epilogue start */
 1331 06ec 8D83      	.LM105:
 292:ir_heat.c     **** 	//printf("0x%04x\n", raw);
 293:ir_heat.c     **** 	pec = i2c_read_ack();
 1332               	n __tmp_reg__,__SREG__
 1333               		cli
 1334 06ee 0E94 0000 		out __SP_H__,r29
 1335 06f2 8983      		out __SREG__,__tmp_reg__
 294:ir_heat.c     **** 	
 295:ir_heat.c     **** 	i2c_stop();
 1336               	 __SP_L__,r28
 1337               		pop r28
 1338 06f4 0E94 0000 		pop r29
 296:ir_heat.c     **** 	if(raw & 0x8000) return 0;
 1339               	t
 297:ir_heat.c     **** 	
 298:ir_heat.c     **** 	return (raw / 5 - 2731);
 1349               	
 1350               		.lcomm last.1940,1
 1351 0706 8D81      		.data
 1352 0708 9E81      	.LC2:
 1353 070a 25E0      		.string	">>> Relais ON"
 1354 070c 30E0      	.LC3:
 1355 070e B901      		.string	">>> Relais OFF"
 1356 0710 0E94 0000 		.text
 1359 0718 2B5A      	.global	set_relais
 1361 071c 3F87      	set_relais:
 1363               	.LM106:
 1364 0720 8E85      	.LFBB16:
 1365 0722 9F85      		push r29
 1366               		push r28
 299:ir_heat.c     **** }
 1367               	
 1368               		in r28,__SP_L__
 1369 0724 2F96      		in r29,__SP_H__
 1370 0726 0FB6      	/* prologue: function */
 1371 0728 F894      	/* frame size = 1 */
 1372 072a DEBF      		std Y+1,r24
 1374 072e CDBF      	.LM107:
 1375 0730 CF91      		ldd r24,Y+1
 1376 0732 DF91      		tst r24
 1377 0734 0895      		breq .L57
 1379               	.LM108:
 1380               		lds r25,last.1940
 1381               		ldd r24,Y+1
 1382               		cp r24,r25
 1383               		breq .L58
 1384               		ldi r24,lo8(.LC2)
 1385               		ldi r25,hi8(.LC2)
 1386               		call puts
 1387               	.L58:
 1389               	.LM109:
 1390               		ldi r26,lo8(37)
 1391 0014 3E3E 3E20 		ldi r27,hi8(37)
 1391      5265 6C61 
 1391      6973 204F 
 1391      4E00 
 1392               		ldi r30,lo8(37)
 1393 0022 3E3E 3E20 		ldi r31,hi8(37)
 1393      5265 6C61 
 1393      6973 204F 
 1393      4646 00
 1394               		ld r24,Z
 1395               		ori r24,lo8(64)
 1396               		st X,r24
 1397               		rjmp .L59
 1398               	.L57:
 300:ir_heat.c     **** 
 301:ir_heat.c     **** 
 302:ir_heat.c     **** void set_relais(uint8_t on) {
 1400               	r24,Y+1
 1401               		cp r24,r25
 1402               		breq .L60
 1403 0736 DF93      		ldi r24,lo8(.LC3)
 1404 0738 CF93      		ldi r25,hi8(.LC3)
 1405 073a 0F92      		call puts
 1406 073c CDB7      	.L60:
 1408               	.LM111:
 1409               		ldi r26,lo8(37)
 1410 0740 8983      		ldi r27,hi8(37)
 303:ir_heat.c     **** 	static uint8_t last = 0;
 304:ir_heat.c     **** 	if(on) {
 1411               	8(37)
 1412               		ldi r31,hi8(37)
 1413 0742 8981      		ld r24,Z
 1414 0744 8823      		andi r24,lo8(-65)
 1415 0746 01F0      		st X,r24
 305:ir_heat.c     **** 		if(on != last) printf(">>> Relais ON\n");
 1416               	
 1418 0748 9091 0000 	.LM112:
 1419 074c 8981      		ldd r24,Y+1
 1420 074e 8917      		sts last.1940,r24
 1421 0750 01F0      	/* epilogue start */
 1423 0754 90E0      	.LM113:
 1424 0756 0E94 0000 		pop __tmp_reg__
 1425               		pop r28
 306:ir_heat.c     **** 		RELAIS_ON;
 1426               		ret
 1431 0760 F0E0      	.Lscope16:
 1432 0762 8081      		.data
 1433 0764 8064      	.LC4:
 1434 0766 8C93      		.string	"\nStart"
 1435 0768 00C0      	.LC5:
 1436               		.string	"Error Temp=0"
 307:ir_heat.c     **** 	}
 308:ir_heat.c     **** 	else {
 309:ir_heat.c     **** 		if(on != last) printf(">>> Relais OFF\n");
 1437               	ing	"Startup %i "
 1438               	.LC7:
 1439 076a 9091 0000 		.string	"Temp: %i, "
 1440 076e 8981      	.LC8:
 1441 0770 8917      		.string	"slope_raw: %i, slope: %i "
 1442 0772 01F0      	.LC9:
 1443 0774 80E0      		.string	"Ambient: %i\n"
 1444 0776 90E0      	.LC10:
 1445 0778 0E94 0000 		.string	"Temperature Protect Rule 48, "
 1446               	.LC11:
 310:ir_heat.c     **** 		RELAIS_OFF;
 1447               	Temperature Protect Rule 45, "
 1448               	.LC12:
 1449 077c A5E2      		.string	"Temperature Protect Rule 40, "
 1450 077e B0E0      	.LC13:
 1451 0780 E5E2      		.string	"Temperature Protect Rule 35, "
 1452 0782 F0E0      	.LC14:
 1453 0784 8081      		.string	"Temperature Protect Rule 30, "
 1454 0786 8F7B      	.LC15:
 1455 0788 8C93      		.string	"Temperature Protect General Rule, "
 1456               	.LC16:
 311:ir_heat.c     **** 	}
 312:ir_heat.c     **** 	last = on;
 1457               	Counter: %i; \n"
 1458               		.text
 1460 078c 8093 0000 	.global	main
 313:ir_heat.c     **** }
 1462               	
 1464 0790 0F90      	.LM114:
 1465 0792 CF91      	.LFBB17:
 1466 0794 DF91      		push r29
 1467 0796 0895      		push r28
 1468               		in r28,__SP_L__
 1469               		in r29,__SP_H__
 1470               		sbiw r28,16
 1471               		in __tmp_reg__,__SREG__
 1472               		cli
 1473               		out __SP_H__,r29
 1474               		out __SREG__,__tmp_reg__
 1475 0031 0A53 7461 		out __SP_L__,r28
 1475      7274 00
 1476               	/* prologue: function */
 1477 0038 4572 726F 	/* frame size = 16 */
 1477      7220 5465 
 1477      6D70 3D30 
 1477      00
 1479 0045 5374 6172 	.LM115:
 1479      7475 7020 
 1479      2569 2000 
 1480               		ldi r30,lo8(36)
 1481 0051 5465 6D70 		ldi r31,hi8(36)
 1481      3A20 2569 
 1481      2C20 00
 1482               		ldi r24,lo8(-64)
 1483 005c 736C 6F70 		st Z,r24
 1483      655F 7261 
 1483      773A 2025 
 1483      692C 2073 
 1483      6C6F 7065 
 1485 0076 416D 6269 	.LM116:
 1485      656E 743A 
 1485      2025 690A 
 1485      00
 1486               		ldi r30,lo8(39)
 1487 0083 5465 6D70 		ldi r31,hi8(39)
 1487      6572 6174 
 1487      7572 6520 
 1487      5072 6F74 
 1487      6563 7420 
 1488               		ldi r24,lo8(8)
 1489 00a1 5465 6D70 		st Z,r24
 1489      6572 6174 
 1489      7572 6520 
 1489      5072 6F74 
 1489      6563 7420 
 1491 00bf 5465 6D70 	.LM117:
 1491      6572 6174 
 1491      7572 6520 
 1491      5072 6F74 
 1491      6563 7420 
 1492               		ldi r30,lo8(42)
 1493 00dd 5465 6D70 		ldi r31,hi8(42)
 1493      6572 6174 
 1493      7572 6520 
 1493      5072 6F74 
 1493      6563 7420 
 1494               		ldi r24,lo8(24)
 1495 00fb 5465 6D70 		st Z,r24
 1495      6572 6174 
 1495      7572 6520 
 1495      5072 6F74 
 1495      6563 7420 
 1497 0119 5465 6D70 	.LM118:
 1497      6572 6174 
 1497      7572 6520 
 1497      5072 6F74 
 1497      6563 7420 
 1498               		ldi r30,lo8(37)
 1499 013c 436F 756E 		ldi r31,hi8(37)
 1499      7465 723A 
 1499      2025 693B 
 1499      200A 00
 1500               		ldi r24,lo8(63)
 1501               		st Z,r24
 1503               	.LM119:
 1504               		ldi r30,lo8(40)
 314:ir_heat.c     **** 
 315:ir_heat.c     **** 
 316:ir_heat.c     **** 
 317:ir_heat.c     **** 
 318:ir_heat.c     **** // ***********************************************************
 319:ir_heat.c     **** // Main program
 320:ir_heat.c     **** //
 321:ir_heat.c     **** int main(void) {
 1505               	4
 1507               	.LM120:
 1508 0798 DF93      		ldi r30,lo8(43)
 1509 079a CF93      		ldi r31,hi8(43)
 1510 079c CDB7      		ldi r24,lo8(-25)
 1511 079e DEB7      		st Z,r24
 1513 07a2 0FB6      	.LM121:
 1514 07a4 F894      		ldi r30,lo8(100)
 1515 07a6 DEBF      		ldi r31,hi8(100)
 1516 07a8 0FBE      		ld r18,Z
 1518               	.LM122:
 1519               	/* #APP */
 322:ir_heat.c     ****    // Ausgnge definieren
 323:ir_heat.c     **** 	DDRB = 0x00 | (1<<RELAIS) | (1<<BUZZER);
 1520               	t.c" 1
 1521               		wdr
 1522 07ac E4E2      	 ;  0 "" 2
 1524 07b0 80EC      	.LM123:
 1525 07b2 8083      	/* #NOAPP */
 324:ir_heat.c     **** 	DDRC = 0x00 | (1<<FLASH_LED);
 1526               	24,lo8(24)
 1527               		ldi r25,hi8(24)
 1528 07b4 E7E2      		ldi r18,lo8(41)
 1529 07b6 F0E0      	/* #APP */
 1530 07b8 88E0      	 ;  337 "ir_heat.c" 1
 1531 07ba 8083      		in __tmp_reg__,__SREG__
 325:ir_heat.c     **** 	DDRD = 0x00 | (1<<STATUS_LED1) | (1<<STATUS_LED2);
 1532               	wdr
 1533               		sts 96,r24
 1534 07bc EAE2      		out __SREG__,__tmp_reg__
 1535 07be F0E0      		sts 96,r18
 1536 07c0 88E1      		
 1537 07c2 8083      	 ;  0 "" 2
 326:ir_heat.c     **** 
 327:ir_heat.c     **** 	// Ausgnge ausschalten
 328:ir_heat.c     **** 	PORTB = ~((1<<RELAIS) | (1<<BUZZER));
 1538               	n	68,0,340,.LM124-.LFBB17
 1539               	.LM124:
 1540 07c4 E5E2      	/* #NOAPP */
 1541 07c6 F0E0      		call UART_first_init
 1543 07ca 8083      	.LM125:
 329:ir_heat.c     **** 	PORTC = ~(1<<FLASH_LED);
 1544               	i2c_init
 1546 07cc E8E2      	.LM126:
 1547 07ce F0E0      		sts interval,__zero_reg__
 1549 07d2 8083      	.LM127:
 330:ir_heat.c     **** 	PORTD = ~((1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED));
 1550               	30,lo8(177)
 1551               		ldi r31,hi8(177)
 1552 07d4 EBE2      		ldi r24,lo8(7)
 1553 07d6 F0E0      		st Z,r24
 1555 07da 8083      	.LM128:
 331:ir_heat.c     **** 
 332:ir_heat.c     **** 	// TWI aus Energiesparmode rausnehmen
 333:ir_heat.c     **** 	PRR != ~(1<<PRTWI);
 1556               	30,lo8(112)
 1557               		ldi r31,hi8(112)
 1558 07dc E4E6      		ldi r24,lo8(1)
 1559 07de F0E0      		st Z,r24
 334:ir_heat.c     **** 
 335:ir_heat.c     **** 	// Whatchdog initialisieren
 336:ir_heat.c     **** 	wdt_reset();
 1561               	9:
 1562               		ldi r30,lo8(68)
 1563               		ldi r31,hi8(68)
 1564               		st Z,__zero_reg__
 1566               	.LM130:
 337:ir_heat.c     **** 	wdt_enable(WDTO_8S);
 1567               	30,lo8(69)
 1568               		ldi r31,hi8(69)
 1569               		ldi r24,lo8(3)
 1570 07e4 88E1      		st Z,r24
 1572 07e8 29E2      	.LM131:
 1573               		ldi r30,lo8(110)
 1574               		ldi r31,hi8(110)
 1575 07ea 0FB6      		ldi r24,lo8(1)
 1576 07ec F894      		st Z,r24
 1578 07f0 8093 6000 	.LM132:
 1579 07f4 0FBE      		ldi r30,lo8(105)
 1580 07f6 2093 6000 		ldi r31,hi8(105)
 1581               		ldi r24,lo8(2)
 1582               		st Z,r24
 338:ir_heat.c     **** 	
 339:ir_heat.c     **** 	// UART initialisieren
 340:ir_heat.c     **** 	UART_first_init();
 1583               	,.LM133-.LFBB17
 1584               	.LM133:
 1585               		ldi r30,lo8(61)
 1586 07fa 0E94 0000 		ldi r31,hi8(61)
 341:ir_heat.c     **** 	i2c_init();
 1587               	 r24,lo8(1)
 1588               		st Z,r24
 342:ir_heat.c     **** 	
 343:ir_heat.c     **** 	interval=0;
 1590               	134:
 1591               		ldi r24,lo8(.LC4)
 1592 0802 1092 0000 		ldi r25,hi8(.LC4)
 344:ir_heat.c     **** 	// Timer 2 initialisieren (RTC)
 345:ir_heat.c     ****    TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);	// clk/256
 1593               	ll puts
 1595 0806 E1EB      	.LM135:
 1596 0808 F0E0      		ldi r26,lo8(43)
 1597 080a 87E0      		ldi r27,hi8(43)
 1598 080c 8083      		ldi r30,lo8(43)
 346:ir_heat.c     ****    TIMSK2 = (1<<TOIE2);
 1599               	31,hi8(43)
 1600               		ld r24,Z
 1601 080e E0E7      		ori r24,lo8(16)
 1602 0810 F0E0      		st X,r24
 1604 0814 8083      	.LM136:
 347:ir_heat.c     **** 
 348:ir_heat.c     ****  	// Timer 0 initialisieren (Blinken)
 349:ir_heat.c     **** 	TCCR0A = 0;
 1605               	26,lo8(43)
 1606               		ldi r27,hi8(43)
 1607 0816 E4E4      		ldi r30,lo8(43)
 1608 0818 F0E0      		ldi r31,hi8(43)
 1609 081a 1082      		ld r24,Z
 350:ir_heat.c     **** 	TCCR0B = (0<<CS02) | (1<<CS01) | (1<<CS00);
 1610               	 r24,lo8(-9)
 1611               		st X,r24
 1613 081e F0E0      	.LM137:
 1614 0820 83E0      		ldi r24,lo8(0)
 1615 0822 8083      		call set_relais
 351:ir_heat.c     **** 	TIMSK0 = (1<<TOIE0);
 1616               	n	68,0,362,.LM138-.LFBB17
 1617               	.LM138:
 1618 0824 EEE6      		sts mode,__zero_reg__
 1620 0828 81E0      	.LM139:
 1621 082a 8083      		std Y+3,__zero_reg__
 352:ir_heat.c     **** 	
 353:ir_heat.c     **** 	// Interrupt fr Taster initialisieren
 354:ir_heat.c     **** 	EICRA = (1<<ISC01);
 1622               	n	68,0,369,.LM140-.LFBB17
 1623               	.LM140:
 1624 082c E9E6      		ldi r24,lo8(-1)
 1625 082e F0E0      		std Y+2,r24
 1627 0832 8083      	.LM141:
 355:ir_heat.c     **** 	EIMSK = (1<<INT0);
 1628               	24,lo8(3)
 1629               		std Y+1,r24
 1631 0836 F0E0      	.LM142:
 1632 0838 81E0      		std Y+9,__zero_reg__
 1633 083a 8083      		std Y+8,__zero_reg__
 356:ir_heat.c     **** 	
 357:ir_heat.c     **** 
 358:ir_heat.c     **** 	printf("\nStart\n");
 1634               	n	68,0,375,.LM143-.LFBB17
 1635               	.LM143:
 1636 083c 80E0      	/* #APP */
 1637 083e 90E0      	 ;  375 "ir_heat.c" 1
 1638 0840 0E94 0000 		sei
 359:ir_heat.c     **** 	STATUS_LED1_ON;		// grne LED ein
 1639               	 "" 2
 1640               	/* #NOAPP */
 1641 0844 ABE2      	.L88:
 1643 0848 EBE2      	.LM144:
 1644 084a F0E0      		lds r24,interval
 1645 084c 8081      		cpi r24,lo8(16)
 1646 084e 8061      		brge .+2
 1647 0850 8C93      		rjmp .L63
 360:ir_heat.c     **** 	STATUS_LED2_OFF;		// rote LED aus
 1648               	8,0,379,.LM145-.LFBB17
 1649               	.LM145:
 1650 0852 ABE2      	/* #APP */
 1651 0854 B0E0      	 ;  379 "ir_heat.c" 1
 1652 0856 EBE2      		wdr
 1653 0858 F0E0      	 ;  0 "" 2
 1655 085c 877F      	.LM146:
 1656 085e 8C93      	/* #NOAPP */
 361:ir_heat.c     **** 	set_relais(0);			// Relais aus
 1657               	rval,__zero_reg__
 1659 0860 80E0      	.LM147:
 1660 0862 0E94 0000 		std Y+3,__zero_reg__
 362:ir_heat.c     **** 	mode = MODE_OFF;
 1661               	abn	68,0,383,.LM148-.LFBB17
 1662               	.LM148:
 1663 0866 1092 0000 		ldd r24,Y+8
 363:ir_heat.c     **** 	
 364:ir_heat.c     **** 	int16_t temp, temp_sum;
 365:ir_heat.c     **** //	int16_t	lookahead;
 366:ir_heat.c     **** 	int16_t 	slope;
 367:ir_heat.c     **** 	int16_t	slope_raw;
 368:ir_heat.c     **** 	uint8_t	count=0;
 1664               	d r25,Y+9
 1665               		asr r25
 1666 086a 1B82      		ror r24
 369:ir_heat.c     **** 	uint8_t  last_interval = 0xff;
 1667               	r r25
 1668               		ror r24
 1669 086c 8FEF      		asr r25
 1670 086e 8A83      		ror r24
 370:ir_heat.c     **** 	uint8_t	startup = 3;
 1671               	 r25
 1672               		ror r24
 1673 0870 83E0      		std Y+11,r25
 1674 0872 8983      		std Y+10,r24
 371:ir_heat.c     **** 	
 372:ir_heat.c     **** 	temp_sum = 0;
 1675               	abn	68,0,384,.LM149-.LFBB17
 1676               	.LM149:
 1677 0874 1986      		std Y+9,__zero_reg__
 1678 0876 1886      		std Y+8,__zero_reg__
 373:ir_heat.c     **** 	
 374:ir_heat.c     **** 	// Interrupts aktivieren
 375:ir_heat.c     **** 	sei();
 1679               	abn	68,0,386,.LM150-.LFBB17
 1680               	.LM150:
 1681               		ldd r24,Y+10
 1682               		ldd r25,Y+11
 1683 0878 7894      		sbiw r24,0
 1684               		brne .L64
 1686               	.LM151:
 376:ir_heat.c     **** 
 377:ir_heat.c     ****    while(1) {
 378:ir_heat.c     ****    	if(!(interval < 16)) { 					// Alle 16x (alle 4 Sekunden) Temperatur checken
 1687               	
 1688               		in r30,__SP_L__
 1689 087a 8091 0000 		in r31,__SP_H__
 1690 087e 8031      		adiw r30,1
 1691 0880 04F4      		ldi r24,lo8(.LC5)
 1692 0882 00C0      		ldi r25,hi8(.LC5)
 379:ir_heat.c     ****    		wdt_reset();                  	// Whatchdog zurcksetzen
 1693               	Z+1,r25
 1694               		st Z,r24
 1695               		call printf
 1696               		pop __tmp_reg__
 1697 0884 A895      		pop __tmp_reg__
 1698               		rjmp .L65
 380:ir_heat.c     ****    		interval=0;
 1700               	.LM152:
 1701               		ldd r24,Y+1
 1702 0886 1092 0000 		tst r24
 381:ir_heat.c     ****    		count=0;
 1703               	q .L66
 1705 088a 1B82      	.LM153:
 382:ir_heat.c     **** 
 383:ir_heat.c     **** 			temp = temp_sum >> 4;				// Mittelwert der 16 Messungen ermitteln
 1706               	d r24,Y+1
 1707               		mov r18,r24
 1708 088c 8885      		ldi r19,lo8(0)
 1709 088e 9985      		rcall .
 1710 0890 9595      		rcall .
 1711 0892 8795      		in r30,__SP_L__
 1712 0894 9595      		in r31,__SP_H__
 1713 0896 8795      		adiw r30,1
 1714 0898 9595      		ldi r24,lo8(.LC6)
 1715 089a 8795      		ldi r25,hi8(.LC6)
 1716 089c 9595      		std Z+1,r25
 1717 089e 8795      		st Z,r24
 1718 08a0 9B87      		std Z+3,r19
 1719 08a2 8A87      		std Z+2,r18
 384:ir_heat.c     **** 			temp_sum = 0;
 1720               	pop __tmp_reg__
 1721               		pop __tmp_reg__
 1722 08a4 1986      		pop __tmp_reg__
 1723 08a6 1886      		pop __tmp_reg__
 385:ir_heat.c     **** 	      //printf("Temp: %i\n", temp);
 386:ir_heat.c     **** 	      if(temp==0) {
 1724               	abn	68,0,394,.LM154-.LFBB17
 1725               	.LM154:
 1726 08a8 8A85      		ldd r24,Y+1
 1727 08aa 9B85      		subi r24,lo8(-(-1))
 1728 08ac 0097      		std Y+1,r24
 387:ir_heat.c     **** 	      	// error!
 388:ir_heat.c     **** 	      	printf("Error Temp=0");
 1730               	:
 1731               		ldi r24,lo8(7)
 1732 08b0 00D0      		call get_temperature
 1733 08b2 EDB7      		std Y+11,r25
 1734 08b4 FEB7      		std Y+10,r24
 1736 08b8 80E0      	.LM156:
 1737 08ba 90E0      		std Y+7,__zero_reg__
 1738 08bc 9183      		std Y+6,__zero_reg__
 1739 08be 8083      	.L66:
 1741 08c4 0F90      	.LM157:
 1742 08c6 0F90      		rcall .
 1743 08c8 00C0      		rcall .
 1744               		in r30,__SP_L__
 389:ir_heat.c     **** 	      }
 390:ir_heat.c     **** 	      else {
 391:ir_heat.c     **** 				if (startup>0) {
 1745               	_
 1746               		adiw r30,1
 1747 08ca 8981      		ldi r24,lo8(.LC7)
 1748 08cc 8823      		ldi r25,hi8(.LC7)
 1749 08ce 01F0      		std Z+1,r25
 392:ir_heat.c     **** 					// wird nur beim ersten Durchlauf, direkt nach Startup ausgefhrt
 393:ir_heat.c     **** 					printf("Startup %i ", startup);
 1750               	,r24
 1751               		ldd r24,Y+10
 1752 08d0 8981      		ldd r25,Y+11
 1753 08d2 282F      		std Z+3,r25
 1754 08d4 30E0      		std Z+2,r24
 1755 08d6 00D0      		call printf
 1756 08d8 00D0      		pop __tmp_reg__
 1757 08da EDB7      		pop __tmp_reg__
 1758 08dc FEB7      		pop __tmp_reg__
 1759 08de 3196      		pop __tmp_reg__
 1761 08e2 90E0      	.LM158:
 1762 08e4 9183      		ldd r24,Y+10
 1763 08e6 8083      		ldd r25,Y+11
 1764 08e8 3383      		call add_value
 1766 08ec 0E94 0000 	.LM159:
 1767 08f0 0F90      		call get_slope
 1768 08f2 0F90      		std Y+5,r25
 1769 08f4 0F90      		std Y+4,r24
 394:ir_heat.c     **** 					startup--;
 1771               		ldd r25,Y+5
 1772               		tst r25
 1773 08f8 8981      		brge .L67
 1774 08fa 8150      		std Y+5,__zero_reg__
 1775 08fc 8983      		std Y+4,__zero_reg__
 395:ir_heat.c     **** 					temp = get_temperature(ADR_T_OBJ1);
 1776               	
 1778 08fe 87E0      	.LM161:
 1779 0900 0E94 0000 		ldd r18,Y+6
 1780 0904 9B87      		ldd r19,Y+7
 1781 0906 8A87      		movw r24,r18
 396:ir_heat.c     **** 					slope = 0;
 1782               	r24
 1783               		rol r25
 1784 0908 1F82      		add r24,r18
 1785 090a 1E82      		adc r25,r19
 1786               		movw r18,r24
 397:ir_heat.c     **** 				}
 398:ir_heat.c     ****    	   	printf("Temp: %i, ", temp);
 1787               	r18
 1788               		rol r19
 1789 090c 00D0      		lsl r18
 1790 090e 00D0      		rol r19
 1791 0910 EDB7      		movw r20,r24
 1792 0912 FEB7      		add r20,r18
 1793 0914 3196      		adc r21,r19
 1794 0916 80E0      		ldd r24,Y+4
 1795 0918 90E0      		ldd r25,Y+5
 1796 091a 9183      		movw r18,r24
 1797 091c 8083      		lsl r18
 1798 091e 8A85      		rol r19
 1799 0920 9B85      		movw r24,r18
 1800 0922 9383      		lsl r24
 1801 0924 8283      		rol r25
 1802 0926 0E94 0000 		lsl r24
 1803 092a 0F90      		rol r25
 1804 092c 0F90      		add r24,r18
 1805 092e 0F90      		adc r25,r19
 1806 0930 0F90      		add r24,r20
 399:ir_heat.c     ****    	   	add_value(temp);									// Neue Temperatur zu Array hinzufgen
 1807               	16,r25
 1808               		std Y+15,r24
 1809 0932 8A85      		ldd r24,Y+15
 1810 0934 9B85      		ldd r25,Y+16
 1811 0936 0E94 0000 		tst r25
 400:ir_heat.c     ****    	   	//print_array();
 401:ir_heat.c     ****    	   	slope_raw = get_slope();						// Aktuelle Steigung ermitteln
 1812               	 .L68
 1813               		ldd r18,Y+15
 1814 093a 0E94 0000 		ldd r19,Y+16
 1815 093e 9D83      		subi r18,lo8(-(15))
 1816 0940 8C83      		sbci r19,hi8(-(15))
 402:ir_heat.c     **** 				if(slope_raw<0) slope_raw = 0;
 1817               	Y+16,r19
 1818               		std Y+15,r18
 1819 0942 8C81      	.L68:
 1820 0944 9D81      		ldd r24,Y+15
 1821 0946 9923      		ldd r25,Y+16
 1822 0948 04F4      		asr r25
 1823 094a 1D82      		ror r24
 1824 094c 1C82      		asr r25
 1825               		ror r24
 403:ir_heat.c     ****    	   	slope = (15*slope + 10*slope_raw)/16;		// Steigung wird mit einer Dmpfung von 16 gedmpft
 1826               		ror r24
 1827               		asr r25
 1828 094e 2E81      		ror r24
 1829 0950 3F81      		std Y+7,r25
 1830 0952 C901      		std Y+6,r24
 1832 0956 991F      	.LM162:
 1833 0958 820F      		rcall .
 1834 095a 931F      		rcall .
 1835 095c 9C01      		rcall .
 1836 095e 220F      		in r30,__SP_L__
 1837 0960 331F      		in r31,__SP_H__
 1838 0962 220F      		adiw r30,1
 1839 0964 331F      		ldi r24,lo8(.LC8)
 1840 0966 AC01      		ldi r25,hi8(.LC8)
 1841 0968 420F      		std Z+1,r25
 1842 096a 531F      		st Z,r24
 1843 096c 8C81      		ldd r24,Y+4
 1844 096e 9D81      		ldd r25,Y+5
 1845 0970 9C01      		std Z+3,r25
 1846 0972 220F      		std Z+2,r24
 1847 0974 331F      		ldd r24,Y+6
 1848 0976 C901      		ldd r25,Y+7
 1849 0978 880F      		std Z+5,r25
 1850 097a 991F      		std Z+4,r24
 1851 097c 880F      		call printf
 1852 097e 991F      		in r24,__SP_L__
 1853 0980 820F      		in r25,__SP_H__
 1854 0982 931F      		adiw r24,6
 1855 0984 840F      		in __tmp_reg__,__SREG__
 1856 0986 951F      		cli
 1857 0988 988B      		out __SP_H__,r25
 1858 098a 8F87      		out __SREG__,__tmp_reg__
 1859 098c 8F85      		out __SP_L__,r24
 1861 0990 9923      	.LM163:
 1862 0992 04F4      		ldi r24,lo8(6)
 1863 0994 2F85      		call get_temperature
 1864 0996 3889      		movw r18,r24
 1865 0998 215F      		rcall .
 1866 099a 3F4F      		rcall .
 1867 099c 388B      		in r30,__SP_L__
 1868 099e 2F87      		in r31,__SP_H__
 1869               		adiw r30,1
 1870 09a0 8F85      		ldi r24,lo8(.LC9)
 1871 09a2 9889      		ldi r25,hi8(.LC9)
 1872 09a4 9595      		std Z+1,r25
 1873 09a6 8795      		st Z,r24
 1874 09a8 9595      		std Z+3,r19
 1875 09aa 8795      		std Z+2,r18
 1876 09ac 9595      		call printf
 1877 09ae 8795      		pop __tmp_reg__
 1878 09b0 9595      		pop __tmp_reg__
 1879 09b2 8795      		pop __tmp_reg__
 1880 09b4 9F83      		pop __tmp_reg__
 404:ir_heat.c     ****    	   	printf("slope_raw: %i, slope: %i ", slope_raw, slope);
 1882               	pi r24,lo8(481)
 1883               		cpc r25,r18
 1884 09b8 00D0      		brlt .L69
 1886 09bc 00D0      	.LM165:
 1887 09be EDB7      		ldd r24,Y+6
 1888 09c0 FEB7      		ldd r25,Y+7
 1889 09c2 3196      		cpi r24,31
 1890 09c4 80E0      		cpc r25,__zero_reg__
 1891 09c6 90E0      		brge .+2
 1892 09c8 9183      		rjmp .L65
 1894 09cc 8C81      	.LM166:
 1895 09ce 9D81      		ldi r24,lo8(6)
 1896 09d0 9383      		sts off_counter,r24
 1898 09d4 8E81      	.LM167:
 1899 09d6 9F81      		rcall .
 1900 09d8 9583      		in r30,__SP_L__
 1901 09da 8483      		in r31,__SP_H__
 1902 09dc 0E94 0000 		adiw r30,1
 1903 09e0 8DB7      		ldi r24,lo8(.LC10)
 1904 09e2 9EB7      		ldi r25,hi8(.LC10)
 1905 09e4 0696      		std Z+1,r25
 1906 09e6 0FB6      		st Z,r24
 1907 09e8 F894      		call printf
 1908 09ea 9EBF      		pop __tmp_reg__
 1909 09ec 0FBE      		pop __tmp_reg__
 1910 09ee 8DBF      		rjmp .L65
 405:ir_heat.c     **** 				//lookahead=lookahead_temp(slope, 5);   	   	
 406:ir_heat.c     ****    	   	//printf("Prognose: %i\n", lookahead);
 407:ir_heat.c     ****    	   	printf("Ambient: %i\n", get_temperature(ADR_T_A));
 1911               	-.LFBB17
 1912               	.LM168:
 1913 09f0 86E0      		ldd r24,Y+10
 1914 09f2 0E94 0000 		ldd r25,Y+11
 1915 09f6 9C01      		ldi r19,hi8(451)
 1916 09f8 00D0      		cpi r24,lo8(451)
 1917 09fa 00D0      		cpc r25,r19
 1918 09fc EDB7      		brlt .L71
 1920 0a00 3196      	.LM169:
 1921 0a02 80E0      		ldd r24,Y+6
 1922 0a04 90E0      		ldd r25,Y+7
 1923 0a06 9183      		cpi r24,51
 1924 0a08 8083      		cpc r25,__zero_reg__
 1925 0a0a 3383      		brge .+2
 1926 0a0c 2283      		rjmp .L65
 1928 0a12 0F90      	.LM170:
 1929 0a14 0F90      		ldi r24,lo8(6)
 1930 0a16 0F90      		sts off_counter,r24
 408:ir_heat.c     **** 				
 409:ir_heat.c     **** 				// Je nach aktueller Temperatur und Steigung in Temperaturschutz gehen 	   	
 410:ir_heat.c     **** 	   		if(temp > 480) {
 1932               	r30,__SP_L__
 1933               		in r31,__SP_H__
 1934 0a1a 8A85      		adiw r30,1
 1935 0a1c 9B85      		ldi r24,lo8(.LC11)
 1936 0a1e 21E0      		ldi r25,hi8(.LC11)
 1937 0a20 813E      		std Z+1,r25
 1938 0a22 9207      		st Z,r24
 1939 0a24 04F0      		call printf
 411:ir_heat.c     **** 	   			// Temperatur > 48C
 412:ir_heat.c     **** 	   			if(slope > 30) {
 1940               	mp_reg__
 1941               		pop __tmp_reg__
 1942 0a26 8E81      		rjmp .L65
 1943 0a28 9F81      	.L71:
 1945 0a2c 9105      	.LM172:
 1946 0a2e 04F4      		ldd r24,Y+10
 1947 0a30 00C0      		ldd r25,Y+11
 413:ir_heat.c     **** 	   				off_counter = OFF_COUNTER+1;
 1948               	,hi8(401)
 1949               		cpi r24,lo8(401)
 1950 0a32 86E0      		cpc r25,r18
 1951 0a34 8093 0000 		brlt .L73
 414:ir_heat.c     **** 	   				printf("Temperature Protect Rule 48, ");
 1952               	abn	68,0,426,.LM173-.LFBB17
 1953               	.LM173:
 1954 0a38 00D0      		ldd r24,Y+6
 1955 0a3a EDB7      		ldd r25,Y+7
 1956 0a3c FEB7      		cpi r24,61
 1957 0a3e 3196      		cpc r25,__zero_reg__
 1958 0a40 80E0      		brge .+2
 1959 0a42 90E0      		rjmp .L65
 1961 0a46 8083      	.LM174:
 1962 0a48 0E94 0000 		ldi r24,lo8(6)
 1963 0a4c 0F90      		sts off_counter,r24
 1965 0a50 00C0      	.LM175:
 1966               		rcall .
 415:ir_heat.c     **** 	   			}
 416:ir_heat.c     **** 	   		}
 417:ir_heat.c     **** 	   		else if(temp > 450) {
 1967               	_
 1968               		in r31,__SP_H__
 1969 0a52 8A85      		adiw r30,1
 1970 0a54 9B85      		ldi r24,lo8(.LC12)
 1971 0a56 31E0      		ldi r25,hi8(.LC12)
 1972 0a58 833C      		std Z+1,r25
 1973 0a5a 9307      		st Z,r24
 1974 0a5c 04F0      		call printf
 418:ir_heat.c     **** 	   			// Temperatur > 45C
 419:ir_heat.c     **** 	   			if(slope > 50) {
 1975               	mp_reg__
 1976               		pop __tmp_reg__
 1977 0a5e 8E81      		rjmp .L65
 1978 0a60 9F81      	.L73:
 1980 0a64 9105      	.LM176:
 1981 0a66 04F4      		ldd r24,Y+10
 1982 0a68 00C0      		ldd r25,Y+11
 420:ir_heat.c     **** 	   				off_counter = OFF_COUNTER+1;
 1983               	,hi8(351)
 1984               		cpi r24,lo8(351)
 1985 0a6a 86E0      		cpc r25,r19
 1986 0a6c 8093 0000 		brlt .L75
 421:ir_heat.c     **** 	   				printf("Temperature Protect Rule 45, ");
 1987               	abn	68,0,433,.LM177-.LFBB17
 1988               	.LM177:
 1989 0a70 00D0      		ldd r24,Y+6
 1990 0a72 EDB7      		ldd r25,Y+7
 1991 0a74 FEB7      		cpi r24,81
 1992 0a76 3196      		cpc r25,__zero_reg__
 1993 0a78 80E0      		brge .+2
 1994 0a7a 90E0      		rjmp .L65
 1996 0a7e 8083      	.LM178:
 1997 0a80 0E94 0000 		ldi r24,lo8(6)
 1998 0a84 0F90      		sts off_counter,r24
 2000 0a88 00C0      	.LM179:
 2001               		rcall .
 422:ir_heat.c     **** 	   			}
 423:ir_heat.c     **** 	   		}
 424:ir_heat.c     **** 	   		else if(temp > 400) {
 2002               	_
 2003               		in r31,__SP_H__
 2004 0a8a 8A85      		adiw r30,1
 2005 0a8c 9B85      		ldi r24,lo8(.LC13)
 2006 0a8e 21E0      		ldi r25,hi8(.LC13)
 2007 0a90 8139      		std Z+1,r25
 2008 0a92 9207      		st Z,r24
 2009 0a94 04F0      		call printf
 425:ir_heat.c     **** 	   			// Temperatur > 40C
 426:ir_heat.c     **** 	   			if(slope > 60) {
 2010               	mp_reg__
 2011               		pop __tmp_reg__
 2012 0a96 8E81      		rjmp .L65
 2013 0a98 9F81      	.L75:
 2015 0a9c 9105      	.LM180:
 2016 0a9e 04F4      		ldd r24,Y+10
 2017 0aa0 00C0      		ldd r25,Y+11
 427:ir_heat.c     **** 	   				off_counter = OFF_COUNTER+1;
 2018               	,hi8(301)
 2019               		cpi r24,lo8(301)
 2020 0aa2 86E0      		cpc r25,r18
 2021 0aa4 8093 0000 		brlt .L77
 428:ir_heat.c     **** 	   				printf("Temperature Protect Rule 40, ");
 2022               	abn	68,0,440,.LM181-.LFBB17
 2023               	.LM181:
 2024 0aa8 00D0      		ldd r24,Y+6
 2025 0aaa EDB7      		ldd r25,Y+7
 2026 0aac FEB7      		cpi r24,121
 2027 0aae 3196      		cpc r25,__zero_reg__
 2028 0ab0 80E0      		brlt .L65
 2030 0ab4 9183      	.LM182:
 2031 0ab6 8083      		ldi r24,lo8(6)
 2032 0ab8 0E94 0000 		sts off_counter,r24
 2034 0abe 0F90      	.LM183:
 2035 0ac0 00C0      		rcall .
 2036               		in r30,__SP_L__
 429:ir_heat.c     **** 	   			}
 430:ir_heat.c     **** 	   		}
 431:ir_heat.c     **** 	   		else if(temp > 350) {
 2037               	_
 2038               		adiw r30,1
 2039 0ac2 8A85      		ldi r24,lo8(.LC14)
 2040 0ac4 9B85      		ldi r25,hi8(.LC14)
 2041 0ac6 31E0      		std Z+1,r25
 2042 0ac8 8F35      		st Z,r24
 2043 0aca 9307      		call printf
 2044 0acc 04F0      		pop __tmp_reg__
 432:ir_heat.c     **** 	   			// Temperatur > 35C
 433:ir_heat.c     **** 	   			if(slope > 80) {
 2045               	mp_reg__
 2046               		rjmp .L65
 2047 0ace 8E81      	.L77:
 2049 0ad2 8135      	.LM184:
 2050 0ad4 9105      		ldd r24,Y+6
 2051 0ad6 04F4      		ldd r25,Y+7
 2052 0ad8 00C0      		cpi r24,161
 434:ir_heat.c     **** 	   				off_counter = OFF_COUNTER+1;
 2053               	,__zero_reg__
 2054               		brlt .L65
 2056 0adc 8093 0000 	.LM185:
 435:ir_heat.c     **** 	   				printf("Temperature Protect Rule 35, ");
 2057               	 r24,lo8(6)
 2058               		sts off_counter,r24
 2060 0ae2 EDB7      	.LM186:
 2061 0ae4 FEB7      		rcall .
 2062 0ae6 3196      		in r30,__SP_L__
 2063 0ae8 80E0      		in r31,__SP_H__
 2064 0aea 90E0      		adiw r30,1
 2065 0aec 9183      		ldi r24,lo8(.LC15)
 2066 0aee 8083      		ldi r25,hi8(.LC15)
 2067 0af0 0E94 0000 		std Z+1,r25
 2068 0af4 0F90      		st Z,r24
 2069 0af6 0F90      		call printf
 2070 0af8 00C0      		pop __tmp_reg__
 2071               		pop __tmp_reg__
 436:ir_heat.c     ****                }
 437:ir_heat.c     **** 	   		}
 438:ir_heat.c     **** 	   		else if(temp > 300) {
 2072               	8,0,454,.LM187-.LFBB17
 2073               	.LM187:
 2074 0afa 8A85      		lds r24,off_counter
 2075 0afc 9B85      		tst r24
 2076 0afe 21E0      		breq .L79
 2078 0b02 9207      	.LM188:
 2079 0b04 04F0      		lds r24,off_counter
 439:ir_heat.c     **** 	   			// Temperatur > 30C
 440:ir_heat.c     **** 	   			if(slope > 120) {
 2080               	4,lo8(-(-1))
 2081               		sts off_counter,r24
 2083 0b08 9F81      	.LM189:
 2084 0b0a 8937      		lds r24,mode
 2085 0b0c 9105      		cpi r24,lo8(1)
 2086 0b0e 04F0      		brne .L80
 441:ir_heat.c     **** 	   				off_counter = OFF_COUNTER+1;
 2087               	_counter
 2088               		tst r24
 2089 0b10 86E0      		breq .L79
 442:ir_heat.c     **** 		   			printf("Temperature Protect Rule 30, ");
 2091               	88:
 2092               		lds r24,off_counter
 2093 0b16 00D0      		subi r24,lo8(-(-1))
 2094 0b18 EDB7      		sts off_counter,r24
 2096 0b1c 3196      	.LM189:
 2097 0b1e 80E0      		lds r24,mode
 2098 0b20 90E0      		cpi r24,lo8(1)
 2099 0b22 9183      		brne .L80
 2100 0b24 8083      		ldi r24,lo8(3)
 2101 0b26 0E94 0000 		sts mode,r24
 2102 0b2a 0F90      	.L80:
 2104 0b2e 00C0      	.LM190:
 2105               		lds r24,off_counter
 443:ir_heat.c     **** 		   		}
 444:ir_heat.c     **** 	   		}
 445:ir_heat.c     **** 	   		else {
 446:ir_heat.c     **** 	   			// Ansonsten
 447:ir_heat.c     **** 	   			if(slope > 160) {
 2106               	(-(-1))
 2107               		sts off_counter,r24
 2109 0b32 9F81      	.LM189:
 2110 0b34 813A      		lds r24,mode
 2111 0b36 9105      		cpi r24,lo8(1)
 2112 0b38 04F0      		brne .L80
 448:ir_heat.c     **** 	   				off_counter = OFF_COUNTER+1;
 2113               	_counter
 2114               		tst r24
 2115 0b3a 86E0      		breq .L79
 449:ir_heat.c     **** 	   				printf("Temperature Protect General Rule, ");
 2117               	88:
 2118               		lds r24,off_counter
 2119 0b40 00D0      		subi r24,lo8(-(-1))
 2120 0b42 EDB7      		sts off_counter,r24
 2122 0b46 3196      	.LM189:
 2123 0b48 80E0      		lds r24,mode
 2124 0b4a 90E0      		cpi r24,lo8(1)
 2125 0b4c 9183      		brne .L80
 2126 0b4e 8083      		ldi r24,lo8(3)
 2127 0b50 0E94 0000 		sts mode,r24
 2128 0b54 0F90      	.L80:
 2130               	.LM190:
 450:ir_heat.c     **** 	   			}
 451:ir_heat.c     **** 	   		}
 452:ir_heat.c     **** 
 453:ir_heat.c     ****    	   }
 454:ir_heat.c     ****    		if(off_counter) {
 2131               	_counter
 2132               		subi r24,lo8(-(-1))
 2133 0b58 8091 0000 		sts off_counter,r24
 2135 0b5e 01F0      	.LM189:
 455:ir_heat.c     ****    			// Protection Counter luft
 456:ir_heat.c     ****   				off_counter--;
 2136               	68,0,454,.LM187-.LFBB17
 2137               	.LM187:
 2138 0b60 8091 0000 		lds r24,off_counter
 2139 0b64 8150      		tst r24
 2140 0b66 8093 0000 		breq .L79
 457:ir_heat.c     ****   				if(mode == MODE_ON) mode = MODE_TEMP_PROT;
 2141               	bn	68,0,456,.LM188-.LFBB17
 2142               	.LM188:
 2143 0b6a 8091 0000 		lds r24,off_counter
 2144 0b6e 8130      		subi r24,lo8(-(-1))
 2145 0b70 01F4      		sts off_counter,r24
 2147 0b74 8093 0000 	.LM189:
 2148               		lds r24,mode
 458:ir_heat.c     **** 				printf("Counter: %i; \n", off_counter);
 2149               	-.LFBB17
 2150               	.LM187:
 2151 0b78 8091 0000 		lds r24,off_counter
 2152 0b7c 282F      		tst r24
 2153 0b7e 30E0      		breq .L79
 2155 0b82 00D0      	.LM188:
 2156 0b84 EDB7      		lds r24,off_counter
 2157 0b86 FEB7      		subi r24,lo8(-(-1))
 2158 0b88 3196      		sts off_counter,r24
 2160 0b8c 90E0      	.LM189:
 2161 0b8e 9183      		lds r24,mode
 2162 0b90 8083      		cpi r24,lo8(1)
 2163 0b92 3383      		brne .L80
 2164 0b94 2283      		ldi r24,lo8(3)
 2165 0b96 0E94 0000 		sts mode,r24
 2166 0b9a 0F90      	.L80:
 2168 0b9e 0F90      	.LM190:
 2169 0ba0 0F90      		lds r24,off_counter
 2170 0ba2 00C0      		mov r18,r24
 2171               		ldi r19,lo8(0)
 459:ir_heat.c     ****    		}
 460:ir_heat.c     ****    		else {
 461:ir_heat.c     ****    			if(mode == MODE_TEMP_PROT) mode = MODE_OFF;
 2172               	30,__SP_L__
 2173               		in r31,__SP_H__
 2174 0ba4 8091 0000 		adiw r30,1
 2175 0ba8 8330      		ldi r24,lo8(.LC16)
 2176 0baa 01F4      		ldi r25,hi8(.LC16)
 2177 0bac 1092 0000 		std Z+1,r25
 2178 0bb0 00C0      		st Z,r24
 2179               		std Z+3,r19
 462:ir_heat.c     ****    		}
 463:ir_heat.c     **** 		}
 464:ir_heat.c     **** 		else if(interval != last_interval) {
 2180               	190:
 2181               		lds r24,off_counter
 2182 0bb2 8091 0000 		mov r18,r24
 2183 0bb6 282F      		ldi r19,lo8(0)
 2184 0bb8 3327      		rcall .
 2185 0bba 27FD      		rcall .
 2186 0bbc 3095      		in r30,__SP_L__
 2187 0bbe 8A81      		in r31,__SP_H__
 2188 0bc0 882F      		adiw r30,1
 2189 0bc2 90E0      		ldi r24,lo8(.LC16)
 2190 0bc4 2817      		ldi r25,hi8(.LC16)
 2191 0bc6 3907      		std Z+1,r25
 2192 0bc8 01F0      		st Z,r24
 465:ir_heat.c     **** 			// In jedem Interval 1x die Temperatur abrufen
 466:ir_heat.c     **** 			// und fr den Mittelwert aufsummieren
 467:ir_heat.c     ****    		last_interval = interval;
 2193               	90-.LFBB17
 2194               	.LM190:
 2195 0bca 8091 0000 		lds r24,off_counter
 2196 0bce 8A83      		mov r18,r24
 468:ir_heat.c     ****    		//uint16_t temp;
 469:ir_heat.c     ****    		if(count<16) {
 2197               	ff_counter,r24
 2199 0bd0 8B81      	.LM189:
 2200 0bd2 8031      		lds r24,mode
 2201 0bd4 00F4      		cpi r24,lo8(1)
 470:ir_heat.c     ****    			//temp = get_temperature(ADR_T_OBJ1);
 471:ir_heat.c     **** 	   		count++;
 2202               		lds r24,off_counter
 2203               		tst r24
 2204 0bd6 8B81      		breq .L79
 2206 0bda 8B83      	.LM188:
 472:ir_heat.c     ****    			// Messwerte fr den Mittelwert aufsummieren
 473:ir_heat.c     ****    			temp_sum += get_temperature(ADR_T_OBJ1);
 2207               	r24,off_counter
 2208               		subi r24,lo8(-(-1))
 2209 0bdc 87E0      		sts off_counter,r24
 2211 0be2 9C01      	.LM189:
 2212 0be4 8885      		lds r24,mode
 2213 0be6 9985      		cpi r24,lo8(1)
 2214 0be8 820F      		brne .L80
 2215 0bea 931F      		ldi r24,lo8(3)
 2216 0bec 9987      		sts mode,r24
 2217 0bee 8887      	.L80:
 474:ir_heat.c     ****    			//printf("Raw: %i\n", temp);
 475:ir_heat.c     ****    		}
 476:ir_heat.c     ****    	}
 477:ir_heat.c     **** 
 478:ir_heat.c     **** 		// Je nach Mode Relais und LEDs setzen
 479:ir_heat.c     **** 		switch(mode) {
 2219               	s r24,off_counter
 2220               		subi r24,lo8(-(-1))
 2221 0bf0 8091 0000 		sts off_counter,r24
 2223 0bf6 30E0      	.LM189:
 2224 0bf8 3D87      		lds r24,mode
 2225 0bfa 2C87      		cpi r24,lo8(1)
 2226 0bfc 8C85      		brne .L80
 2227 0bfe 9D85      		ldi r24,lo8(3)
 2228 0c00 8130      		sts mode,r24
 2229 0c02 9105      	.L80:
 2231 0c06 2C85      	.LM190:
 2232 0c08 3D85      		lds r24,off_counter
 2233 0c0a 2330      		mov r18,r24
 2234 0c0c 3105      		ldi r19,lo8(0)
 2235 0c0e 01F0      		rcall .
 2236 0c10 8C85      		rcall .
 2237 0c12 9D85      		in r30,__SP_L__
 2238 0c14 0097      		in r31,__SP_H__
 2239 0c16 01F4      		adiw r30,1
 2240               		ldi r24,lo8(.LC16)
 480:ir_heat.c     **** 		case MODE_OFF:
 481:ir_heat.c     **** 			set_relais(0);
 2241               	8(3)
 2242               		sts mode,r24
 2243 0c18 80E0      	.L80:
 482:ir_heat.c     **** 			STATUS_LED1_ON;      // Grn
 2245               	s r24,off_counter
 2246               		subi r24,lo8(-(-1))
 2247 0c1e ABE2      		sts off_counter,r24
 2249 0c22 EBE2      	.LM189:
 2250 0c24 F0E0      		lds r24,mode
 2251 0c26 8081      		cpi r24,lo8(1)
 2252 0c28 8061      		brne .L80
 2253 0c2a 8C93      		ldi r24,lo8(3)
 483:ir_heat.c     **** 			STATUS_LED2_OFF;
 2254               	
 2255               		breq .L79
 2257 0c2e B0E0      	.LM188:
 2258 0c30 EBE2      		lds r24,off_counter
 2259 0c32 F0E0      		subi r24,lo8(-(-1))
 2260 0c34 8081      		sts off_counter,r24
 2262 0c38 8C93      	.LM189:
 2263 0c3a 00C0      		lds r24,mode
 2264               		cpi r24,lo8(1)
 484:ir_heat.c     **** 			break;
 485:ir_heat.c     **** 		case MODE_ON:
 486:ir_heat.c     **** 			set_relais(1);
 2265               		lds r24,off_counter
 2266               		tst r24
 2267 0c3c 81E0      		breq .L79
 487:ir_heat.c     **** 			STATUS_LED1_ON;     // Orange
 2269               	88:
 2270               		lds r24,off_counter
 2271 0c42 ABE2      		subi r24,lo8(-(-1))
 2272 0c44 B0E0      		sts off_counter,r24
 2274 0c48 F0E0      	.LM189:
 2275 0c4a 8081      		lds r24,mode
 2276 0c4c 8061      		cpi r24,lo8(1)
 2277 0c4e 8C93      		brne .L80
 488:ir_heat.c     **** 			STATUS_LED2_ON;
 2278               	_counter
 2279               		tst r24
 2280 0c50 ABE2      		breq .L79
 2282 0c54 EBE2      	.LM188:
 2283 0c56 F0E0      		lds r24,off_counter
 2284 0c58 8081      		subi r24,lo8(-(-1))
 2285 0c5a 8860      		sts off_counter,r24
 2287 0c5e 00C0      	.LM189:
 2288               		lds r24,mode
 489:ir_heat.c     **** 			break;
 490:ir_heat.c     **** 		case MODE_TEMP_PROT:
 491:ir_heat.c     **** 			set_relais(0);
 2289               	8(1)
 2290               		brne .L80
 2291 0c60 80E0      		ldi r24,lo8(3)
 2292 0c62 0E94 0000 		sts mode,r24
 492:ir_heat.c     **** 			STATUS_LED1_OFF;
 2293               	tabn	68,0,456,.LM188-.LFBB17
 2294               	.LM188:
 2295 0c66 ABE2      		lds r24,off_counter
 2296 0c68 B0E0      		subi r24,lo8(-(-1))
 2297 0c6a EBE2      		sts off_counter,r24
 2299 0c6e 8081      	.LM189:
 2300 0c70 8F7E      		lds r24,mode
 2301 0c72 8C93      		cpi r24,lo8(1)
 493:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2302               		lds r24,off_counter
 2303               		tst r24
 2304 0c74 ABE2      		breq .L79
 2306 0c78 EBE2      	.LM188:
 2307 0c7a F0E0      		lds r24,off_counter
 2308 0c7c 8081      		subi r24,lo8(-(-1))
 2309 0c7e 8860      		sts off_counter,r24
 2311 0c82 00C0      	.LM189:
 2312               		lds r24,mode
 494:ir_heat.c     **** 			break;
 495:ir_heat.c     **** 		default:
 496:ir_heat.c     **** 			mode = MODE_OFF;
 2313               	8(1)
 2314               		brne .L80
 2315 0c84 1092 0000 		ldi r24,lo8(3)
 2316 0c88 00C0      		sts mode,r24
 2317               	.L80:
 2319               	.LM190:
 2320               		lds r24,off_counter
 2321               		mov r18,r24
 2322               		ldi r19,lo8(0)
 2323               		rcall .
 2324               		rcall .
 2325               		in r30,__SP_L__
 2326               		in r31,__SP_H__
 2327               		adiw r30,1
 2328               		ldi r24,lo8(.LC16)
 2329               		ldi r25,hi8(.LC16)
 2330               		std Z+1,r25
 2331               		st Z,r24
 2332               		std Z+3,r19
 2333               		std Z+2,r18
 2334               		call printf
 2335               		pop __tmp_reg__
 2336               		pop __tmp_reg__
 2337               		pop __tmp_reg__
 2338               		pop __tmp_reg__
 2339               		rjmp .L82
 2340               	.L79:
 2342               	.LM191:
 2343               		lds r24,mode
 2344               		cpi r24,lo8(3)
 2345               		brne .L82
 2346               		sts mode,__zero_reg__
 2347               		rjmp .L82
 2348               	.L63:
 2350               	.LM192:
 2351               		lds r24,interval
 2352               		mov r18,r24
 2353               		clr r19
 2354               		sbrc r18,7
 2355               		com r19
 2356               		ldd r24,Y+2
 2357               		mov r24,r24
 2358               		ldi r25,lo8(0)
DEFINED SYMBOLS
                            *ABS*:00000000 ir_heat.c
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:2      *ABS*:0000003f __SREG__
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:3      *ABS*:0000003e __SP_H__
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:4      *ABS*:0000003d __SP_L__
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:5      *ABS*:00000034 __CCP__
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:90     .data:00000000 interval
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:97     .bss:00000000 off_counter
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:103    .data:00000001 t_la_threshold_up
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:108    .data:00000003 t_abs_threshold_up
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:113    .data:00000005 t_la_threshold_down
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:118    .data:00000007 t_abs_threshold_down
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:124    .text:00000000 __vector_9
                             .bss:00000001 c.1686
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:162    .text:0000002e __vector_16
                            *COM*:00000001 mode
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:158    .bss:00000002 running.1718
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:293    .text:000000f6 __vector_1
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:447    .text:000001c4 __vector_18
                            *COM*:00000001 r_in
                            *COM*:00000020 rbuf
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:513    .text:00000220 __vector_19
                            *COM*:00000001 t_in
                            *COM*:00000001 t_out
                            *COM*:00000020 tbuf
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:592    .text:00000298 tbuflen
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:622    .text:000002b4 UART_putchar
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:694    .text:0000031a rbuflen
                            *COM*:00000001 r_out
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:723    .text:00000336 UART_getchar
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:782    .text:00000380 UART_first_init
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:844    .text:000003ba print_array
                            *COM*:0000000c t_array
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:931    .text:00000432 add_value
                            *COM*:00000002 slope2
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:1087   .text:0000056a get_slope
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:1202   .text:00000630 lookahead_temp
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:1269   .text:00000692 get_temperature
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:289    .bss:00000003 last.1940
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:1399   .text:00000736 set_relais
C:\Users\Thorsten\AppData\Local\Temp/ccJ2YD7r.s:1504   .text:00000798 main

UNDEFINED SYMBOLS
fdevopen
printf
putchar
__divmodhi4
i2c_start
i2c_write
i2c_rep_start
i2c_read_ack
i2c_stop
__udivmodhi4
puts
i2c_init
__do_copy_data
__do_clear_bss
