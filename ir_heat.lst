   1               		.file	"ir_heat.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  87               	.global	__vector_9
  89               	__vector_9:
   1:ir_heat.c     **** // ***********************************************************
   2:ir_heat.c     **** // Project:
   3:ir_heat.c     **** // Author:
   4:ir_heat.c     **** // Module description:
   5:ir_heat.c     **** // ***********************************************************
   6:ir_heat.c     **** 
   7:ir_heat.c     **** #ifndef F_CPU
   8:ir_heat.c     **** #define F_CPU 1000000UL
   9:ir_heat.c     **** #endif
  10:ir_heat.c     **** 
  11:ir_heat.c     **** #include <avr\io.h>              // Most basic include files
  12:ir_heat.c     **** #include <avr\interrupt.h>       // Add the necessary ones
  13:ir_heat.c     **** //#include <avr\signal.h>          // here
  14:ir_heat.c     **** #include <avr\wdt.h>
  15:ir_heat.c     **** 
  16:ir_heat.c     **** #include <stdio.h>
  17:ir_heat.c     **** #include <string.h>
  18:ir_heat.c     **** #include <stdlib.h>
  19:ir_heat.c     **** #include	<util/delay.h>
  20:ir_heat.c     **** 
  21:ir_heat.c     **** #include "i2c_mstr.h"
  22:ir_heat.c     **** #include "ir_heat.h"
  23:ir_heat.c     **** 
  24:ir_heat.c     **** #define 	MLX90614_WRITE	(0x5A<<1)
  25:ir_heat.c     **** #define 	MLX90614_READ	(MLX90614_WRITE+1)
  26:ir_heat.c     **** #define	ADR_T_A			0x06
  27:ir_heat.c     **** #define	ADR_T_OBJ1		0x07
  28:ir_heat.c     **** #define	ADR_T_OBJ2		0x08
  29:ir_heat.c     **** #define	DEFAULT_TEMP	150
  30:ir_heat.c     **** 
  31:ir_heat.c     **** 
  32:ir_heat.c     **** #define __STDIO_FDEVOPEN_COMPAT_12						
  33:ir_heat.c     **** // Buffer sizes must be 2^n
  34:ir_heat.c     **** //
  35:ir_heat.c     **** #define TBUFSIZE			32
  36:ir_heat.c     **** #define RBUFSIZE			32
  37:ir_heat.c     **** 
  38:ir_heat.c     **** #define TMASK				(TBUFSIZE-1)
  39:ir_heat.c     **** #define RMASK				(RBUFSIZE-1)
  40:ir_heat.c     **** 
  41:ir_heat.c     **** #define FLASH_LED			PC3
  42:ir_heat.c     **** #define STATUS_LED1		PD4
  43:ir_heat.c     **** #define STATUS_LED2		PD3
  44:ir_heat.c     **** #define RELAIS				PB6
  45:ir_heat.c     **** #define BUZZER				PB7
  46:ir_heat.c     **** #define SWITCH				PD2
  47:ir_heat.c     **** 
  48:ir_heat.c     **** #define RELAIS_ON			PORTB |= (1<<RELAIS)
  49:ir_heat.c     **** #define RELAIS_OFF		PORTB &=~(1<<RELAIS)
  50:ir_heat.c     **** 
  51:ir_heat.c     **** #define BUZZER_ON			PORTB |= (1<<BUZZER)
  52:ir_heat.c     **** #define BUZZER_OFF		PORTB &=~(1<<BUZZER)
  53:ir_heat.c     **** 
  54:ir_heat.c     **** #define STATUS_LED1_ON	PORTD |= (1<<STATUS_LED1)
  55:ir_heat.c     **** #define STATUS_LED1_OFF	PORTD &=~(1<<STATUS_LED1)
  56:ir_heat.c     **** 
  57:ir_heat.c     **** #define FLASH_LED_ON		PORTC |= (1<<FLASH_LED)
  58:ir_heat.c     **** #define FLASH_LED_OFF	PORTC &=~(1<<FLASH_LED)
  59:ir_heat.c     **** 
  60:ir_heat.c     **** #define STATUS_LED2_ON	PORTD |= (1<<STATUS_LED2)
  61:ir_heat.c     **** #define STATUS_LED2_OFF	PORTD &=~(1<<STATUS_LED2)
  62:ir_heat.c     **** 
  63:ir_heat.c     **** #define OFF_COUNTER		2
  64:ir_heat.c     **** 
  65:ir_heat.c     **** #define TIMER1_STOP		TCCR1B = 0
  66:ir_heat.c     **** #define TIMER1_RUN		TCCR1B = (0<<CS12) | (1<<CS11) | (0<<CS10)
  67:ir_heat.c     **** 
  68:ir_heat.c     **** #define	MODE_OFF				0
  69:ir_heat.c     **** #define	MODE_ON				1
  70:ir_heat.c     **** #define	MODE_ON_NO_PROT	2
  71:ir_heat.c     **** #define	MODE_TEMP_PROT		3
  72:ir_heat.c     **** 
  73:ir_heat.c     **** #define	BEEP_SHORT			1
  74:ir_heat.c     **** #define	BEEP_2SHORT			2
  75:ir_heat.c     **** #define	BEEP_LONG			3
  76:ir_heat.c     **** #define	BEEP_XLONG			4
  77:ir_heat.c     **** #define	BEEP_2LONG			5
  78:ir_heat.c     **** #define	BEEP_SHORT_LONG	6
  79:ir_heat.c     **** 
  80:ir_heat.c     **** // Define here the global static variables
  81:ir_heat.c     **** //
  82:ir_heat.c     **** volatile unsigned char tbuf[TBUFSIZE];  // TX buffer
  83:ir_heat.c     **** volatile unsigned char rbuf[RBUFSIZE];  // RX buffer
  84:ir_heat.c     **** 
  85:ir_heat.c     **** volatile unsigned char t_in;            // TX buffer in index
  86:ir_heat.c     **** volatile unsigned char t_out;           // TX buffer out index
  87:ir_heat.c     **** 
  88:ir_heat.c     **** volatile unsigned char r_in;            // RX buffer in index
  89:ir_heat.c     **** volatile unsigned char r_out;           // RX buffer out index
  90:ir_heat.c     **** 
  91:ir_heat.c     **** int8_t	interval = -12;
  92:ir_heat.c     **** int16_t 	t_array[6];
  93:ir_heat.c     **** uint8_t	off_counter = 0;
  94:ir_heat.c     **** uint8_t	mode;
  95:ir_heat.c     **** int16_t	slope2;
  96:ir_heat.c     **** uint8_t	flash_button = 0;
  97:ir_heat.c     **** uint8_t	flash_LED = 0;
  98:ir_heat.c     **** 
  99:ir_heat.c     **** /*
 100:ir_heat.c     **** uint16_t	t_la_threshold_up 	=  300;
 101:ir_heat.c     **** uint16_t	t_abs_threshold_up 	=  270;
 102:ir_heat.c     **** uint16_t	t_la_threshold_down 	=  250;
 103:ir_heat.c     **** uint16_t	t_abs_threshold_down	=  250;
 104:ir_heat.c     **** */
 105:ir_heat.c     **** 
 106:ir_heat.c     **** 
 107:ir_heat.c     **** // Clock Timer
 108:ir_heat.c     **** SIGNAL(SIG_OVERFLOW2) {
  90               	ush r0
  91               		clr __zero_reg__
  92               		push r24
  93 0000 1F92      	/* prologue: Signal */
  94 0002 0F92      	/* frame size = 0 */
  96 0006 0F92      	.LM1:
  97 0008 1124      		lds r24,interval
  98 000a 8F93      		subi r24,lo8(-(1))
  99               		sts interval,r24
 100               	/* epilogue start */
 109:ir_heat.c     **** 	interval++;
 101               	0,110,.LM2-.LFBB1
 102               	.LM2:
 103 000c 8091 0000 		pop r24
 104 0010 8F5F      		pop r0
 105 0012 8093 0000 		out __SREG__,r0
 106               		pop r0
 110:ir_heat.c     **** }
 107               	_zero_reg__
 108               		reti
 110 0018 0F90      	.Lscope1:
 112 001c 0F90      	.global	__vector_13
 114 0020 1895      	__vector_13:
 116               	.LM3:
 117               	.LFBB2:
 118               		push __zero_reg__
 119               		push r0
 120               		in r0,__SREG__
 111:ir_heat.c     **** 
 112:ir_heat.c     **** SIGNAL(SIG_OVERFLOW1) {
 121               	__zero_reg__
 122               	/* prologue: Signal */
 123               	/* frame size = 0 */
 125 0024 0F92      	.LM4:
 126 0026 0FB6      		sts 129,__zero_reg__
 128 002a 1124      	.LM5:
 129               		sts 133,__zero_reg__
 113:ir_heat.c     **** 	TIMER1_STOP;
 131               	 132,__zero_reg__
 132               	/* epilogue start */
 114:ir_heat.c     **** 	TCNT1H = 0;
 134               	7:
 135               		pop r0
 136 0030 1092 8500 		out __SREG__,r0
 115:ir_heat.c     **** 	TCNT1L = 0;
 137               	p r0
 138               		pop __zero_reg__
 139 0034 1092 8400 		reti
 116:ir_heat.c     **** }
 141               	ope2:
 143 0038 0F90      	.global	__vector_16
 145 003c 0F90      	__vector_16:
 147 0040 1895      	.LM8:
 148               	.LFBB3:
 149               		push __zero_reg__
 150               		push r0
 151               		in r0,__SREG__
 152               		push r0
 153               		clr __zero_reg__
 117:ir_heat.c     **** 
 118:ir_heat.c     **** 
 119:ir_heat.c     **** // LED Flasher
 120:ir_heat.c     **** SIGNAL(SIG_OVERFLOW0) {
 154               	sh r19
 155               		push r20
 156               		push r24
 157 0042 1F92      		push r25
 158 0044 0F92      		push r30
 159 0046 0FB6      		push r31
 160 0048 0F92      	/* prologue: Signal */
 161 004a 1124      	/* frame size = 0 */
 163 004e 3F93      	.LM9:
 164 0050 4F93      		lds r24,c1.1730
 165 0052 8F93      		mov r18,r24
 166 0054 9F93      		subi r18,lo8(-(1))
 167 0056 EF93      		sts c1.1730,r18
 169               	.LM10:
 170               		lds r24,c2.1731
 121:ir_heat.c     **** 	static uint8_t	c1 = 0;
 122:ir_heat.c     **** 	static uint8_t c2 = 0;
 123:ir_heat.c     **** 	uint8_t slow=0;
 124:ir_heat.c     **** 	c1++;
 171               	i r19,lo8(-(1))
 172               		sts c2.1731,r19
 174 005e 282F      	.LM11:
 175 0060 2F5F      		lds r20,mode
 176 0062 2093 0000 		cpi r20,lo8(3)
 125:ir_heat.c     **** 	c2++;
 177               	.L6
 179 0066 8091 0000 	.LM12:
 180 006a 382F      		mov r24,r18
 181 006c 3F5F      		ldi r25,lo8(0)
 182 006e 3093 0000 		sbiw r24,7
 126:ir_heat.c     **** 	
 127:ir_heat.c     **** 	// Tasten LED
 128:ir_heat.c     **** 	if (mode==MODE_TEMP_PROT) {
 183               	.L6
 185 0072 4091 0000 	.LM13:
 186 0076 4330      		ldi r30,lo8(40)
 187 0078 01F4      		ldi r31,hi8(40)
 129:ir_heat.c     **** 		if(c1 > (6<<slow)) {
 188               	24,Z
 189               		ori r24,lo8(8)
 190 007a 822F      		st Z,r24
 191 007c 90E0      	.L6:
 193 0080 04F0      	.LM14:
 130:ir_heat.c     **** 			FLASH_LED_ON;
 194               	24,r18
 195               		ldi r25,lo8(0)
 196 0082 E8E2      		sbiw r24,11
 197 0084 F0E0      		brlt .L7
 199 0088 8860      	.LM15:
 200 008a 8083      		sts c1.1730,__zero_reg__
 131:ir_heat.c     **** 		}
 132:ir_heat.c     **** 	}
 133:ir_heat.c     **** 	if(c1 > (10<<slow)) {
 202               	ldi r30,lo8(40)
 203               		ldi r31,hi8(40)
 204 008c 822F      		ld r24,Z
 205 008e 90E0      		andi r24,lo8(-9)
 206 0090 0B97      		st Z,r24
 207 0092 04F0      	.L7:
 134:ir_heat.c     **** 		c1 = 0;
 208               	n	68,0,139,.LM17-.LFBB3
 209               	.LM17:
 210 0094 1092 0000 		cpi r20,lo8(2)
 135:ir_heat.c     **** 		FLASH_LED_OFF;
 211               	ne .L8
 213 0098 E8E2      	.LM18:
 214 009a F0E0      		cpi r19,lo8(121)
 215 009c 8081      		brlo .L8
 217 00a0 8083      	.LM19:
 218               		ldi r30,lo8(43)
 136:ir_heat.c     **** 	}
 137:ir_heat.c     **** 	
 138:ir_heat.c     **** 	// Status LED
 139:ir_heat.c     **** 	if (mode==MODE_ON_NO_PROT) {
 219               	,hi8(43)
 220               		ld r24,Z
 221 00a2 4230      		andi r24,lo8(-17)
 222 00a4 01F4      		st Z,r24
 140:ir_heat.c     **** 		if(c2 > 120) {
 223               	
 225 00a6 3937      	.LM20:
 226 00a8 00F0      		cpi r19,lo8(-120)
 141:ir_heat.c     **** 			STATUS_LED1_OFF;	// rot
 227               	lo .L10
 229 00aa EBE2      	.LM21:
 230 00ac F0E0      		sts c2.1731,__zero_reg__
 232 00b0 8F7E      	.LM22:
 233 00b2 8083      		ldi r30,lo8(43)
 234               		ldi r31,hi8(43)
 142:ir_heat.c     **** 		}
 143:ir_heat.c     **** 	}
 144:ir_heat.c     **** 	if(c2 > 135) {
 235               	Z
 236               		ori r24,lo8(16)
 237 00b4 3838      		st Z,r24
 238 00b6 00F0      	.L10:
 145:ir_heat.c     **** 		c2 = 0;
 239               	pilogue start */
 241 00b8 1092 0000 	.LM23:
 146:ir_heat.c     **** 		STATUS_LED1_ON; 		// orange
 242               	p r31
 243               		pop r30
 244 00bc EBE2      		pop r25
 245 00be F0E0      		pop r24
 246 00c0 8081      		pop r20
 247 00c2 8061      		pop r19
 248 00c4 8083      		pop r18
 249               		pop r0
 250               		out __SREG__,r0
 147:ir_heat.c     **** 	}	
 148:ir_heat.c     **** }
 251               	pop __zero_reg__
 252               		reti
 258 00d0 3F91      	.Lscope3:
 260 00d4 0F90      	.global	__vector_18
 262 00d8 0F90      	__vector_18:
 264 00dc 1895      	.LM24:
 265               	.LFBB4:
 266               		push __zero_reg__
 267               		push r0
 268               		in r0,__SREG__
 269               		push r0
 270               		clr __zero_reg__
 271               		push r24
 272               		push r30
 273               		push r31
 274               	/* prologue: Signal */
 149:ir_heat.c     **** 
 150:ir_heat.c     **** 
 151:ir_heat.c     **** 
 152:ir_heat.c     **** //*******************************************
 153:ir_heat.c     **** //
 154:ir_heat.c     **** // Taster IQR und Entprellung
 155:ir_heat.c     **** //
 156:ir_heat.c     **** SIGNAL(SIG_INTERRUPT0) {
 157:ir_heat.c     **** 	static uint8_t running = 0;
 158:ir_heat.c     **** 	
 159:ir_heat.c     **** 	if(running | TCNT1H | TCNT1L){
 160:ir_heat.c     **** //		printf("X");
 161:ir_heat.c     **** 		return;
 162:ir_heat.c     **** 	}
 163:ir_heat.c     **** 	running = 1;
 164:ir_heat.c     **** 	wdt_reset();
 165:ir_heat.c     **** 	
 166:ir_heat.c     **** 	uint16_t i;
 167:ir_heat.c     **** 	uint16_t c = 0;
 168:ir_heat.c     **** 	EIMSK = 0;
 169:ir_heat.c     **** 	sei();
 170:ir_heat.c     **** 	//printf("In");
 171:ir_heat.c     **** 	for(i=0;i<1000;i++) if((PIND & (1<<SWITCH))) c++;
 172:ir_heat.c     **** 	//printf(" %i ", c);
 173:ir_heat.c     **** 
 174:ir_heat.c     **** 	if(c < 200) {
 175:ir_heat.c     **** 		TCNT1L = 1;
 176:ir_heat.c     **** 		TIMER1_RUN;
 177:ir_heat.c     **** 		switch(mode) {
 178:ir_heat.c     **** 		case MODE_OFF:
 179:ir_heat.c     **** 			mode = MODE_ON;
 180:ir_heat.c     **** 			set_relais(1);
 181:ir_heat.c     **** 			STATUS_LED1_ON;			// orange
 182:ir_heat.c     **** 			STATUS_LED2_ON;
 183:ir_heat.c     **** 			c = 0;
 184:ir_heat.c     **** 			while((!(PIND & (1<<SWITCH))) && (c < 300)) {
 185:ir_heat.c     **** 				c++;
 186:ir_heat.c     **** 				_delay_ms (10);
 187:ir_heat.c     **** 			}
 188:ir_heat.c     **** 			//printf("c: %i", c);
 189:ir_heat.c     **** 
 190:ir_heat.c     **** 			if(c < 300) {
 191:ir_heat.c     **** 				// normal einnschalten
 192:ir_heat.c     **** 				mode = MODE_ON;
 193:ir_heat.c     **** 			}
 194:ir_heat.c     **** 			else {
 195:ir_heat.c     **** 				// einschalten, aber ohne Hitzeschutz
 196:ir_heat.c     **** 				mode = MODE_ON_NO_PROT;
 197:ir_heat.c     **** 				printf("Temperature Protection Off!\n");
 198:ir_heat.c     **** 				STATUS_LED1_OFF;		// rot
 199:ir_heat.c     **** 				STATUS_LED2_ON;
 200:ir_heat.c     **** 				beep(BEEP_SHORT_LONG);
 201:ir_heat.c     **** 			}
 202:ir_heat.c     **** 			break;
 203:ir_heat.c     **** 		case MODE_ON:
 204:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 205:ir_heat.c     **** 		case MODE_TEMP_PROT:
 206:ir_heat.c     **** 		default:
 207:ir_heat.c     **** 			printf("\nxXx\n");
 208:ir_heat.c     **** 			mode = MODE_OFF;
 209:ir_heat.c     **** 		}
 210:ir_heat.c     **** 	}
 211:ir_heat.c     **** //	printf("Out\n");
 212:ir_heat.c     **** 	EIFR 		= (1<<INTF0);
 213:ir_heat.c     **** 	EIMSK 	= (1<<INT0);
 214:ir_heat.c     **** 	running 	= 0;
 215:ir_heat.c     **** 	//printf("Exit\n");
 216:ir_heat.c     **** }
 217:ir_heat.c     **** 
 218:ir_heat.c     **** 
 219:ir_heat.c     **** 
 220:ir_heat.c     **** SIGNAL(SIG_USART_RECV) {
 275               	tabn	68,0,225,.LM25-.LFBB4
 276               	.LM25:
 277               		lds r24,198
 279 00e0 0F92      	.LM26:
 280 00e2 0FB6      		lds r30,r_in
 281 00e4 0F92      		ldi r31,lo8(0)
 282 00e6 1124      		andi r30,lo8(31)
 283 00e8 8F93      		andi r31,hi8(31)
 284 00ea EF93      		subi r30,lo8(-(rbuf))
 285 00ec FF93      		sbci r31,hi8(-(rbuf))
 286               		st Z,r24
 221:ir_heat.c     **** //******************
 222:ir_heat.c     **** // RX interrupt handler
 223:ir_heat.c     **** //
 224:ir_heat.c     **** 	char c;	
 225:ir_heat.c     **** 	c = UDR0;							// Get received char
 288               	24,r_in
 289               		subi r24,lo8(-(1))
 290 00ee 8091 C600 		sts r_in,r24
 226:ir_heat.c     **** 	rbuf[r_in & RMASK] = c;
 291               	epilogue start */
 293 00f2 E091 0000 	.LM28:
 294 00f6 F0E0      		pop r31
 295 00f8 EF71      		pop r30
 296 00fa F070      		pop r24
 297 00fc E050      		pop r0
 298 00fe F040      		out __SREG__,r0
 299 0100 8083      		pop r0
 227:ir_heat.c     **** 	r_in++;
 300               	ro_reg__
 301               		reti
 228:ir_heat.c     **** }
 306               	e4:
 308 010c FF91      	.global	__vector_19
 310 0110 8F91      	__vector_19:
 312 0114 0FBE      	.LM29:
 313 0116 0F90      	.LFBB5:
 314 0118 1F90      		push __zero_reg__
 315 011a 1895      		push r0
 316               		in r0,__SREG__
 317               		push r0
 318               		clr __zero_reg__
 319               		push r24
 320               		push r25
 321               		push r30
 322               		push r31
 323               	/* prologue: Signal */
 324               	/* frame size = 0 */
 229:ir_heat.c     **** 
 230:ir_heat.c     **** SIGNAL(SIG_USART_DATA) {
 325               	M30-.LFBB5
 326               	.LM30:
 327               		lds r25,t_in
 328 011c 1F92      		lds r24,t_out
 329 011e 0F92      		cp r25,r24
 330 0120 0FB6      		breq .L14
 332 0124 1124      	.LM31:
 333 0126 8F93      		lds r30,t_out
 334 0128 9F93      		ldi r31,lo8(0)
 335 012a EF93      		andi r30,lo8(31)
 336 012c FF93      		andi r31,hi8(31)
 337               		subi r30,lo8(-(tbuf))
 338               		sbci r31,hi8(-(tbuf))
 231:ir_heat.c     **** //*******************
 232:ir_heat.c     **** // Data register empty interrupt handler.
 233:ir_heat.c     **** // Indicates that next char can be transmitted
 234:ir_heat.c     **** //
 235:ir_heat.c     **** 	if(t_in != t_out) {
 339               	 198,r24
 341 012e 9091 0000 	.LM32:
 342 0132 8091 0000 		lds r24,t_out
 343 0136 9817      		subi r24,lo8(-(1))
 344 0138 01F0      		sts t_out,r24
 236:ir_heat.c     **** 		UDR0 = tbuf[t_out & TMASK];
 345               	.L16
 346               	.L14:
 348 013e F0E0      	.LM33:
 349 0140 EF71      		ldi r30,lo8(193)
 350 0142 F070      		ldi r31,hi8(193)
 351 0144 E050      		ld r24,Z
 352 0146 F040      		andi r24,lo8(-33)
 353 0148 8081      		st Z,r24
 354 014a 8093 C600 	.L16:
 237:ir_heat.c     **** 		t_out++;	
 355               	e start */
 357 014e 8091 0000 	.LM34:
 358 0152 8F5F      		pop r31
 359 0154 8093 0000 		pop r30
 360 0158 00C0      		pop r25
 361               		pop r24
 238:ir_heat.c     **** 	}
 239:ir_heat.c     **** 	else {
 240:ir_heat.c     **** 		UCSR0B &= ~(1<<UDRIE0);
 362               	
 363               		out __SREG__,r0
 364 015a E1EC      		pop r0
 365 015c F0E0      		pop __zero_reg__
 366 015e 8081      		reti
 368 0162 8083      	.Lscope5:
 370               	.global	tbuflen
 241:ir_heat.c     **** 	}
 242:ir_heat.c     **** }
 371               	buflen, @function
 372               	tbuflen:
 374 0166 EF91      	.LM35:
 375 0168 9F91      	.LFBB6:
 376 016a 8F91      	/* prologue: function */
 377 016c 0F90      	/* frame size = 0 */
 379 0170 0F90      	.LM36:
 380 0172 1F90      		lds r24,t_in
 381 0174 1895      		lds r25,t_out
 383               	.LM37:
 384               		sub r24,r25
 385               	/* epilogue start */
 386               		ret
 243:ir_heat.c     **** 
 244:ir_heat.c     **** char tbuflen(void) {
 388               		"UART_putchar:F(0,1)",36,0,0,UART_putchar
 391               	.global	UART_putchar
 245:ir_heat.c     **** //****************
 246:ir_heat.c     **** // Retrieve pending chars in TX buffer
 247:ir_heat.c     **** //
 248:ir_heat.c     **** 	return(t_in - t_out);
 393               	putchar:
 395 0176 8091 0000 	.LM38:
 396 017a 9091 0000 	.LFBB7:
 249:ir_heat.c     **** }
 397               	h r17
 398               		push r28
 399 017e 891B      		push r29
 400               	/* prologue: function */
 401 0180 0895      	/* frame size = 0 */
 402               		mov r17,r24
 404               	.LM39:
 405               		ldi r28,lo8(32)
 406               		ldi r29,hi8(32)
 407               	.L20:
 408               		call tbuflen
 409               		movw r18,r28
 250:ir_heat.c     **** 
 251:ir_heat.c     **** int UART_putchar(char c, FILE *stream) {
 410               		sbc r19,__zero_reg__
 411               		cpi r18,3
 412               		cpc r19,__zero_reg__
 413 0182 1F93      		brlt .L20
 415 0186 DF93      	.LM40:
 416               		lds r30,t_in
 417               		ldi r31,lo8(0)
 418 0188 182F      		andi r30,lo8(31)
 252:ir_heat.c     **** //*********************
 253:ir_heat.c     **** // Fills the transmit buffer, if it is full wait
 254:ir_heat.c     **** //
 255:ir_heat.c     **** 	while((TBUFSIZE - tbuflen()) <= 2);  // Wait...
 419               	,hi8(31)
 420               		subi r30,lo8(-(tbuf))
 421 018a C0E2      		sbci r31,hi8(-(tbuf))
 422 018c D0E0      		st Z,r17
 424 018e 0E94 0000 	.LM41:
 425 0192 9E01      		lds r24,t_in
 426 0194 281B      		subi r24,lo8(-(1))
 427 0196 3109      		sts t_in,r24
 429 019a 3105      	.LM42:
 430 019c 04F0      		ldi r30,lo8(193)
 256:ir_heat.c     **** 	
 257:ir_heat.c     **** 	// Add data to the transmit buffer, enable TXCIE
 258:ir_heat.c     **** 	//
 259:ir_heat.c     **** 	tbuf[t_in & TMASK] = c;
 431               	(193)
 432               		ld r24,Z
 433 019e E091 0000 		ori r24,lo8(32)
 434 01a2 F0E0      		st Z,r24
 436 01a6 F070      	.LM43:
 437 01a8 E050      		ldi r24,lo8(0)
 438 01aa F040      		ldi r25,hi8(0)
 439 01ac 1083      	/* epilogue start */
 260:ir_heat.c     **** 	t_in++;	
 440               		pop r28
 441               		pop r17
 442 01ae 8091 0000 		ret
 444 01b4 8093 0000 	.Lscope7:
 261:ir_heat.c     **** 	UCSR0B |= (1<<UDRIE0);			// Enable UDR empty interrupt	
 445               	bs	"rbuflen:F(0,2)",36,0,0,rbuflen
 446               	.global	rbuflen
 448 01ba F0E0      	rbuflen:
 450 01be 8062      	.LM44:
 451 01c0 8083      	.LFBB8:
 262:ir_heat.c     **** 	return(0);
 263:ir_heat.c     **** }
 452               	ogue: function */
 453               	/* frame size = 0 */
 455 01c4 90E0      	.LM45:
 456               		lds r24,r_in
 457 01c6 DF91      		lds r25,r_out
 459 01ca 1F91      	.LM46:
 460 01cc 0895      		sub r24,r25
 461               	/* epilogue start */
 462               		ret
 464               	.Lscope8:
 264:ir_heat.c     **** 
 265:ir_heat.c     **** char rbuflen(void) {
 467               	tchar
 469               	UART_getchar:
 471               	.LM47:
 266:ir_heat.c     **** // ***************
 267:ir_heat.c     **** // Retrive pending chars in RX buffer
 268:ir_heat.c     **** //
 269:ir_heat.c     **** 	return(r_in - r_out);
 472               	9:
 473               	/* prologue: function */
 474 01ce 8091 0000 	/* frame size = 0 */
 475 01d2 9091 0000 	.L26:
 270:ir_heat.c     **** }
 476               	abn	68,0,278,.LM48-.LFBB9
 477               	.LM48:
 478 01d6 891B      		call rbuflen
 479               		tst r24
 480 01d8 0895      		breq .L26
 482               	.LM49:
 483               		lds r30,r_out
 484               		ldi r31,lo8(0)
 485               		andi r30,lo8(31)
 486               		andi r31,hi8(31)
 487               		subi r30,lo8(-(rbuf))
 271:ir_heat.c     **** 
 272:ir_heat.c     **** int UART_getchar(FILE *stream) {
 488               	8(-(rbuf))
 489               		ld r24,Z
 491               	.LM50:
 492               		lds r25,r_out
 493               		subi r25,lo8(-(1))
 273:ir_heat.c     **** //*******************
 274:ir_heat.c     **** // Retieves character from UART. This function is to be passed
 275:ir_heat.c     **** // to fdevopen
 276:ir_heat.c     **** //
 277:ir_heat.c     **** 	unsigned char c;
 278:ir_heat.c     **** 	while(rbuflen() == 0);	  // Wait...
 494               	_out,r25
 496 01da 0E94 0000 	.LM51:
 497 01de 8823      		ldi r25,lo8(0)
 498 01e0 01F0      	/* epilogue start */
 279:ir_heat.c     **** 	c = rbuf[r_out & RMASK];
 503 01e8 EF71      	.Lscope9:
 506 01ee F040      	.global	exp_slope
 280:ir_heat.c     **** 	r_out++;	
 508               	:
 510 01f2 9091 0000 	.LM52:
 511 01f6 9F5F      	.LFBB10:
 512 01f8 9093 0000 	/* prologue: function */
 281:ir_heat.c     **** 	return(c);
 282:ir_heat.c     **** }
 513               	ame size = 0 */
 515 01fc 90E0      	.LM53:
 516               		clr r18
 517 01fe 0895      		clr r19
 518               		sub r18,r24
 519               		sbc r19,r25
 520               		brpl .L30
 521               		subi r18,lo8(-(15))
 522               		sbci r19,hi8(-(15))
 523               	.L30:
 524               		movw r24,r18
 525               		asr r25
 526               		ror r24
 527               		asr r25
 283:ir_heat.c     **** 
 284:ir_heat.c     **** void UART_first_init(void) {
 285:ir_heat.c     **** //***********************
 286:ir_heat.c     **** // The function fdevopen(..) must contain as parameters the
 287:ir_heat.c     **** // corresponding  ..putchar() and  ..getchar() functions, defined before.
 288:ir_heat.c     **** //
 289:ir_heat.c     **** 	UBRR0 = 12;										 		// 4800 BPS
 290:ir_heat.c     **** 	
 291:ir_heat.c     **** 	UCSR0B = (1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0);	// 8 Databits, receive and transmit enabled, receive a
 292:ir_heat.c     **** 	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
 293:ir_heat.c     **** 	
 294:ir_heat.c     **** 	fdevopen(UART_putchar, UART_getchar);
 295:ir_heat.c     **** 	sei();											 		// Global interrupt enable
 296:ir_heat.c     **** }
 297:ir_heat.c     **** 
 298:ir_heat.c     **** 
 299:ir_heat.c     **** 
 300:ir_heat.c     **** 
 301:ir_heat.c     **** int16_t exp_slope(int16_t temp) {
 528               	25
 529               		ror r24
 530               		asr r25
 531               		ror r24
 532               		movw r18,r24
 533               		lsl r18
 534               		rol r19
 535 0200 2227      		lsl r24
 536 0202 3327      		rol r25
 537 0204 281B      		lsl r24
 538 0206 390B      		rol r25
 539 0208 02F4      		lsl r24
 540 020a 215F      		rol r25
 541 020c 3F4F      		add r18,r24
 542               		adc r19,r25
 543 020e C901      		subi r18,lo8(-(320))
 544 0210 9595      		sbci r19,hi8(-(320))
 546 0214 9595      	.LM54:
 547 0216 8795      		mov r24,r18
 548 0218 9595      		mov r25,r19
 549 021a 8795      	/* epilogue start */
 550 021c 9595      		ret
 552 0220 9C01      	.Lscope10:
 554 0224 331F      	.global	get_slope2
 556 0228 991F      	get_slope2:
 558 022c 991F      	.LM55:
 559 022e 880F      	.LFBB11:
 560 0230 991F      	/* prologue: function */
 561 0232 280F      	/* frame size = 0 */
 563 0236 205C      	.LM56:
 564 0238 3E4F      		lds r24,t_array+10
 302:ir_heat.c     **** 	return 10 * (-temp/16 + 32);
 303:ir_heat.c     **** }
 565               	ray+4
 566               		lds r19,(t_array+4)+1
 567 023a 822F      		sub r24,r18
 568 023c 932F      		sbc r25,r19
 569               		lsl r24
 570 023e 0895      		rol r25
 571               		lsl r24
 572               		rol r25
 573               		lsl r24
 574               		rol r25
 575               		lds r18,last_slope.1889
 576               		lds r19,(last_slope.1889)+1
 304:ir_heat.c     **** 
 305:ir_heat.c     **** 
 306:ir_heat.c     **** int16_t get_slope2() {
 577               	
 578               		adc r25,r19
 579               		lsl r24
 580               		rol r25
 581               		ldi r22,lo8(3)
 307:ir_heat.c     **** 	static int16_t last_slope = 0;
 308:ir_heat.c     **** //	last_slope = (200*(t_array[5]-t_array[2]) / 16 +  2*last_slope) / 3;
 309:ir_heat.c     **** 	last_slope = (16*(t_array[5]-t_array[2]) +  2*last_slope) / 3;
 582               	 r23,hi8(3)
 583               		call __divmodhi4
 584 0240 8091 0000 		mov r24,r22
 585 0244 9091 0000 		mov r25,r23
 586 0248 2091 0000 		sts last_slope.1889,r22
 587 024c 3091 0000 		sts last_slope.1889+1,r23
 588 0250 821B      	/* epilogue start */
 590 0254 880F      	.LM57:
 591 0256 991F      		ret
 596 0260 2091 0000 	.Lscope11:
 598 0268 820F      	.global	add_value
 600 026c 880F      	add_value:
 602 0270 63E0      	.LM58:
 603 0272 70E0      	.LFBB12:
 604 0274 0E94 0000 	/* prologue: function */
 605 0278 862F      	/* frame size = 0 */
 606 027a 972F      		mov r20,r24
 607 027c 6093 0000 		mov r21,r25
 609               	.LM59:
 310:ir_heat.c     **** 	return last_slope;
 311:ir_heat.c     **** }
 610               	_array)+1
 611               		or r24,r25
 612 0284 0895      		brne .L35
 614               	.LM60:
 615               		ldi r30,lo8(t_array+10)
 616               		ldi r31,hi8(t_array+10)
 617               		st Z,r20
 618               		std Z+1,r21
 619               		movw r26,r30
 620               		sbiw r26,2
 621               		st X,r20
 312:ir_heat.c     **** 
 313:ir_heat.c     **** 
 314:ir_heat.c     **** 
 315:ir_heat.c     **** 
 316:ir_heat.c     **** //*********************************************
 317:ir_heat.c     **** //
 318:ir_heat.c     **** // Gibt den Temperatur Ringspeicher
 319:ir_heat.c     **** // über den UART aus
 320:ir_heat.c     **** //
 321:ir_heat.c     **** void print_array(){
 322:ir_heat.c     **** 	uint8_t i;
 323:ir_heat.c     ****   	printf("Array:");
 324:ir_heat.c     **** 	for(i=0;i<6;i++) {
 325:ir_heat.c     ****    	printf(" %i", t_array[i]);
 326:ir_heat.c     **** 	}
 327:ir_heat.c     ****   	printf("\n");
 328:ir_heat.c     **** }
 329:ir_heat.c     **** 
 330:ir_heat.c     **** 
 331:ir_heat.c     **** 
 332:ir_heat.c     **** //*********************************************
 333:ir_heat.c     **** //
 334:ir_heat.c     **** // Fügt einen Meßwert zum Ringspeicher hinzu
 335:ir_heat.c     **** // Der Ringspeicher enthält die letzten 6 Werte
 336:ir_heat.c     **** // t_array[5] ist der neuste Wert
 337:ir_heat.c     **** //
 338:ir_heat.c     **** void add_value(uint16_t value) {
 622               		st X,r21
 623               		movw r26,r30
 624               		sbiw r26,4
 625               		st X,r20
 626               		adiw r26,1
 627 0286 482F      		st X,r21
 628 0288 592F      		movw r26,r30
 339:ir_heat.c     **** 	uint8_t i;
 340:ir_heat.c     **** 	if(t_array[0]==0) {
 629               	26,6
 630               		st X,r20
 631 028a 8091 0000 		adiw r26,1
 632 028e 9091 0000 		st X,r21
 633 0292 892B      		movw r26,r30
 634 0294 01F4      		sbiw r26,8
 341:ir_heat.c     **** 		t_array[0]=t_array[1]=t_array[2]=t_array[3]=t_array[4]=t_array[5]=value;
 635               	r20
 636               		adiw r26,1
 637 0296 E0E0      		st X,r21
 638 0298 F0E0      		sbiw r30,10
 639 029a 4083      		st Z,r20
 640 029c 5183      		std Z+1,r21
 641 029e DF01      		ret
 642 02a0 1297      	.L35:
 643 02a2 4C93      		ldi r30,lo8(t_array)
 644 02a4 1196      		ldi r31,hi8(t_array)
 646 02a8 DF01      	.LM61:
 647 02aa 1497      		ldi r18,lo8(t_array+10)
 648 02ac 4C93      		ldi r19,hi8(t_array+10)
 649 02ae 1196      	.L37:
 651 02b2 DF01      	.LM62:
 652 02b4 1697      		ldd r24,Z+2
 653 02b6 4C93      		ldd r25,Z+3
 654 02b8 1196      		st Z+,r24
 655 02ba 5C93      		st Z+,r25
 657 02be 1897      	.LM63:
 658 02c0 4C93      		cp r30,r18
 659 02c2 1196      		cpc r31,r19
 660 02c4 5C93      		brne .L37
 662 02c8 4083      	.LM64:
 663 02ca 5183      		mov r18,r20
 664 02cc 0895      		mov r19,r21
 665               		sts (t_array+10)+1,r19
 666 02ce E0E0      		sts t_array+10,r18
 342:ir_heat.c     **** 	}
 343:ir_heat.c     **** 	else {
 344:ir_heat.c     **** 		for(i=0;i<5;i++) {
 668               	5,(t_array+8)+1
 669               		sub r18,r24
 670 02d2 20E0      		sbc r19,r25
 671 02d4 30E0      		movw r24,r18
 672               		lsl r24
 345:ir_heat.c     **** 			t_array[i]=t_array[i+1];
 673               	r25
 674               		lsl r18
 675 02d6 8281      		rol r19
 676 02d8 9381      		lsl r18
 677 02da 8193      		rol r19
 678 02dc 9193      		lsl r18
 679               		rol r19
 680               		add r24,r18
 681 02de E217      		adc r25,r19
 682 02e0 F307      		lds r22,slope2
 683 02e2 01F4      		lds r23,(slope2)+1
 346:ir_heat.c     **** 		}
 347:ir_heat.c     **** 		t_array[5] = value;
 684               	22
 685               		lsl r18
 686 02e4 242F      		rol r19
 687 02e6 352F      		movw r20,r18
 688 02e8 3093 0000 		lsl r20
 689 02ec 2093 0000 		rol r21
 348:ir_heat.c     **** 		slope2 = (10*(t_array[5]-t_array[4]) + 19*slope2) / 20;
 690               	20
 691               		rol r21
 692 02f0 8091 0000 		lsl r20
 693 02f4 9091 0000 		rol r21
 694 02f8 281B      		add r18,r20
 695 02fa 390B      		adc r19,r21
 696 02fc C901      		add r18,r22
 697 02fe 880F      		adc r19,r23
 698 0300 991F      		add r24,r18
 699 0302 220F      		adc r25,r19
 700 0304 331F      		ldi r22,lo8(20)
 701 0306 220F      		ldi r23,hi8(20)
 702 0308 331F      		call __divmodhi4
 703 030a 220F      		sts (slope2)+1,r23
 704 030c 331F      		sts slope2,r22
 705 030e 820F      		ret
 707 0312 6091 0000 	.Lscope12:
 709 031a 9B01      	.global	get_slope
 711 031e 331F      	get_slope:
 713 0322 440F      	.LM66:
 714 0324 551F      	.LFBB13:
 715 0326 440F      	/* prologue: function */
 716 0328 551F      	/* frame size = 0 */
 718 032c 551F      	.LM67:
 719 032e 240F      		ldi r26,lo8(t_array+8)
 720 0330 351F      		ldi r27,hi8(t_array+8)
 721 0332 260F      		movw r30,r26
 722 0334 371F      		ld r18,Z+
 723 0336 820F      		ld r19,Z+
 724 0338 931F      		lds r24,t_array+2
 725 033a 64E1      		lds r25,(t_array+2)+1
 726 033c 70E0      		sub r18,r24
 727 033e 0E94 0000 		sbc r19,r25
 728 0342 7093 0000 		movw r24,r18
 729 0346 6093 0000 		lsl r24
 730 034a 0895      		rol r25
 731               		lsl r24
 732               		rol r25
 733               		add r24,r18
 734               		adc r25,r19
 735               		sbiw r26,8
 736               		ld r20,Z
 349:ir_heat.c     **** 	}
 350:ir_heat.c     **** }
 351:ir_heat.c     **** 
 352:ir_heat.c     **** 
 353:ir_heat.c     **** 
 354:ir_heat.c     **** //********************************************
 355:ir_heat.c     **** //
 356:ir_heat.c     **** // Gibt die gemittelte Steigung
 357:ir_heat.c     **** // über die letzten 4 Sekunden zurück
 358:ir_heat.c     **** //
 359:ir_heat.c     **** int16_t get_slope() {
 737               	sub r20,r18
 738               		sbc r21,r19
 739               		movw r18,r20
 740               		lsl r18
 741               		rol r19
 742               		add r18,r20
 743               		adc r19,r21
 744 034c A0E0      		add r24,r18
 745 034e B0E0      		adc r25,r19
 746 0350 FD01      		adiw r26,6
 747 0352 2191      		ld r20,X+
 748 0354 3191      		ld r21,X
 749 0356 8091 0000 		sbiw r26,6+1
 750 035a 9091 0000 		adiw r26,4
 751 035e 281B      		ld r18,X+
 752 0360 390B      		ld r19,X
 753 0362 C901      		sbiw r26,4+1
 754 0364 880F      		sub r20,r18
 755 0366 991F      		sbc r21,r19
 756 0368 880F      		movw r18,r20
 757 036a 991F      		lsl r18
 758 036c 820F      		rol r19
 759 036e 931F      		add r18,r20
 760 0370 1897      		adc r19,r21
 761 0372 4081      		movw r20,r18
 762 0374 5181      		lsl r20
 763 0376 2D91      		rol r21
 764 0378 3C91      		lsl r20
 765 037a 1197      		rol r21
 766 037c 421B      		add r18,r20
 767 037e 530B      		adc r19,r21
 768 0380 9A01      		add r24,r18
 769 0382 220F      		adc r25,r19
 770 0384 331F      		ldi r22,lo8(9)
 771 0386 240F      		ldi r23,hi8(9)
 772 0388 351F      		call __divmodhi4
 773 038a 820F      		mov r24,r22
 774 038c 931F      		mov r25,r23
 775 038e 1696      	/* epilogue start */
 777 0392 5C91      	.LM68:
 778 0394 1797      		ret
 780 0398 2D91      	.Lscope13:
 782 039c 1597      	.global	get_last_slope
 784 03a0 530B      	get_last_slope:
 786 03a4 220F      	.LM69:
 787 03a6 331F      	.LFBB14:
 788 03a8 240F      	/* prologue: function */
 789 03aa 351F      	/* frame size = 0 */
 791 03ae 440F      	.LM70:
 792 03b0 551F      		lds r18,t_array+10
 793 03b2 440F      		lds r19,(t_array+10)+1
 794 03b4 551F      		lds r24,t_array+8
 795 03b6 240F      		lds r25,(t_array+8)+1
 796 03b8 351F      		sub r18,r24
 797 03ba 820F      		sbc r19,r25
 799 03be 69E0      	.LM71:
 800 03c0 70E0      		mov r24,r18
 801 03c2 0E94 0000 		mov r25,r19
 802 03c6 862F      	/* epilogue start */
 803 03c8 972F      		ret
 360:ir_heat.c     **** 	int16_t s1, s2, s3;
 361:ir_heat.c     **** 
 362:ir_heat.c     **** 	s1 = t_array[5] - t_array[0];
 363:ir_heat.c     **** 	s2 = t_array[4] - t_array[1];
 364:ir_heat.c     **** 	s3 = t_array[3] - t_array[2];
 365:ir_heat.c     **** 	
 366:ir_heat.c     **** 	return ((3*s1+5*s2+15*s3)/9);
 367:ir_heat.c     **** }
 805               	:P(4,4)",64,0,0,24
 806               	.global	_beep
 808               	_beep:
 810               	.LM72:
 811               	.LFBB15:
 812               	/* prologue: function */
 813               	/* frame size = 0 */
 368:ir_heat.c     **** 
 369:ir_heat.c     **** 
 370:ir_heat.c     **** 
 371:ir_heat.c     **** //********************************************
 372:ir_heat.c     **** //
 373:ir_heat.c     **** // Gibt die aktuelle Steigung der Temperatur zurück
 374:ir_heat.c     **** // in 0.1°C in 4s
 375:ir_heat.c     **** //
 376:ir_heat.c     **** int16_t	get_last_slope() {
 814               	8,0,417,.LM73-.LFBB15
 815               	.LM73:
 816               		ldi r30,lo8(37)
 817               		ldi r31,hi8(37)
 818               		ld r18,Z
 819               		ori r18,lo8(-128)
 820               		st Z,r18
 822 03d0 3091 0000 	.LM74:
 823 03d4 8091 0000 		ldi r22,lo8(20)
 824 03d8 9091 0000 		ldi r23,hi8(20)
 825 03dc 281B      		call __udivmodhi4
 826 03de 390B      		mov r24,r22
 377:ir_heat.c     ****     return (t_array[5] - t_array[4]);
 378:ir_heat.c     **** }
 827               		sbiw r24,0
 828               		breq .L45
 829 03e0 822F      		ldi r18,lo8(0)
 830 03e2 932F      		ldi r19,hi8(0)
 831               	.LBB36:
 832 03e4 0895      	.LBB37:
 833               	.LBB38:
 834               	.LBB39:
 836               	.Ltext1:
 838               	.LM75:
 839               		ldi r20,lo8(5000)
 379:ir_heat.c     **** 
 380:ir_heat.c     **** 
 381:ir_heat.c     **** 
 382:ir_heat.c     **** //********************************************
 383:ir_heat.c     **** //
 384:ir_heat.c     **** // Liest die vom MLX90614 gemessene Temperatur aus
 385:ir_heat.c     **** // Rückgabe in 0.1°C, also 215 = 21.5°C
 386:ir_heat.c     **** //
 387:ir_heat.c     **** uint16_t get_temperature(uint8_t adr) {
 388:ir_heat.c     **** 	uint16_t raw;
 389:ir_heat.c     **** 	uint8_t 	ret;
 390:ir_heat.c     **** 	uint8_t 	lo, hi, pec;
 391:ir_heat.c     **** 	uint8_t	pec_read[6];
 392:ir_heat.c     **** 
 393:ir_heat.c     **** 	if(i2c_start(MLX90614_WRITE)) return DEFAULT_TEMP;
 394:ir_heat.c     **** 	if(i2c_write(adr)) return DEFAULT_TEMP;
 395:ir_heat.c     **** 	
 396:ir_heat.c     **** 	ret = i2c_rep_start(MLX90614_READ);
 397:ir_heat.c     **** 	if(ret) {
 398:ir_heat.c     **** 		i2c_rep_start(MLX90614_READ);
 399:ir_heat.c     ****    }
 400:ir_heat.c     **** 
 401:ir_heat.c     **** 	lo = i2c_read_ack();
 402:ir_heat.c     **** 	hi = i2c_read_ack();
 403:ir_heat.c     **** 	raw = (uint16_t)(hi<<8)+lo;
 404:ir_heat.c     **** 	pec = i2c_read_ack();
 405:ir_heat.c     **** 	
 406:ir_heat.c     **** 	i2c_stop();
 407:ir_heat.c     **** 	
 408:ir_heat.c     **** 	if(raw & 0x8000) return DEFAULT_TEMP;
 409:ir_heat.c     **** 	
 410:ir_heat.c     **** 	return (raw / 5 - 2731); 					// 1 = 0.1°C
 411:ir_heat.c     **** }
 412:ir_heat.c     **** 
 413:ir_heat.c     **** 
 414:ir_heat.c     **** 
 415:ir_heat.c     **** void _beep(uint16_t duration_ms){
 840               	5000)
 841               	.L46:
 842               		movw r30,r20
 843               	/* #APP */
 844               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 416:ir_heat.c     **** 	uint16_t i;
 417:ir_heat.c     **** 	BUZZER_ON;
 845               	biw r30,1
 846               		brne 1b
 847 03e6 E5E2      	 ;  0 "" 2
 848 03e8 F0E0      	/* #NOAPP */
 849 03ea 2081      	.LBE39:
 850 03ec 2068      	.LBE38:
 851 03ee 2083      	.LBE37:
 418:ir_heat.c     **** 	for(i=0;i<(duration_ms/20);i++) _delay_ms(20);
 852               	
 854 03f0 64E1      	.Ltext2:
 856 03f4 0E94 0000 	.LM76:
 857 03f8 862F      		subi r18,lo8(-(1))
 858 03fa 972F      		sbci r19,hi8(-(1))
 859 03fc 0097      		cp r18,r24
 860 03fe 01F0      		cpc r19,r25
 861 0400 20E0      		brlo .L46
 862 0402 30E0      	.L45:
 864               	.LM77:
 865               		ldi r30,lo8(37)
 866               		ldi r31,hi8(37)
 867               		ld r24,Z
 868               		andi r24,lo8(127)
   1:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   5:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   8:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  11:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      distribution.
  15:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  16:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  20:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  32:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  34:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  37:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  39:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \file */
  40:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \code
  42:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \endcode
  44:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  45:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  53:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  60:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  62:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  63:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  64:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #endif
  68:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  69:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  71:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     register.
  76:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  77:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     can be achieved.
  79:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  80:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
  81:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
  83:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	);
  89:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** }
  90:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  91:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  93:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     counter register pair.
  98:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  99:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****  */
 102:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
 103:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
 105:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 869               	logue start */
 871 0404 48E8      	.LM78:
 872 0406 53E1      		ret
 877 040a 3197      	.Lscope15:
 880               	.global	beep
 882               	beep:
 884               	.LM79:
 885               	.LFBB16:
 886               	/* prologue: function */
 887               	/* frame size = 0 */
 889 040e 2F5F      	.LM80:
 890 0410 3F4F      	/* #APP */
 891 0412 2817      	 ;  424 "ir_heat.c" 1
 892 0414 3907      		cli
 893 0416 00F0      	 ;  0 "" 2
 419:ir_heat.c     **** 	BUZZER_OFF;
 895               	 1
 896               		wdr
 897 0418 E5E2      	 ;  0 "" 2
 899 041c 8081      	.LM82:
 900 041e 8F77      	/* #NOAPP */
 901 0420 8083      		cpi r24,lo8(3)
 902               		breq .L53
 420:ir_heat.c     **** }
 903               	,lo8(4)
 904               		brsh .L56
 905 0422 0895      		cpi r24,lo8(1)
 906               		breq .L51
 907               		cpi r24,lo8(2)
 908               		brne .L50
 909               		rjmp .L58
 910               	.L56:
 911               		cpi r24,lo8(4)
 912               		breq .L54
 913               		cpi r24,lo8(6)
 914               		brne .L50
 915               		rjmp .L59
 421:ir_heat.c     **** 
 422:ir_heat.c     **** 
 423:ir_heat.c     **** void	beep(uint8_t type){
 916               		68,0,428,.LM83-.LFBB16
 917               	.LM83:
 918               		ldi r24,lo8(120)
 919               		ldi r25,hi8(120)
 920               		call _beep
 424:ir_heat.c     **** 	cli();
 921               	 .L50
 922               	.L53:
 924               	.LM84:
 925 0424 F894      		ldi r24,lo8(250)
 926               		ldi r25,hi8(250)
 425:ir_heat.c     **** 	wdt_reset();
 927               	_beep
 928               		rjmp .L50
 929               	.L54:
 931               	.LM85:
 426:ir_heat.c     **** 	switch(type){
 932               	r24,lo8(850)
 933               		ldi r25,hi8(850)
 934               		call _beep
 935 0428 8330      		rjmp .L50
 936 042a 01F0      	.L58:
 938 042e 00F4      	.LM86:
 939 0430 8130      		ldi r24,lo8(80)
 940 0432 01F0      		ldi r25,hi8(80)
 941 0434 8230      		call _beep
 942 0436 01F4      	.LBB40:
 943 0438 00C0      	.LBB41:
 944               	.LBB42:
 945 043a 8430      	.LBB43:
 947 043e 8630      	.Ltext3:
 949 0442 00C0      	.LM87:
 950               		ldi r24,lo8(20000)
 427:ir_heat.c     **** 	case BEEP_SHORT:
 428:ir_heat.c     **** 		_beep(120);
 951               	
 952               	/* #APP */
 953 0444 88E7      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 954 0446 90E0      		1: sbiw r24,1
 955 0448 0E94 0000 		brne 1b
 956 044c 00C0      	 ;  0 "" 2
 957               	/* #NOAPP */
 429:ir_heat.c     **** 		break;
 430:ir_heat.c     **** 	case BEEP_LONG:
 431:ir_heat.c     **** 		_beep(250);
 958               	:
 959               	.LBE42:
 960 044e 8AEF      	.LBE41:
 961 0450 90E0      	.LBE40:
 963 0456 00C0      	.Ltext4:
 432:ir_heat.c     **** 		break;
 433:ir_heat.c     **** 	case BEEP_XLONG:
 434:ir_heat.c     **** 		_beep(850);
 965               		ldi r24,lo8(80)
 966               		ldi r25,hi8(80)
 967 0458 82E5      		call _beep
 968 045a 93E0      		rjmp .L50
 969 045c 0E94 0000 	.L59:
 971               	.LM89:
 435:ir_heat.c     **** 		break;
 436:ir_heat.c     **** 	case BEEP_2SHORT:
 437:ir_heat.c     **** 		_beep(80);
 972               	4,lo8(100)
 973               		ldi r25,hi8(100)
 974 0462 80E5      		call _beep
 975 0464 90E0      	.LBB44:
 976 0466 0E94 0000 	.LBB45:
 977               	.LBB46:
 978               	.LBB47:
 980               	.Ltext5:
 982               	.LM90:
 983               		ldi r24,lo8(-20536)
 984               		ldi r25,hi8(-20536)
 985 046a 80E2      	/* #APP */
 986 046c 9EE4      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 987               		1: sbiw r24,1
 988               		brne 1b
 989 046e 0197      	 ;  0 "" 2
 990 0470 01F4      	/* #NOAPP */
 991               	.LBE47:
 992               	.LBE46:
 993               	.LBE45:
 994               	.LBE44:
 996               	.Ltext6:
 998               	.LM91:
 438:ir_heat.c     **** 		_delay_ms(80);
 439:ir_heat.c     **** 		_beep(80);
 999               	hi8(350)
 1000               		call _beep
 1001 0472 80E5      	.L50:
 1003 0476 0E94 0000 	.LM92:
 1004 047a 00C0      	/* #APP */
 1005               	 ;  446 "ir_heat.c" 1
 440:ir_heat.c     **** 		break;
 441:ir_heat.c     **** 	case BEEP_SHORT_LONG:
 442:ir_heat.c     **** 		_beep(100);
 1006               	  0 "" 2
 1007               	/* epilogue start */
 1009 047e 90E0      	.LM93:
 1010 0480 0E94 0000 	/* #NOAPP */
 1011               		ret
 1013               	.Lscope16:
 1014               		.data
 1015               	.LC0:
 1016               		.string	">>> Relais ON"
 1017               	.LC1:
 1018               		.string	">>> Relais OFF"
 1019 0484 88EC      		.text
 1022               	.global	set_relais
 1024 048a 01F4      	set_relais:
 1026               	.LM94:
 1027               	.LFBB17:
 1028               		push r17
 1029               	/* prologue: function */
 1030               	/* frame size = 0 */
 1031               		mov r17,r24
 443:ir_heat.c     **** 		_delay_ms(180);
 444:ir_heat.c     **** 		_beep(350);		
 1034               	.LM96:
 1035 048c 8EE5      		lds r24,last.2001
 1036 048e 91E0      		cp r17,r24
 1037 0490 0E94 0000 		breq .L62
 1038               		ldi r24,lo8(.LC0)
 445:ir_heat.c     **** 	}
 446:ir_heat.c     **** 	sei();	
 1039               	25,hi8(.LC0)
 1040               		call puts
 1041               	.L62:
 1043 0494 7894      	.LM97:
 1044               		ldi r30,lo8(37)
 1045               		ldi r31,hi8(37)
 447:ir_heat.c     **** }
 1046               	,Z
 1047               		ori r24,lo8(64)
 1048               		st Z,r24
 1049 0496 0895      		rjmp .L63
 1050               	.L61:
 1052               	.LM98:
 1053               		lds r24,last.2001
 1054 0000 3E3E 3E20 		tst r24
 1054      5265 6C61 
 1054      6973 204F 
 1054      4E00 
 1055               		breq .L64
 1056 000e 3E3E 3E20 		ldi r24,lo8(.LC1)
 1056      5265 6C61 
 1056      6973 204F 
 1056      4646 00
 1057               		ldi r25,hi8(.LC1)
 1058               		call puts
 1059               	.L64:
 1061               	.LM99:
 1062               		ldi r30,lo8(37)
 448:ir_heat.c     **** 
 449:ir_heat.c     **** 
 450:ir_heat.c     **** 
 451:ir_heat.c     **** //***************************************************
 452:ir_heat.c     **** //
 453:ir_heat.c     **** // Relais Ein- und Ausschalen
 454:ir_heat.c     **** //
 455:ir_heat.c     **** void set_relais(uint8_t on) {
 1063               		ld r24,Z
 1064               		andi r24,lo8(-65)
 1065               		st Z,r24
 1066 0498 1F93      	.L63:
 1068               	.LM100:
 1069 049a 182F      		sts last.2001,r17
 456:ir_heat.c     **** 	static uint8_t last = 0;
 457:ir_heat.c     **** 	if(on) {
 1070               	ogue start */
 1072 049c 8823      	.LM101:
 1073 049e 01F0      		pop r17
 458:ir_heat.c     **** 		if(on != last) printf(">>> Relais ON\n");
 1074               	
 1079 04a8 80E0      	.Lscope17:
 1080 04aa 90E0      		.data
 1081 04ac 0E94 0000 	.LC2:
 1082               		.string	"Temperature Protection Off!"
 459:ir_heat.c     **** 		RELAIS_ON;
 1083               	string	"\nxXx"
 1084               		.text
 1086 04b2 F0E0      	.global	__vector_1
 1088 04b6 8064      	__vector_1:
 1090 04ba 00C0      	.LM102:
 1091               	.LFBB18:
 460:ir_heat.c     **** 	}
 461:ir_heat.c     **** 	else {
 462:ir_heat.c     **** 		if(on != last) printf(">>> Relais OFF\n");
 1092               	ero_reg__
 1093               		push r0
 1094 04bc 8091 0000 		in r0,__SREG__
 1095 04c0 8823      		push r0
 1096 04c2 01F0      		clr __zero_reg__
 1097 04c4 80E0      		push r18
 1098 04c6 90E0      		push r19
 1099 04c8 0E94 0000 		push r20
 1100               		push r21
 463:ir_heat.c     **** 		RELAIS_OFF;
 1101               	
 1102               		push r23
 1103 04cc E5E2      		push r24
 1104 04ce F0E0      		push r25
 1105 04d0 8081      		push r26
 1106 04d2 8F7B      		push r27
 1107 04d4 8083      		push r30
 1108               		push r31
 464:ir_heat.c     **** 	}
 465:ir_heat.c     **** 	last = on;
 1109               	ogue: Signal */
 1110               	/* frame size = 0 */
 1112               	.LM103:
 466:ir_heat.c     **** }
 1113               	 r24,133
 1114               		lds r18,132
 1115 04da 1F91      		lds r25,running.1757
 1116 04dc 0895      		or r24,r25
 1117               		or r24,r18
 1118               		breq .+2
 1119               		rjmp .L77
 1121               	.LM104:
 1122               		ldi r24,lo8(1)
 1123               		sts running.1757,r24
 1125               	.LM105:
 1126 0039 0A78 5878 	/* #APP */
 1126      00
 1127               	 ;  164 "ir_heat.c" 1
 1128               		wdr
 1129               	 ;  0 "" 2
 1131               	.LM106:
 1132               	/* #NOAPP */
 1133               		out 61-32,__zero_reg__
 1135 04de 1F92      	.LM107:
 1136 04e0 0F92      	/* #APP */
 1137 04e2 0FB6      	 ;  169 "ir_heat.c" 1
 1138 04e4 0F92      		sei
 1139 04e6 1124      	 ;  0 "" 2
 1140 04e8 2F93      	/* #NOAPP */
 1141 04ea 3F93      		ldi r18,lo8(0)
 1142 04ec 4F93      		ldi r19,hi8(0)
 1143 04ee 5F93      		ldi r20,lo8(0)
 1144 04f0 6F93      		ldi r21,hi8(0)
 1146 04f4 8F93      	.LM108:
 1147 04f6 9F93      		ldi r30,lo8(41)
 1148 04f8 AF93      		ldi r31,hi8(41)
 1149 04fa BF93      	.L69:
 1150 04fc EF93      		ld r24,Z
 1151 04fe FF93      		sbrs r24,2
 1152               		rjmp .L68
 1153               		subi r20,lo8(-(1))
 1154               		sbci r21,hi8(-(1))
 1155               	.L68:
 1156 0500 8091 8500 		subi r18,lo8(-(1))
 1157 0504 2091 8400 		sbci r19,hi8(-(1))
 1158 0508 9091 0000 		ldi r24,hi8(1000)
 1159 050c 892B      		cpi r18,lo8(1000)
 1160 050e 822B      		cpc r19,r24
 1161 0510 01F0      		brne .L69
 1163               	.LM109:
 1164               		cpi r20,200
 1165 0514 81E0      		cpc r21,__zero_reg__
 1166 0516 8093 0000 		brlo .+2
 1167               		rjmp .L70
 1169               	.LM110:
 1170               		ldi r24,lo8(1)
 1171 051a A895      		sts 132,r24
 1173               	.LM111:
 1174               		ldi r24,lo8(2)
 1175               		sts 129,r24
 1177               	.LM112:
 1178               		lds r24,mode
 1179               		tst r24
 1180               		breq .+2
 1181 051e 7894      		rjmp .L80
 1183               	.LM113:
 1184 0520 20E0      		ldi r24,lo8(1)
 1185 0522 30E0      		sts mode,r24
 1187 0526 50E0      	.LM114:
 1188               		call set_relais
 1190 0528 E9E2      	.LM115:
 1191 052a F0E0      		ldi r30,lo8(43)
 1192               		ldi r31,hi8(43)
 1193 052c 8081      		ld r24,Z
 1194 052e 82FF      		ori r24,lo8(16)
 1195 0530 00C0      		st Z,r24
 1197 0534 5F4F      	.LM116:
 1198               		ld r24,Z
 1199 0536 2F5F      		ori r24,lo8(8)
 1200 0538 3F4F      		st Z,r24
 1202 053c 283E      	.LM117:
 1203 053e 3807      		sbic 41-32,2
 1204 0540 01F4      		rjmp .L73
 1205               		ldi r18,lo8(0)
 1206               		ldi r19,hi8(0)
 1207 0542 483C      	.LBB48:
 1208 0544 5105      	.LBB49:
 1209 0546 00F0      	.LBB50:
 1210 0548 00C0      	.LBB51:
 1212               	.Ltext7:
 1214 054c 8093 8400 	.LM118:
 1215               		ldi r20,lo8(2500)
 1216               		ldi r21,hi8(2500)
 1217 0550 82E0      	.LBE51:
 1218 0552 8093 8100 	.LBE50:
 1219               	.LBE49:
 1220               	.LBE48:
 1222 055a 8823      	.Ltext8:
 1224 055e 00C0      	.LM119:
 1225               		ldi r30,lo8(41)
 1226               		ldi r31,hi8(41)
 1227 0560 81E0      	.L75:
 1229               	.LM120:
 1230               		subi r18,lo8(-(1))
 1231 0566 0E94 0000 		sbci r19,hi8(-(1))
 1232               	.LBB55:
 1233               	.LBB54:
 1234 056a EBE2      	.LBB53:
 1235 056c F0E0      	.LBB52:
 1237 0570 8061      	.Ltext9:
 1239               	.LM121:
 1240               		movw r24,r20
 1241 0574 8081      	/* #APP */
 1242 0576 8860      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1243 0578 8083      		1: sbiw r24,1
 1244               		brne 1b
 1245               	 ;  0 "" 2
 1246 057a 4A99      	/* #NOAPP */
 1247 057c 00C0      	.LBE52:
 1248 057e 20E0      	.LBE53:
 1249 0580 30E0      	.LBE54:
 1250               	.LBE55:
 1252               	.Ltext10:
 1254               	.LM122:
 1255               		ld r24,Z
 1256               		sbrc r24,2
 1257               		rjmp .L74
 1258 0582 44EC      		ldi r24,hi8(300)
 1259 0584 59E0      		cpi r18,lo8(300)
 1260               		cpc r19,r24
 1261               		brne .L75
 1262               		rjmp .L76
 1263               	.L74:
 1265               	.LM123:
 1266               		subi r18,lo8(300)
 1267               		sbci r19,hi8(300)
 1268 0586 E9E2      		brsh .L76
 1269 0588 F0E0      	.L73:
 1271               	.LM124:
 1272               		ldi r24,lo8(1)
 1273 058a 2F5F      		sts mode,r24
 1274 058c 3F4F      		rjmp .L70
 1275               	.L76:
 1277               	.LM125:
 1278               		ldi r24,lo8(2)
 1279               		sts mode,r24
 1281               	.LM126:
 1282               		ldi r24,lo8(.LC2)
 1283 058e CA01      		ldi r25,hi8(.LC2)
 1284               		call puts
 1286 0590 0197      	.LM127:
 1287 0592 01F4      		ldi r30,lo8(43)
 1288               		ldi r31,hi8(43)
 1289               		ld r24,Z
 1290               		andi r24,lo8(-17)
 1291               		st Z,r24
 1293               	.LM128:
 1294               		ld r24,Z
 1295               		ori r24,lo8(8)
 1296               		st Z,r24
 1298 0594 8081      	.LM129:
 1299 0596 82FD      		ldi r24,lo8(6)
 1300 0598 00C0      		call beep
 1301 059a 81E0      		rjmp .L70
 1302 059c 2C32      	.L80:
 1304 05a0 01F4      	.LM130:
 1305 05a2 00C0      		ldi r24,lo8(.LC3)
 1306               		ldi r25,hi8(.LC3)
 1307               		call puts
 1309 05a4 2C52      	.LM131:
 1310 05a6 3140      		sts mode,__zero_reg__
 1311 05a8 00F4      	.L70:
 1313               	.LM132:
 1314               		ldi r24,lo8(1)
 1315 05aa 81E0      		out 60-32,r24
 1317 05b0 00C0      	.LM133:
 1318               		out 61-32,r24
 1320               	.LM134:
 1321 05b2 82E0      		sts running.1757,__zero_reg__
 1322 05b4 8093 0000 	.L77:
 1323               	/* epilogue start */
 1325 05b8 80E0      	.LM135:
 1326 05ba 90E0      		pop r31
 1327 05bc 0E94 0000 		pop r30
 1328               		pop r27
 1329               		pop r26
 1330 05c0 EBE2      		pop r25
 1331 05c2 F0E0      		pop r24
 1332 05c4 8081      		pop r23
 1333 05c6 8F7E      		pop r22
 1334 05c8 8083      		pop r21
 1335               		pop r20
 1336               		pop r19
 1337 05ca 8081      		pop r18
 1338 05cc 8860      		pop r0
 1339 05ce 8083      		out __SREG__,r0
 1340               		pop r0
 1341               		pop __zero_reg__
 1342 05d0 86E0      		reti
 1349 05da 90E0      	.Lscope18:
 1352               	.global	get_temperature
 1354               	get_temperature:
 1356               	.LM136:
 1357 05e4 81E0      	.LFBB19:
 1358 05e6 8CBB      		push r17
 1359               		push r28
 1360               		push r29
 1361 05e8 8DBB      	/* prologue: function */
 1362               	/* frame size = 0 */
 1363               		mov r17,r24
 1365               	.LM137:
 1366               		ldi r24,lo8(-76)
 1367               		call i2c_start
 1368               		tst r24
 1369 05ee FF91      		brne .L82
 1371 05f2 BF91      	.LM138:
 1372 05f4 AF91      		mov r24,r17
 1373 05f6 9F91      		call i2c_write
 1374 05f8 8F91      		tst r24
 1375 05fa 7F91      		brne .L82
 1377 05fe 5F91      	.LM139:
 1378 0600 4F91      		ldi r24,lo8(-75)
 1379 0602 3F91      		call i2c_rep_start
 1381 0606 0F90      	.LM140:
 1382 0608 0FBE      		tst r24
 1383 060a 0F90      		breq .L83
 1385 060e 1895      	.LM141:
 1386               		ldi r24,lo8(-75)
 1387               		call i2c_rep_start
 1388               	.L83:
 1390               	.LM142:
 1391               		call i2c_read_ack
 1392               		mov r17,r24
 1394               	.LM143:
 1395               		call i2c_read_ack
 1397               	.LM144:
 1398               		mov r19,r24
 1399               		ldi r18,lo8(0)
 1400               		movw r28,r18
 1401 0610 1F93      		add r28,r17
 1402 0612 CF93      		adc r29,__zero_reg__
 1404               	.LM145:
 1405               		call i2c_read_ack
 1407               	.LM146:
 1408               		call i2c_stop
 1410 061a 0E94 0000 	.LM147:
 1411 061e 8823      		tst r29
 1412 0620 01F4      		brlt .L82
 1414               	.LM148:
 1415 0622 812F      		movw r24,r28
 1416 0624 0E94 0000 		ldi r22,lo8(5)
 1417 0628 8823      		ldi r23,hi8(5)
 1418 062a 01F4      		call __udivmodhi4
 1419               		subi r22,lo8(-(-2731))
 1420               		sbci r23,hi8(-(-2731))
 1421 062c 85EB      		rjmp .L84
 1422 062e 0E94 0000 	.L82:
 1423               		ldi r22,lo8(150)
 1424               		ldi r23,hi8(150)
 1425 0632 8823      	.L84:
 1427               	.LM149:
 1428               		mov r24,r22
 1429 0636 85EB      		mov r25,r23
 1430 0638 0E94 0000 	/* epilogue start */
 1431               		pop r29
 1432               		pop r28
 1433               		pop r17
 1434 063c 0E94 0000 		ret
 1440               	.Lscope19:
 1441 0646 382F      		.data
 1442 0648 20E0      	.LC4:
 1443 064a E901      		.string	"Array:"
 1444 064c C10F      	.LC5:
 1445 064e D11D      		.string	" %i"
 1446               		.text
 1448 0650 0E94 0000 	.global	print_array
 1450               	print_array:
 1452               	.LM150:
 1453               	.LFBB20:
 1454 0658 DD23      		push r12
 1455 065a 04F0      		push r13
 1456               		push r14
 1457               		push r15
 1458 065c CE01      		push r16
 1459 065e 65E0      		push r17
 1460 0660 70E0      	/* prologue: function */
 1461 0662 0E94 0000 	/* frame size = 0 */
 1463 0668 7A40      	.LM151:
 1464 066a 00C0      		rcall .
 1465               		ldi r24,lo8(.LC4)
 1466 066c 66E9      		ldi r25,hi8(.LC4)
 1467 066e 70E0      		in r26,__SP_L__
 1468               		in r27,__SP_H__
 1469               		adiw r26,1+1
 1470               		st X,r25
 1471 0670 862F      		st -X,r24
 1472 0672 972F      		sbiw r26,1
 1473               		call printf
 1475 0676 CF91      	.LM152:
 1476 0678 1F91      		rcall .
 1477 067a 0895      		in r30,__SP_L__
 1478               		in r31,__SP_H__
 1479               		adiw r30,1
 1480               		mov __tmp_reg__,r31
 1481               		ldi r31,lo8(.LC5)
 1482               		mov r14,r31
 1483               		ldi r31,hi8(.LC5)
 1484               		mov r15,r31
 1485               		mov r31,__tmp_reg__
 1486 003e 4172 7261 		std Z+1,r15
 1486      793A 00
 1487               		st Z,r14
 1488 0045 2025 6900 		mov __tmp_reg__,r31
 1489               		ldi r31,lo8(t_array)
 1490               		mov r12,r31
 1491               		ldi r31,hi8(t_array)
 1492               		mov r13,r31
 1493               		mov r31,__tmp_reg__
 1494               		movw r26,r12
 1495               		ld r24,X+
 1496               		ld r25,X+
 1497 067c CF92      		movw r16,r26
 1498 067e DF92      		std Z+3,r25
 1499 0680 EF92      		std Z+2,r24
 1500 0682 FF92      		call printf
 1501 0684 0F93      		in r30,__SP_L__
 1502 0686 1F93      		in r31,__SP_H__
 1503               		adiw r30,1
 1504               		std Z+1,r15
 1505               		st Z,r14
 1506               		movw r26,r16
 1507 0688 00D0      		ld r24,X+
 1508 068a 80E0      		ld r25,X
 1509 068c 90E0      		std Z+3,r25
 1510 068e ADB7      		std Z+2,r24
 1511 0690 BEB7      		call printf
 1512 0692 1296      		in r30,__SP_L__
 1513 0694 9C93      		in r31,__SP_H__
 1514 0696 8E93      		adiw r30,1
 1515 0698 1197      		std Z+1,r15
 1516 069a 0E94 0000 		st Z,r14
 1517               		movw r26,r12
 1518               		adiw r26,4
 1519 069e 00D0      		ld r24,X+
 1520 06a0 EDB7      		ld r25,X
 1521 06a2 FEB7      		sbiw r26,4+1
 1522 06a4 3196      		std Z+3,r25
 1523 06a6 0F2E      		std Z+2,r24
 1524 06a8 F0E0      		call printf
 1525 06aa EF2E      		in r30,__SP_L__
 1526 06ac F0E0      		in r31,__SP_H__
 1527 06ae FF2E      		adiw r30,1
 1528 06b0 F02D      		std Z+1,r15
 1529 06b2 F182      		st Z,r14
 1530 06b4 E082      		movw r26,r12
 1531 06b6 0F2E      		adiw r26,6
 1532 06b8 F0E0      		ld r24,X+
 1533 06ba CF2E      		ld r25,X
 1534 06bc F0E0      		sbiw r26,6+1
 1535 06be DF2E      		std Z+3,r25
 1536 06c0 F02D      		std Z+2,r24
 1537 06c2 D601      		call printf
 1538 06c4 8D91      		in r30,__SP_L__
 1539 06c6 9D91      		in r31,__SP_H__
 1540 06c8 8D01      		adiw r30,1
 1541 06ca 9383      		std Z+1,r15
 1542 06cc 8283      		st Z,r14
 1543 06ce 0E94 0000 		movw r26,r12
 1544 06d2 EDB7      		adiw r26,8
 1545 06d4 FEB7      		ld r24,X+
 1546 06d6 3196      		ld r25,X
 1547 06d8 F182      		sbiw r26,8+1
 1548 06da E082      		std Z+3,r25
 1549 06dc D801      		std Z+2,r24
 1550 06de 8D91      		call printf
 1551 06e0 9C91      		in r30,__SP_L__
 1552 06e2 9383      		in r31,__SP_H__
 1553 06e4 8283      		adiw r30,1
 1554 06e6 0E94 0000 		std Z+1,r15
 1555 06ea EDB7      		st Z,r14
 1556 06ec FEB7      		movw r26,r12
 1557 06ee 3196      		adiw r26,10
 1558 06f0 F182      		ld r24,X+
 1559 06f2 E082      		ld r25,X
 1560 06f4 D601      		sbiw r26,10+1
 1561 06f6 1496      		std Z+3,r25
 1562 06f8 8D91      		std Z+2,r24
 1563 06fa 9C91      		call printf
 1565 06fe 9383      	.LM153:
 1566 0700 8283      		pop __tmp_reg__
 1567 0702 0E94 0000 		pop __tmp_reg__
 1568 0706 EDB7      		pop __tmp_reg__
 1569 0708 FEB7      		pop __tmp_reg__
 1570 070a 3196      		ldi r24,lo8(10)
 1571 070c F182      		ldi r25,hi8(10)
 1572 070e E082      		call putchar
 1573 0710 D601      	/* epilogue start */
 1575 0714 8D91      	.LM154:
 1576 0716 9C91      		pop r17
 1577 0718 1797      		pop r16
 1578 071a 9383      		pop r15
 1579 071c 8283      		pop r14
 1580 071e 0E94 0000 		pop r13
 1581 0722 EDB7      		pop r12
 1582 0724 FEB7      		ret
 1584 0728 F182      	.Lscope20:
 1586 072c D601      	.global	UART_first_init
 1588 0730 8D91      	UART_first_init:
 1590 0734 1997      	.LM155:
 1591 0736 9383      	.LFBB21:
 1592 0738 8283      	/* prologue: function */
 1593 073a 0E94 0000 	/* frame size = 0 */
 1595 0740 FEB7      	.LM156:
 1596 0742 3196      		ldi r24,lo8(12)
 1597 0744 F182      		ldi r25,hi8(12)
 1598 0746 E082      		sts (196)+1,r25
 1599 0748 D601      		sts 196,r24
 1601 074c 8D91      	.LM157:
 1602 074e 9C91      		ldi r24,lo8(-104)
 1603 0750 1B97      		sts 193,r24
 1605 0754 8283      	.LM158:
 1606 0756 0E94 0000 		ldi r24,lo8(6)
 1607               		sts 194,r24
 1609 075a 0F90      	.LM159:
 1610 075c 0F90      		ldi r24,lo8(gs(UART_putchar))
 1611 075e 0F90      		ldi r25,hi8(gs(UART_putchar))
 1612 0760 0F90      		ldi r22,lo8(gs(UART_getchar))
 1613 0762 8AE0      		ldi r23,hi8(gs(UART_getchar))
 1614 0764 90E0      		call fdevopen
 1616               	.LM160:
 1617               	/* #APP */
 1618               	 ;  295 "ir_heat.c" 1
 1619 076a 1F91      		sei
 1620 076c 0F91      	 ;  0 "" 2
 1621 076e FF90      	/* epilogue start */
 1623 0772 DF90      	.LM161:
 1624 0774 CF90      	/* #NOAPP */
 1625 0776 0895      		ret
 1627               	.Lscope21:
 1628               		.data
 1629               	.LC6:
 1630               		.string	"\n\nStart\n"
 1631               	.LC7:
 1632               		.string	"Error Temp=0"
 1633               	.LC8:
 1634               		.string	"Startup %i "
 1635               	.LC9:
 1636               		.string	"Temp: %i, "
 1637               	.LC10:
 1638               		.string	"exp_s: %i, s2: %i, fx: %i\n"
 1639 0778 8CE0      	.LC11:
 1640 077a 90E0      		.string	"On-Counter: %i; \n"
 1641 077c 9093 C500 	.LC12:
 1642 0780 8093 C400 		.string	"Off-Counter: %i; \n"
 1643               		.text
 1645 0784 88E9      	.global	main
 1647               	main:
 1649 078a 86E0      	.LM162:
 1650 078c 8093 C200 	.LFBB22:
 1651               		push r2
 1652               		push r3
 1653 0790 80E0      		push r4
 1654 0792 90E0      		push r5
 1655 0794 60E0      		push r6
 1656 0796 70E0      		push r7
 1657 0798 0E94 0000 		push r8
 1658               		push r9
 1659               		push r10
 1660               		push r11
 1661               		push r12
 1662 079c 7894      		push r13
 1663               		push r14
 1664               		push r15
 1665               		push r16
 1666               		push r17
 1667               		push r29
 1668 079e 0895      		push r28
 1669               		rcall .
 1670               		rcall .
 1671               		in r28,__SP_L__
 1672               		in r29,__SP_H__
 1673 0049 0A0A 5374 	/* prologue: function */
 1673      6172 740A 
 1673      00
 1674               	/* frame size = 4 */
 1676               	.LM163:
 1677 005f 5374 6172 		ldi r24,lo8(-64)
 1677      7475 7020 
 1677      2569 2000 
 1678               		out 36-32,r24
 1680               	.LM164:
 1681 0076 6578 705F 		ldi r24,lo8(8)
 1681      733A 2025 
 1681      692C 2073 
 1681      323A 2025 
 1681      692C 2066 
 1682               		out 39-32,r24
 1684               	.LM165:
 1685 00a3 4F66 662D 		ldi r24,lo8(24)
 1685      436F 756E 
 1685      7465 723A 
 1685      2025 693B 
 1685      200A 00
 1686               		out 42-32,r24
 1688               	.LM166:
 1689               		ldi r24,lo8(63)
 1690               		out 37-32,r24
 467:ir_heat.c     **** 
 468:ir_heat.c     **** 
 469:ir_heat.c     **** 
 470:ir_heat.c     **** 
 471:ir_heat.c     **** // ***********************************************************
 472:ir_heat.c     **** // Main program
 473:ir_heat.c     **** //
 474:ir_heat.c     **** int main(void) {
 1691               	n	68,0,483,.LM168-.LFBB22
 1692               	.LM168:
 1693               		ldi r16,lo8(43)
 1694 07a0 2F92      		ldi r17,hi8(43)
 1695 07a2 3F92      		ldi r24,lo8(-25)
 1696 07a4 4F92      		movw r30,r16
 1697 07a6 5F92      		st Z,r24
 1699 07aa 7F92      	.LM169:
 1700 07ac 8F92      		lds r24,100
 1702 07b0 AF92      	.LM170:
 1703 07b2 BF92      	/* #APP */
 1704 07b4 CF92      	 ;  489 "ir_heat.c" 1
 1705 07b6 DF92      		wdr
 1706 07b8 EF92      	 ;  0 "" 2
 1708 07bc 0F93      	.LM171:
 1709 07be 1F93      	/* #NOAPP */
 1710 07c0 DF93      		ldi r18,lo8(41)
 1711 07c2 CF93      		ldi r24,lo8(24)
 1712 07c4 00D0      		ldi r25,hi8(24)
 1713 07c6 00D0      	/* #APP */
 1714 07c8 CDB7      	 ;  490 "ir_heat.c" 1
 1715 07ca DEB7      		in __tmp_reg__,__SREG__
 1716               		cli
 1717               		wdr
 475:ir_heat.c     ****    // Ausgänge definieren
 476:ir_heat.c     **** 	DDRB = 0x00 | (1<<RELAIS) | (1<<BUZZER);
 1718               	_tmp_reg__
 1719               		sts 96,r18
 1720 07cc 80EC      		
 1721 07ce 84B9      	 ;  0 "" 2
 477:ir_heat.c     **** 	DDRC = 0x00 | (1<<FLASH_LED);
 1722               	abn	68,0,493,.LM172-.LFBB22
 1723               	.LM172:
 1724 07d0 88E0      	/* #NOAPP */
 1725 07d2 87B9      		call UART_first_init
 478:ir_heat.c     **** 	DDRD = 0x00 | (1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED);
 1726               	abn	68,0,494,.LM173-.LFBB22
 1727               	.LM173:
 1728 07d4 88E1      		call i2c_init
 479:ir_heat.c     **** 
 480:ir_heat.c     **** 	// Ausgänge ausschalten
 481:ir_heat.c     **** 	PORTB = ~((1<<RELAIS) | (1<<BUZZER));
 1730               	74:
 1731               		sts interval,__zero_reg__
 1733 07da 85B9      	.LM175:
 482:ir_heat.c     **** 	PORTC = ~(1<<FLASH_LED);
 1734               	 r24,lo8(7)
 1735               		sts 177,r24
 1737 07de 88B9      	.LM176:
 483:ir_heat.c     **** 	PORTD = ~((1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED));
 1738               	 r25,lo8(1)
 1739               		sts 112,r25
 1741 07e2 10E0      	.LM177:
 1742 07e4 87EE      		out 68-32,__zero_reg__
 1744 07e8 8083      	.LM178:
 484:ir_heat.c     **** 
 485:ir_heat.c     **** 	// TWI aus Energiesparmode rausnehmen
 486:ir_heat.c     **** 	PRR != ~(1<<PRTWI);
 1745               	4,lo8(3)
 1746               		out 69-32,r24
 487:ir_heat.c     **** 
 488:ir_heat.c     **** 	// Whatchdog initialisieren
 489:ir_heat.c     **** 	wdt_reset();
 1748               	179:
 1749               		sts 110,r25
 1751               	.LM180:
 1752 07ee A895      		sts 128,__zero_reg__
 490:ir_heat.c     **** 	wdt_enable(WDTO_8S);
 1754               	:
 1755               		sts 129,__zero_reg__
 1757 07f0 29E2      	.LM182:
 1758 07f2 88E1      		sts 130,__zero_reg__
 1760               	.LM183:
 1761               		sts 111,r25
 1763 07f8 F894      	.LM184:
 1764 07fa A895      		ldi r24,lo8(2)
 1765 07fc 8093 6000 		sts 105,r24
 1767 0802 2093 6000 	.LM185:
 1768               		out 61-32,r25
 491:ir_heat.c     **** 	
 492:ir_heat.c     **** 	// UART initialisieren
 493:ir_heat.c     **** 	UART_first_init();
 1770               	,lo8(.LC6)
 1771               		ldi r25,hi8(.LC6)
 1772               		call puts
 494:ir_heat.c     **** 	i2c_init();
 1774               	87:
 1775               		movw r30,r16
 1776 080a 0E94 0000 		ld r24,Z
 495:ir_heat.c     **** 	
 496:ir_heat.c     **** 	interval=0;
 1777               	i r24,lo8(16)
 1778               		st Z,r24
 497:ir_heat.c     **** 	
 498:ir_heat.c     **** 	// Timer 2 initialisieren (RTC)
 499:ir_heat.c     ****    TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);	// clk/256
 1780               	188:
 1781               		ld r24,Z
 1782 0812 87E0      		andi r24,lo8(-9)
 1783 0814 8093 B100 		st Z,r24
 500:ir_heat.c     ****    TIMSK2 = (1<<TOIE2);
 1784               	abn	68,0,521,.LM189-.LFBB22
 1785               	.LM189:
 1786 0818 91E0      		ldi r24,lo8(0)
 1787 081a 9093 7000 		call set_relais
 501:ir_heat.c     **** 
 502:ir_heat.c     ****  	// Timer 0 initialisieren (Blinken)
 503:ir_heat.c     **** 	TCCR0A = 0;
 1788               	abn	68,0,522,.LM190-.LFBB22
 1789               	.LM190:
 1790 081e 14BC      		sts mode,__zero_reg__
 504:ir_heat.c     **** 	TCCR0B = (0<<CS02) | (1<<CS01) | (1<<CS00);
 1791               	tabn	68,0,542,.LM191-.LFBB22
 1792               	.LM191:
 1793 0820 83E0      	/* #APP */
 1794 0822 85BD      	 ;  542 "ir_heat.c" 1
 505:ir_heat.c     **** 	TIMSK0 = (1<<TOIE0);
 1795               	
 1796               	 ;  0 "" 2
 1797 0824 9093 6E00 	/* #NOAPP */
 506:ir_heat.c     **** 	
 507:ir_heat.c     **** 	// Timer 1 initialisieren (Entprellen?)
 508:ir_heat.c     **** 	TCCR1A = 0;
 1798               	lr r8
 1799               		clr r9
 1800 0828 1092 8000 		ldi r16,lo8(0)
 509:ir_heat.c     **** 	TIMER1_STOP;
 1801               	i r31,lo8(-1)
 1802               		std Y+2,r31
 1803 082c 1092 8100 		mov __tmp_reg__,r31
 510:ir_heat.c     **** 	TCCR1C = 0;
 1804               	i r31,lo8(3)
 1805               		mov r6,r31
 1806 0830 1092 8200 		mov r31,__tmp_reg__
 511:ir_heat.c     **** 	TIMSK1 = (1<<TOIE1);
 1807               	r r7
 1808               		std Y+1,__zero_reg__
 512:ir_heat.c     **** 	
 513:ir_heat.c     **** 	// Interrupt für Taster initialisieren
 514:ir_heat.c     **** 	EICRA = (1<<ISC01);
 1810               	192:
 1811               		mov __tmp_reg__,r31
 1812 0838 82E0      		ldi r31,lo8(43)
 1813 083a 8093 6900 		mov r10,r31
 515:ir_heat.c     **** 	EIMSK = (1<<INT0);
 1814               	 r11
 1815               		mov r31,__tmp_reg__
 516:ir_heat.c     **** 	
 517:ir_heat.c     **** 
 518:ir_heat.c     **** 	printf("\n\nStart\n\n");
 1817               	193:
 1818               		clr r2
 1819 0840 80E0      		clr r3
 1820 0842 90E0      	.LBB56:
 1821 0844 0E94 0000 	.LBB57:
 519:ir_heat.c     **** 	STATUS_LED1_ON;		// grüne LED ein
 1822               	8:
 1823               	.LBB59:
 1825 084a 8081      	.Ltext11:
 1827 084e 8083      	.LM194:
 520:ir_heat.c     **** 	STATUS_LED2_OFF;		// rote LED aus
 1828               	_tmp_reg__,r31
 1829               		ldi r31,lo8(25000)
 1830 0850 8081      		mov r4,r31
 1831 0852 877F      		ldi r31,hi8(25000)
 1832 0854 8083      		mov r5,r31
 521:ir_heat.c     **** 	set_relais(0);			// Relais aus
 1833               	r31,__tmp_reg__
 1834               	.L114:
 1835 0856 80E0      	.LBE59:
 1836 0858 0E94 0000 	.LBE58:
 522:ir_heat.c     **** 	mode = MODE_OFF;
 1837               	57:
 1838               	.LBE56:
 523:ir_heat.c     **** 	
 524:ir_heat.c     **** //	int16_t temp, temp_sum, temp_a;
 525:ir_heat.c     **** //	int16_t	lookahead;
 526:ir_heat.c     **** //	int16_t 	slope, max_slope;
 527:ir_heat.c     **** //	int16_t	slope_raw;
 528:ir_heat.c     **** 	int16_t 	temp, temp_sum = 0;
 529:ir_heat.c     **** 	int16_t	slope_raw, slope = 0, temp_a, max_slope;
 530:ir_heat.c     **** 	uint8_t	count=0;
 531:ir_heat.c     **** 	uint8_t  last_interval = 0xff;
 532:ir_heat.c     **** 	uint8_t	startup = 3;
 533:ir_heat.c     **** 	uint8_t	on_counter = 0;
 534:ir_heat.c     **** 	int16_t	factor;
 535:ir_heat.c     **** 	int16_t	integral = 0;
 536:ir_heat.c     **** 	int8_t	fx = 0;
 537:ir_heat.c     **** 	
 538:ir_heat.c     **** 	int16_t	slope_std = 0;
 539:ir_heat.c     **** 	int16_t	slope_real = 0;
 540:ir_heat.c     **** 		
 541:ir_heat.c     **** 	// Interrupts aktivieren
 542:ir_heat.c     **** 	sei();
 1840               	ext12:
 1842               	.LM195:
 1843               		lds r20,interval
 1844 0860 7894      		cpi r20,lo8(16)
 1845               		brge .+2
 1846               		rjmp .L91
 1848 0864 9924      	.LM196:
 1849 0866 00E0      	/* #APP */
 1850 0868 FFEF      	 ;  546 "ir_heat.c" 1
 1851 086a FA83      		wdr
 1852 086c 0F2E      	 ;  0 "" 2
 1854 0870 6F2E      	.LM197:
 1855 0872 F02D      	/* #NOAPP */
 1856 0874 7724      		movw r24,r8
 1857 0876 1982      		mov r22,r16
 543:ir_heat.c     **** 
 544:ir_heat.c     ****    while(1) {
 545:ir_heat.c     ****    	if(!(interval < 16)) { 					// Alle 16x (alle 4 Sekunden) Temperatur checken
 546:ir_heat.c     ****    		wdt_reset();                  	// Whatchdog zurücksetzen
 547:ir_heat.c     **** 
 548:ir_heat.c     **** 			temp = temp_sum / count;				// Mittelwert der 16 Messungen ermitteln
 549:ir_heat.c     **** 
 550:ir_heat.c     ****    		interval=0;
 551:ir_heat.c     ****    		count=0;
 552:ir_heat.c     **** 			temp_sum = 0;
 553:ir_heat.c     **** 	      //printf("Temp: %i\n", temp);
 554:ir_heat.c     **** 	      if(temp==0) {
 555:ir_heat.c     **** 	      	// error!
 556:ir_heat.c     **** 	      	printf("Error Temp=0");
 557:ir_heat.c     **** 	      }
 558:ir_heat.c     **** 	      else {
 559:ir_heat.c     **** 				if (startup>0) {
 560:ir_heat.c     **** 					// wird nur beim ersten Durchlauf, direkt nach Startup ausgeführt
 561:ir_heat.c     **** 					printf("Startup %i ", startup);
 562:ir_heat.c     **** 					startup--;
 563:ir_heat.c     **** 					temp = get_temperature(ADR_T_OBJ1);
 564:ir_heat.c     **** 					slope = 0;
 565:ir_heat.c     **** 				}
 566:ir_heat.c     ****    	   	printf("Temp: %i, ", temp);
 567:ir_heat.c     ****    	   	add_value(temp);									// Neue Temperatur zu Array hinzufügen
 568:ir_heat.c     ****    	   	slope_raw = get_slope();						// Aktuelle Steigung ermitteln
 569:ir_heat.c     ****    	   	if (slope_raw < -100) slope_raw = -100;
 570:ir_heat.c     ****    	   	
 571:ir_heat.c     ****    	   	factor = (temp - 620) / -25;					// Fakort ermitteln
 572:ir_heat.c     ****    	   	temp_a = get_temperature(ADR_T_A);
 573:ir_heat.c     ****    	   	//factor = (temp - 900 + 2*temp_a ) / -25;					// Fakort ermitteln
 574:ir_heat.c     ****    	   	if(factor < 0) factor = 0;
 575:ir_heat.c     ****    	   	   	   	
 576:ir_heat.c     **** 				if(slope_raw > factor) { 						// "Steigungsintegral"
 577:ir_heat.c     **** 					integral = 8*(integral + slope_raw) / factor;
 578:ir_heat.c     **** 					if(integral > 2000) integral = 2000;
 579:ir_heat.c     **** 				}
 580:ir_heat.c     **** 				else {
 581:ir_heat.c     **** 					integral = integral / 4;
 582:ir_heat.c     **** 				}
 583:ir_heat.c     **** 				
 584:ir_heat.c     **** //				slope = (31*slope + 10*slope_raw)/32; 		// Steigung dämpfen
 585:ir_heat.c     **** 
 586:ir_heat.c     **** 				
 587:ir_heat.c     **** 				if(slope_raw < -10) slope_raw = -10;
 588:ir_heat.c     **** 				if(slope_raw<0) {									// Fallende Temperaturen werden stärker gewichtet
 589:ir_heat.c     **** 	   	   	slope = (3*slope + 10*slope_raw)/4;		// Negative Steigung wird mit einer Dämpfung von 8 ge
 590:ir_heat.c     **** 				}
 591:ir_heat.c     **** 				else {
 592:ir_heat.c     **** 	   	   	slope = (31*slope + 10*slope_raw)/32;	// Positive Steigung wird mit einer Dämpfung von 16 
 593:ir_heat.c     **** 	   	   }
 594:ir_heat.c     **** 	   	
 595:ir_heat.c     **** 	   		slope_std = exp_slope(temp) + fx;
 596:ir_heat.c     **** 	   		slope_real = get_slope2();
 597:ir_heat.c     **** 	   	
 598:ir_heat.c     **** /*
 599:ir_heat.c     ****    	   	printf("slope_raw: %i, slope: %i ", slope_raw, slope);
 600:ir_heat.c     ****      	   	printf("Ambient: %i\n", get_temperature(ADR_T_A));
 601:ir_heat.c     **** */				
 602:ir_heat.c     **** 
 603:ir_heat.c     **** 				// temp_a 150 -> 45
 604:ir_heat.c     **** 				// temp_a 100 -> 60
 605:ir_heat.c     **** //   	   	max_slope = temp_a * -1.3 + 240;
 606:ir_heat.c     **** //   	   	max_slope = max_slope * (600-temp)/50;
 607:ir_heat.c     **** 				max_slope = (float)temp * -0.8 + 360;
 608:ir_heat.c     **** 
 609:ir_heat.c     **** //   	   	printf("sl_raw: %i, sl: %i, s_max: %i, f: %i, int: %i t_a: %i\n", slope_raw, slope, max_s
 610:ir_heat.c     ****    	   	printf("exp_s: %i, s2: %i, fx: %i\n", slope_std, slope_real, fx);
 611:ir_heat.c     **** 
 612:ir_heat.c     **** //				if((slope > max_slope) || (integral > 500)) {
 613:ir_heat.c     **** 				if(slope_real > slope_std) {
 614:ir_heat.c     **** 					on_counter++;
 615:ir_heat.c     **** 		   		printf("On-Counter: %i; \n", on_counter);
 616:ir_heat.c     **** 	   			if(mode == MODE_ON_NO_PROT){
 617:ir_heat.c     **** 						//on_counter++;
 618:ir_heat.c     **** 	   				if(on_counter==3){
 619:ir_heat.c     **** 	   					beep(BEEP_SHORT);
 620:ir_heat.c     **** 	   					on_counter = 0;
 621:ir_heat.c     **** 	   				}
 622:ir_heat.c     ****   					}
 623:ir_heat.c     ****    				else {
 624:ir_heat.c     ****    					if(get_last_slope() > 0) {
 625:ir_heat.c     **** 							//on_counter++;
 626:ir_heat.c     **** 			   			if((on_counter > 8) || (temp > 520)) {
 627:ir_heat.c     ****    							off_counter = OFF_COUNTER+1;
 628:ir_heat.c     ****    							on_counter = 0;
 629:ir_heat.c     ****    							if(mode == MODE_ON) {
 630:ir_heat.c     **** 	   							beep(BEEP_XLONG);
 631:ir_heat.c     ****    								if(temp<500) {
 632:ir_heat.c     ****    									fx = fx+20;
 633:ir_heat.c     ****    								}
 634:ir_heat.c     ****    							}
 635:ir_heat.c     **** 		   				}
 636:ir_heat.c     **** 		   				else {
 637:ir_heat.c     **** 		   					if( ((on_counter > 4) && ((on_counter % 2) == 1)) || (temp > 500) ) {
 638:ir_heat.c     **** 		   						beep(BEEP_LONG);
 639:ir_heat.c     **** 		   					}
 640:ir_heat.c     ****    						}
 641:ir_heat.c     ****    					}
 642:ir_heat.c     ****    					else {
 643:ir_heat.c     ****    						if(slope_raw<0) on_counter=0;
 644:ir_heat.c     ****    					}
 645:ir_heat.c     ****    				}
 646:ir_heat.c     **** 				}			
 647:ir_heat.c     **** 				else {
 648:ir_heat.c     **** 					on_counter = 0;
 649:ir_heat.c     **** 				}					
 650:ir_heat.c     ****    	   }
 651:ir_heat.c     **** 
 652:ir_heat.c     ****    		if(off_counter) {
 653:ir_heat.c     ****    			// Protection Counter läuft
 654:ir_heat.c     ****   				off_counter--;
 655:ir_heat.c     ****   				if(mode == MODE_ON) mode = MODE_TEMP_PROT;
 656:ir_heat.c     **** 				printf("Off-Counter: %i; \n", off_counter);
 657:ir_heat.c     ****    		}
 658:ir_heat.c     ****    		else {
 659:ir_heat.c     ****    			if(mode == MODE_TEMP_PROT) {
 660:ir_heat.c     ****    				slope = 0;
 661:ir_heat.c     ****    				integral = 0;
 662:ir_heat.c     ****    				mode = MODE_OFF;
 663:ir_heat.c     ****    			}
 664:ir_heat.c     ****    		}
 665:ir_heat.c     **** 		}
 666:ir_heat.c     **** 		else if(interval != last_interval) {
 667:ir_heat.c     **** 			// In jedem Interval 1x die Temperatur abrufen
 668:ir_heat.c     **** 			// und für den Mittelwert aufsummieren
 669:ir_heat.c     ****    		last_interval = interval;
 670:ir_heat.c     ****     		if(count<16) {
 671:ir_heat.c     **** 	   		count++;
 672:ir_heat.c     ****    			// Messwerte für den Mittelwert aufsummieren
 673:ir_heat.c     ****    			temp_sum += get_temperature(ADR_T_OBJ1);
 674:ir_heat.c     ****    		}
 675:ir_heat.c     ****    	}
 676:ir_heat.c     **** 
 677:ir_heat.c     **** 		// Je nach Mode Relais und LEDs setzen
 678:ir_heat.c     **** 		switch(mode) {
 679:ir_heat.c     **** 		case MODE_OFF:
 680:ir_heat.c     **** 			set_relais(0);
 681:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 1858               	all __divmodhi4
 1859               		mov r24,r22
 1860 0878 0F2E      		mov r25,r23
 1861 087a FBE2      		std Y+4,r25
 1862 087c AF2E      		std Y+3,r24
 1864 0880 F02D      	.LM198:
 1865               		sts interval,__zero_reg__
 1867 0882 2224      	.LM199:
 1868 0884 3324      		or r24,r25
 1869               		brne .L92
 1871               	.LM200:
 1872               		rcall .
 1873               		ldi r24,lo8(.LC7)
 1874               		ldi r25,hi8(.LC7)
 1875               		in r30,__SP_L__
 1876               		in r31,__SP_H__
 1877 0886 0F2E      		std Z+2,r25
 1878 0888 F8EA      		std Z+1,r24
 1879 088a 4F2E      		call printf
 1880 088c F1E6      		pop __tmp_reg__
 1881 088e 5F2E      		pop __tmp_reg__
 1882 0890 F02D      		rjmp .L93
 1883               	.L92:
 1885               	.LM201:
 1886               		tst r6
 1887               		breq .L94
 1889               	.LM202:
 1890               		rcall .
 1891               		rcall .
 1892 0892 4091 0000 		in r30,__SP_L__
 1893 0896 4031      		in r31,__SP_H__
 1894 0898 04F4      		adiw r30,1
 1895 089a 00C0      		ldi r24,lo8(.LC8)
 1896               		ldi r25,hi8(.LC8)
 1897               		std Z+1,r25
 1898               		st Z,r24
 1899               		std Z+2,r6
 1900 089c A895      		std Z+3,__zero_reg__
 1901               		call printf
 1903               	.LM203:
 1904               		dec r6
 1906 08a0 602F      	.LM204:
 1907 08a2 70E0      		pop __tmp_reg__
 1908 08a4 0E94 0000 		pop __tmp_reg__
 1909 08a8 862F      		pop __tmp_reg__
 1910 08aa 972F      		pop __tmp_reg__
 1911 08ac 9C83      		ldi r24,lo8(7)
 1912 08ae 8B83      		call get_temperature
 1913               		std Y+4,r25
 1914               		std Y+3,r24
 1915 08b0 1092 0000 	.L94:
 1917               	.LM205:
 1918 08b4 892B      		rcall .
 1919 08b6 01F4      		rcall .
 1920               		in r30,__SP_L__
 1921               		in r31,__SP_H__
 1922 08b8 00D0      		adiw r30,1
 1923 08ba 80E0      		ldi r24,lo8(.LC9)
 1924 08bc 90E0      		ldi r25,hi8(.LC9)
 1925 08be EDB7      		std Z+1,r25
 1926 08c0 FEB7      		st Z,r24
 1927 08c2 9283      		ldd r24,Y+3
 1928 08c4 8183      		ldd r25,Y+4
 1929 08c6 0E94 0000 		std Z+3,r25
 1930 08ca 0F90      		std Z+2,r24
 1931 08cc 0F90      		call printf
 1933               	.LM206:
 1934               		pop __tmp_reg__
 1935               		pop __tmp_reg__
 1936 08d0 6620      		pop __tmp_reg__
 1937 08d2 01F0      		pop __tmp_reg__
 1938               		ldd r24,Y+3
 1939               		ldd r25,Y+4
 1940 08d4 00D0      		call add_value
 1942 08d8 EDB7      	.LM207:
 1943 08da FEB7      		call get_slope
 1944 08dc 3196      		movw r8,r24
 1946 08e0 90E0      	.LM208:
 1947 08e2 9183      		ldi r24,lo8(6)
 1948 08e4 8083      		call get_temperature
 1950 08e8 1382      	.LM209:
 1951 08ea 0E94 0000 		ldd r24,Y+3
 1952               		ldd r25,Y+4
 1953               		call exp_slope
 1954 08ee 6A94      		ldd r30,Y+1
 1955               		mov r16,r30
 1956               		clr r17
 1957 08f0 0F90      		sbrc r16,7
 1958 08f2 0F90      		com r17
 1959 08f4 0F90      		movw r12,r16
 1960 08f6 0F90      		add r12,r24
 1961 08f8 87E0      		adc r13,r25
 1963 08fe 9C83      	.LM210:
 1964 0900 8B83      		call get_slope2
 1965               		movw r14,r24
 1967               	.LM211:
 1968 0902 00D0      		in r24,__SP_L__
 1969 0904 00D0      		in r25,__SP_H__
 1970 0906 EDB7      		sbiw r24,8
 1971 0908 FEB7      		in __tmp_reg__,__SREG__
 1972 090a 3196      		cli
 1973 090c 80E0      		out __SP_H__,r25
 1974 090e 90E0      		out __SREG__,__tmp_reg__
 1975 0910 9183      		out __SP_L__,r24
 1976 0912 8083      		in r30,__SP_L__
 1977 0914 8B81      		in r31,__SP_H__
 1978 0916 9C81      		adiw r30,1
 1979 0918 9383      		ldi r24,lo8(.LC10)
 1980 091a 8283      		ldi r25,hi8(.LC10)
 1981 091c 0E94 0000 		std Z+1,r25
 1982               		st Z,r24
 1983               		std Z+3,r13
 1984 0920 0F90      		std Z+2,r12
 1985 0922 0F90      		std Z+5,r15
 1986 0924 0F90      		std Z+4,r14
 1987 0926 0F90      		std Z+7,r17
 1988 0928 8B81      		std Z+6,r16
 1989 092a 9C81      		call printf
 1991               	.LM212:
 1992               		in r30,__SP_L__
 1993 0930 0E94 0000 		in r31,__SP_H__
 1994 0934 4C01      		adiw r30,8
 1995               		in __tmp_reg__,__SREG__
 1996               		cli
 1997 0936 86E0      		out __SP_H__,r31
 1998 0938 0E94 0000 		out __SREG__,__tmp_reg__
 1999               		out __SP_L__,r30
 2000               		cp r12,r14
 2001 093c 8B81      		cpc r13,r15
 2002 093e 9C81      		brlt .+2
 2003 0940 0E94 0000 		rjmp .L95
 2005 0946 0E2F      	.LM213:
 2006 0948 1127      		inc r7
 2008 094c 1095      	.LM214:
 2009 094e 6801      		rcall .
 2010 0950 C80E      		rcall .
 2011 0952 D91E      		in r30,__SP_L__
 2012               		in r31,__SP_H__
 2013               		adiw r30,1
 2014 0954 0E94 0000 		ldi r24,lo8(.LC11)
 2015 0958 7C01      		ldi r25,hi8(.LC11)
 2016               		std Z+1,r25
 2017               		st Z,r24
 2018 095a 8DB7      		std Z+2,r7
 2019 095c 9EB7      		std Z+3,__zero_reg__
 2020 095e 0897      		call printf
 2022 0962 F894      	.LM215:
 2023 0964 9EBF      		pop __tmp_reg__
 2024 0966 0FBE      		pop __tmp_reg__
 2025 0968 8DBF      		pop __tmp_reg__
 2026 096a EDB7      		pop __tmp_reg__
 2027 096c FEB7      		lds r24,mode
 2028 096e 3196      		cpi r24,lo8(2)
 2029 0970 80E0      		brne .L96
 2031 0974 9183      	.LM216:
 2032 0976 8083      		ldi r25,lo8(3)
 2033 0978 D382      		cp r7,r25
 2034 097a C282      		brne .L93
 2036 097e E482      	.LM217:
 2037 0980 1783      		ldi r24,lo8(1)
 2038 0982 0683      		call beep
 2039 0984 0E94 0000 		clr r7
 2040               		rjmp .L93
 2041               	.L96:
 2043 098a FEB7      	.LM218:
 2044 098c 3896      		call get_last_slope
 2045 098e 0FB6      		cp __zero_reg__,r24
 2046 0990 F894      		cpc __zero_reg__,r25
 2047 0992 FEBF      		brge .L97
 2049 0996 EDBF      	.LM219:
 2050 0998 CE14      		ldi r30,lo8(8)
 2051 099a DF04      		cp r30,r7
 2052 099c 04F0      		brlo .L98
 2053 099e 00C0      		ldd r24,Y+3
 2054               		ldd r25,Y+4
 2055               		subi r24,lo8(521)
 2056 09a0 7394      		sbci r25,hi8(521)
 2057               		brlt .L99
 2058               	.L98:
 2060 09a4 00D0      	.LM220:
 2061 09a6 EDB7      		ldi r31,lo8(3)
 2062 09a8 FEB7      		sts off_counter,r31
 2064 09ac 80E0      	.LM221:
 2065 09ae 90E0      		lds r24,mode
 2066 09b0 9183      		cpi r24,lo8(1)
 2067 09b2 8083      		breq .L100
 2068 09b4 7282      		clr r7
 2069 09b6 1382      		ldi r24,lo8(3)
 2070 09b8 0E94 0000 		rjmp .L101
 2071               	.L100:
 2073 09bc 0F90      	.LM222:
 2074 09be 0F90      		ldi r24,lo8(4)
 2075 09c0 0F90      		call beep
 2077 09c4 8091 0000 	.LM223:
 2078 09c8 8230      		ldd r24,Y+3
 2079 09ca 01F4      		ldd r25,Y+4
 2080               		subi r24,lo8(500)
 2081               		sbci r25,hi8(500)
 2082 09cc 93E0      		brge .L95
 2084 09d0 01F4      	.LM224:
 2085               		ldd r31,Y+1
 2086               		subi r31,lo8(-(20))
 2087 09d2 81E0      		std Y+1,r31
 2088 09d4 0E94 0000 		clr r7
 2089 09d8 7724      		rjmp .L93
 2090 09da 00C0      	.L99:
 2092               	.LM225:
 2093               		ldi r18,lo8(4)
 2094 09dc 0E94 0000 		cp r18,r7
 2095 09e0 1816      		brsh .L102
 2096 09e2 1906      		sbrc r7,0
 2097 09e4 04F4      		rjmp .L103
 2098               	.L102:
 2099               		ldd r24,Y+3
 2100 09e6 E8E0      		ldd r25,Y+4
 2101 09e8 E715      		subi r24,lo8(501)
 2102 09ea 00F0      		sbci r25,hi8(501)
 2103 09ec 8B81      		brlt .L93
 2104 09ee 9C81      	.L103:
 2106 09f2 9240      	.LM226:
 2107 09f4 04F0      		ldi r24,lo8(3)
 2108               		call beep
 2109               		rjmp .L93
 2110               	.L97:
 2112 09f8 F093 0000 	.LM227:
 2113               		tst r9
 2114               		brge .L93
 2115 09fc 8091 0000 	.L95:
 2116 0a00 8130      		clr r7
 2117 0a02 01F0      	.L93:
 2119 0a06 83E0      	.LM228:
 2120 0a08 00C0      		lds r24,off_counter
 2121               		tst r24
 2122               		breq .L104
 2123               	.L101:
 2125 0a0c 0E94 0000 	.LM229:
 2126               		subi r24,lo8(-(-1))
 2127               		sts off_counter,r24
 2129 0a12 9C81      	.LM230:
 2130 0a14 845F      		lds r24,mode
 2131 0a16 9140      		cpi r24,lo8(1)
 2132 0a18 04F4      		brne .L105
 2133               		ldi r31,lo8(3)
 2134               		sts mode,r31
 2135 0a1a F981      	.L105:
 2137 0a1e F983      	.LM231:
 2138 0a20 7724      		rcall .
 2139 0a22 00C0      		rcall .
 2140               		in r30,__SP_L__
 2141               		in r31,__SP_H__
 2142               		adiw r30,1
 2143 0a24 24E0      		ldi r24,lo8(.LC12)
 2144 0a26 2715      		ldi r25,hi8(.LC12)
 2145 0a28 00F4      		std Z+1,r25
 2146 0a2a 70FC      		st Z,r24
 2147 0a2c 00C0      		lds r24,off_counter
 2148               		std Z+2,r24
 2149 0a2e 8B81      		std Z+3,__zero_reg__
 2150 0a30 9C81      		call printf
 2151 0a32 855F      		movw r8,r2
 2152 0a34 9140      		ldi r16,lo8(0)
 2153 0a36 04F0      		pop __tmp_reg__
 2154               		pop __tmp_reg__
 2155               		pop __tmp_reg__
 2156               		pop __tmp_reg__
 2157 0a38 83E0      		rjmp .L106
 2158 0a3a 0E94 0000 	.L104:
 2160               	.LM232:
 2161               		lds r24,mode
 2162               		cpi r24,lo8(3)
 2163 0a40 9920      		breq .L107
 2164 0a42 04F4      		movw r8,r2
 2165               		ldi r16,lo8(0)
 2166 0a44 7724      		rjmp .L106
 2167               	.L107:
 2169               	.LM233:
 2170 0a46 8091 0000 		sts mode,__zero_reg__
 2171 0a4a 8823      		movw r8,r2
 2172 0a4c 01F0      		ldi r16,lo8(0)
 2173               		rjmp .L108
 2174               	.L91:
 2176 0a4e 8150      	.LM234:
 2177 0a50 8093 0000 		mov r18,r20
 2178               		clr r19
 2179               		sbrc r18,7
 2180 0a54 8091 0000 		com r19
 2181 0a58 8130      		ldd r30,Y+2
 2182 0a5a 01F4      		mov r24,r30
 2183 0a5c F3E0      		ldi r25,lo8(0)
 2184 0a5e F093 0000 		cp r18,r24
 2185               		cpc r19,r25
 2186               		breq .L106
 2188 0a62 00D0      	.LM235:
 2189 0a64 00D0      		std Y+2,r20
 2191 0a68 FEB7      	.LM236:
 2192 0a6a 3196      		cpi r16,lo8(16)
 2193 0a6c 80E0      		brsh .L106
 2195 0a70 9183      	.LM237:
 2196 0a72 8083      		subi r16,lo8(-(1))
 2198 0a78 8283      	.LM238:
 2199 0a7a 1382      		ldi r24,lo8(7)
 2200 0a7c 0E94 0000 		call get_temperature
 2201 0a80 4101      		add r8,r24
 2202 0a82 00E0      		adc r9,r25
 2203 0a84 0F90      	.L106:
 2205 0a88 0F90      	.LM239:
 2206 0a8a 0F90      		lds r24,mode
 2207 0a8c 00C0      		cpi r24,lo8(1)
 2208               		breq .L110
 2209               		cpi r24,lo8(1)
 2210               		brlo .L108
 2211 0a8e 8091 0000 		cpi r24,lo8(2)
 2212 0a92 8330      		breq .L111
 2213 0a94 01F0      		cpi r24,lo8(3)
 2214 0a96 4101      		brne .L116
 2215 0a98 00E0      		rjmp .L117
 2216 0a9a 00C0      	.L108:
 2218               	.LM240:
 2219               		ldi r24,lo8(0)
 2220 0a9c 1092 0000 		call set_relais
 2222 0aa2 00E0      	.LM241:
 2223 0aa4 00C0      		movw r30,r10
 2224               		ld r24,Z
 2225               		ori r24,lo8(16)
 2226               		st Z,r24
 2228 0aa8 3327      	.LM242:
 2229 0aaa 27FD      		ld r24,Z
 2230 0aac 3095      		andi r24,lo8(-9)
 2231 0aae EA81      		st Z,r24
 2233 0ab2 90E0      	.LM243:
 2234 0ab4 2817      		sts off_counter,__zero_reg__
 2235 0ab6 3907      		clr r7
 2236 0ab8 01F0      		rjmp .L113
 2237               	.L110:
 2239 0aba 4A83      	.LM244:
 2240               		movw r30,r10
 2241               		ld r24,Z
 2242 0abc 0031      		ori r24,lo8(16)
 2243 0abe 00F4      		st Z,r24
 2244               	.L111:
 2246 0ac0 0F5F      	.LM245:
 2247               		ldi r24,lo8(1)
 2248               		call set_relais
 2250 0ac4 0E94 0000 	.LM246:
 2251 0ac8 880E      		movw r30,r10
 2252 0aca 991E      		ld r24,Z
 2253               		ori r24,lo8(8)
 2254               		st Z,r24
 2255               		rjmp .L113
 2256 0acc 8091 0000 	.L117:
 2258 0ad2 01F0      	.LM247:
 2259 0ad4 8130      		ldi r24,lo8(0)
 2260 0ad6 00F0      		call set_relais
 2262 0ada 01F0      	.LM248:
 2263 0adc 8330      		movw r30,r10
 2264 0ade 01F4      		ld r24,Z
 2265 0ae0 00C0      		andi r24,lo8(-17)
 2266               		st Z,r24
 2268               	.LM249:
 2269 0ae2 80E0      		ld r24,Z
 2270 0ae4 0E94 0000 		ori r24,lo8(8)
 2271               		st Z,r24
 2272               		rjmp .L113
 2273 0ae8 F501      	.L116:
 2275 0aec 8061      	.LM250:
 2276 0aee 8083      		sts mode,__zero_reg__
 682:ir_heat.c     **** 			STATUS_LED2_OFF;
 2277               	1-.LFBB22
 2278               	.LM251:
 2279 0af0 8081      		movw r24,r4
 2280 0af2 877F      	/* #APP */
 2281 0af4 8083      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 683:ir_heat.c     **** 			off_counter = 0;
 2282               	r24,r4
 2283               	/* #APP */
 2284 0af6 1092 0000 	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 2285 0afa 7724      		1: sbiw r24,1
 2286 0afc 00C0      		brne 1b
 2287               	 ;  0 "" 2
 684:ir_heat.c     **** 			on_counter = 0;
 685:ir_heat.c     **** 			break;
 686:ir_heat.c     **** 		case MODE_ON:
 687:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 2288               	ib/gcc/../../avr/include/util/delay_basic.h" 1
 2289               		1: sbiw r24,1
 2290 0afe F501      		brne 1b
 2291 0b00 8081      	 ;  0 "" 2
 2292 0b02 8061      	/* #NOAPP */
 2293 0b04 8083      		rjmp .L114
 2294               	.LBE60:
 688:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 689:ir_heat.c     **** 			set_relais(1);
 2295               	basic.h" 1
 2296               		1: sbiw r24,1
 2297 0b06 81E0      		brne 1b
 2298 0b08 0E94 0000 	 ;  0 "" 2
 690:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2299               	ib/gcc/../../avr/include/util/delay_basic.h" 1
 2300               		1: sbiw r24,1
 2301 0b0c F501      		brne 1b
 2302 0b0e 8081      	 ;  0 "" 2
 2303 0b10 8860      	/* #NOAPP */
 2304 0b12 8083      		rjmp .L114
 2305 0b14 00C0      	.LBE60:
 2306               	.LBE61:
 691:ir_heat.c     **** 			break;
 692:ir_heat.c     **** 		case MODE_TEMP_PROT:
 693:ir_heat.c     **** 			set_relais(0);
 2307               	1
 2308               		1: sbiw r24,1
 2309 0b16 80E0      		brne 1b
 2310 0b18 0E94 0000 	 ;  0 "" 2
 694:ir_heat.c     **** 			STATUS_LED1_OFF;
 2311               	ib/gcc/../../avr/include/util/delay_basic.h" 1
 2312               		1: sbiw r24,1
 2313 0b1c F501      		brne 1b
 2314 0b1e 8081      	 ;  0 "" 2
 2315 0b20 8F7E      	/* #NOAPP */
 2316 0b22 8083      		rjmp .L114
 695:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2317               	il/delay_basic.h" 1
 2318               		1: sbiw r24,1
 2319 0b24 8081      		brne 1b
 2320 0b26 8860      	 ;  0 "" 2
 2321 0b28 8083      	/* #NOAPP */
 2322 0b2a 00C0      		rjmp .L114
 2323               	.LBE60:
 696:ir_heat.c     **** 			slope = 0;
 697:ir_heat.c     **** 			integral = 0;
 698:ir_heat.c     **** 			break;
 699:ir_heat.c     **** 		default:
 700:ir_heat.c     **** 			mode = MODE_OFF;
 2324               	basic.h" 1
 2325               		1: sbiw r24,1
 2326 0b2c 1092 0000 		brne 1b
 2327               	 ;  0 "" 2
 2328               	/* #NOAPP */
 2329               		rjmp .L114
 2330               	.LBE60:
 2331               	.LBE61:
 2332               	.LBE62:
 2333               	.LBE63:
 2347               	.Lscope22:
 2348               	.global	interval
 2349               		.data
 2352               	interval:
 2353               		.byte	-12
 2354               	.global	off_counter
 2355               	.global	off_counter
 2356               		.section .bss
 2359               	off_counter:
 2360               		.skip 1,0
 2361               	.global	flash_button
 2362               	.global	flash_button
 2365               	flash_button:
 2366               		.skip 1,0
 2367 00b6 F4        	.global	flash_LED
 2368               	.global	flash_LED
 2371               	flash_LED:
 2372               		.skip 1,0
 2373               		.lcomm last.2001,1
 2374 0000 00        		.lcomm last_slope.1889,2
 2375               		.lcomm running.1757,1
 2376               		.lcomm c2.1731,1
 2377               		.lcomm c1.1730,1
 2378               		.comm tbuf,32,1
 2379               		.comm rbuf,32,1
 2380 0001 00        		.comm t_in,1,1
 2381               		.comm t_out,1,1
 2382               		.comm r_in,1,1
 2383               		.comm r_out,1,1
 2384               		.comm t_array,12,1
 2385               		.comm mode,1,1
 2386 0002 00        		.comm slope2,2,1
 2405               		.text
 2407               	.Letext0:
 2408               	.global __do_copy_data
 2409               	.global __do_clear_bss
 2410               	...
DEFINED SYMBOLS
                            *ABS*:00000000 ir_heat.c
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:2      *ABS*:0000003f __SREG__
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:3      *ABS*:0000003e __SP_H__
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:4      *ABS*:0000003d __SP_L__
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:5      *ABS*:00000034 __CCP__
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:89     .text:00000000 __vector_9
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:2366   .data:000000b6 interval
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:120    .text:00000022 __vector_13
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:153    .text:00000042 __vector_16
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:2390   .bss:00000008 c1.1730
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:2389   .bss:00000007 c2.1731
                            *COM*:00000001 mode
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:274    .text:000000de __vector_18
                            *COM*:00000001 r_in
                            *COM*:00000020 rbuf
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:324    .text:0000011c __vector_19
                            *COM*:00000001 t_in
                            *COM*:00000001 t_out
                            *COM*:00000020 tbuf
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:387    .text:00000176 tbuflen
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:409    .text:00000182 UART_putchar
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:466    .text:000001ce rbuflen
                            *COM*:00000001 r_out
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:487    .text:000001da UART_getchar
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:527    .text:00000200 exp_slope
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:576    .text:00000240 get_slope2
                            *COM*:0000000c t_array
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:2387   .bss:00000004 last_slope.1889
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:621    .text:00000286 add_value
                            *COM*:00000002 slope2
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:736    .text:0000034c get_slope
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:813    .text:000003cc get_last_slope
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:839    .text:000003e6 _beep
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:915    .text:00000424 beep
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:1062   .text:00000498 set_relais
                             .bss:00000003 last.2001
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:1131   .text:000004de __vector_1
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:2388   .bss:00000006 running.1757
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:1397   .text:00000610 get_temperature
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:1493   .text:0000067c print_array
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:1631   .text:00000778 UART_first_init
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:1690   .text:000007a0 main
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:2373   .bss:00000000 off_counter
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:2379   .bss:00000001 flash_button
C:\Users\Thorsten\AppData\Local\Temp/cc5mI4VL.s:2385   .bss:00000002 flash_LED

UNDEFINED SYMBOLS
__divmodhi4
__udivmodhi4
puts
i2c_start
i2c_write
i2c_rep_start
i2c_read_ack
i2c_stop
printf
putchar
fdevopen
i2c_init
__do_copy_data
__do_clear_bss
