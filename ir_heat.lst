   1               		.file	"ir_heat.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  86               	.global	interval
  87               		.data
  90               	interval:
  91 0000 F4        		.byte	-12
  92               	.global	off_counter
  93               	.global	off_counter
  94               		.section .bss
  97               	off_counter:
  98 0000 00        		.skip 1,0
  99               		.text
 101               	.global	__vector_9
 103               	__vector_9:
   1:ir_heat.c     **** // ***********************************************************
   2:ir_heat.c     **** // Project:
   3:ir_heat.c     **** // Author:
   4:ir_heat.c     **** // Module description:
   5:ir_heat.c     **** // ***********************************************************
   6:ir_heat.c     **** 
   7:ir_heat.c     **** #ifndef F_CPU
   8:ir_heat.c     **** #define F_CPU 1000000UL
   9:ir_heat.c     **** #endif
  10:ir_heat.c     **** 
  11:ir_heat.c     **** #include <avr\io.h>              // Most basic include files
  12:ir_heat.c     **** #include <avr\interrupt.h>       // Add the necessary ones
  13:ir_heat.c     **** #include <avr\signal.h>          // here
  14:ir_heat.c     **** #include <avr\wdt.h>
  15:ir_heat.c     **** 
  16:ir_heat.c     **** #include <stdio.h>
  17:ir_heat.c     **** #include <string.h>
  18:ir_heat.c     **** #include <stdlib.h>
  19:ir_heat.c     **** 
  20:ir_heat.c     **** #include "i2c_mstr.h"
  21:ir_heat.c     **** #include "ir_heat.h"
  22:ir_heat.c     **** 
  23:ir_heat.c     **** #define 	MLX90614_WRITE	(0x5A<<1)
  24:ir_heat.c     **** #define 	MLX90614_READ	(MLX90614_WRITE+1)
  25:ir_heat.c     **** #define	ADR_T_A			0x06
  26:ir_heat.c     **** #define	ADR_T_OBJ1		0x07
  27:ir_heat.c     **** #define	ADR_T_OBJ2		0x08
  28:ir_heat.c     **** 
  29:ir_heat.c     **** 
  30:ir_heat.c     **** #define __STDIO_FDEVOPEN_COMPAT_12						
  31:ir_heat.c     **** // Buffer sizes must be 2^n
  32:ir_heat.c     **** //
  33:ir_heat.c     **** #define TBUFSIZE			32
  34:ir_heat.c     **** #define RBUFSIZE			32
  35:ir_heat.c     **** 
  36:ir_heat.c     **** #define TMASK				(TBUFSIZE-1)
  37:ir_heat.c     **** #define RMASK				(RBUFSIZE-1)
  38:ir_heat.c     **** 
  39:ir_heat.c     **** #define FLASH_LED			PC3
  40:ir_heat.c     **** #define STATUS_LED1		PD4
  41:ir_heat.c     **** #define STATUS_LED2		PD3
  42:ir_heat.c     **** #define RELAIS				PB6
  43:ir_heat.c     **** #define BUZZER				PB7
  44:ir_heat.c     **** #define SWITCH				PD2
  45:ir_heat.c     **** 
  46:ir_heat.c     **** #define RELAIS_ON			PORTB |= (1<<RELAIS)
  47:ir_heat.c     **** #define RELAIS_OFF		PORTB &=~(1<<RELAIS)
  48:ir_heat.c     **** 
  49:ir_heat.c     **** #define BUZZER_ON			PORTB |= (1<<BUZZER)
  50:ir_heat.c     **** #define BUZZER_OFF		PORTB &=~(1<<BUZZER)
  51:ir_heat.c     **** 
  52:ir_heat.c     **** #define STATUS_LED1_ON	PORTD |= (1<<STATUS_LED1)
  53:ir_heat.c     **** #define STATUS_LED1_OFF	PORTD &=~(1<<STATUS_LED1)
  54:ir_heat.c     **** 
  55:ir_heat.c     **** #define FLASH_LED_ON		PORTC |= (1<<FLASH_LED)
  56:ir_heat.c     **** #define FLASH_LED_OFF	PORTC &=~(1<<FLASH_LED)
  57:ir_heat.c     **** 
  58:ir_heat.c     **** #define STATUS_LED2_ON	PORTD |= (1<<STATUS_LED2)
  59:ir_heat.c     **** #define STATUS_LED2_OFF	PORTD &=~(1<<STATUS_LED2)
  60:ir_heat.c     **** 
  61:ir_heat.c     **** #define OFF_COUNTER		2
  62:ir_heat.c     **** 
  63:ir_heat.c     **** #define TIMER1_STOP		TCCR1B = 0
  64:ir_heat.c     **** #define TIMER1_RUN		TCCR1B = (0<<CS12) | (1<<CS11) | (0<<CS10)
  65:ir_heat.c     **** 
  66:ir_heat.c     **** #define	MODE_OFF			0
  67:ir_heat.c     **** #define	MODE_ON			1
  68:ir_heat.c     **** #define	MODE_TEMP_PROT	3
  69:ir_heat.c     **** 
  70:ir_heat.c     **** // Define here the global static variables
  71:ir_heat.c     **** //
  72:ir_heat.c     **** volatile unsigned char tbuf[TBUFSIZE];  // TX buffer
  73:ir_heat.c     **** volatile unsigned char rbuf[RBUFSIZE];  // RX buffer
  74:ir_heat.c     **** 
  75:ir_heat.c     **** volatile unsigned char t_in;            // TX buffer in index
  76:ir_heat.c     **** volatile unsigned char t_out;           // TX buffer out index
  77:ir_heat.c     **** 
  78:ir_heat.c     **** volatile unsigned char r_in;            // RX buffer in index
  79:ir_heat.c     **** volatile unsigned char r_out;           // RX buffer out index
  80:ir_heat.c     **** 
  81:ir_heat.c     **** int8_t	interval = -12;
  82:ir_heat.c     **** int16_t 	t_array[6];
  83:ir_heat.c     **** uint8_t	off_counter = 0;
  84:ir_heat.c     **** uint8_t	mode;
  85:ir_heat.c     **** int16_t	slope2;
  86:ir_heat.c     **** 
  87:ir_heat.c     **** /*
  88:ir_heat.c     **** uint16_t	t_la_threshold_up 	=  300;
  89:ir_heat.c     **** uint16_t	t_abs_threshold_up 	=  270;
  90:ir_heat.c     **** uint16_t	t_la_threshold_down 	=  250;
  91:ir_heat.c     **** uint16_t	t_abs_threshold_down	=  250;
  92:ir_heat.c     **** */
  93:ir_heat.c     **** 
  94:ir_heat.c     **** 
  95:ir_heat.c     **** // Clock Timer
  96:ir_heat.c     **** SIGNAL(SIG_OVERFLOW2) {
 104               	8,0,96,.LM0-.LFBB1
 105               	.LM0:
 106               	.LFBB1:
 107 0000 1F92      		push __zero_reg__
 108 0002 0F92      		push r0
 109 0004 0FB6      		in r0,__SREG__
 110 0006 0F92      		push r0
 111 0008 1124      		clr __zero_reg__
 112 000a 8F93      		push r24
 113 000c DF93      		push r29
 114 000e CF93      		push r28
 115 0010 CDB7      		in r28,__SP_L__
 116 0012 DEB7      		in r29,__SP_H__
 117               	/* prologue: Signal */
 118               	/* frame size = 0 */
  97:ir_heat.c     **** 	interval++;
 119               	,.LM1-.LFBB1
 120               	.LM1:
 121 0014 8091 0000 		lds r24,interval
 122 0018 8F5F      		subi r24,lo8(-(1))
 123 001a 8093 0000 		sts interval,r24
 124               	/* epilogue start */
  98:ir_heat.c     **** }
 125               	n	68,0,98,.LM2-.LFBB1
 126               	.LM2:
 127 001e CF91      		pop r28
 128 0020 DF91      		pop r29
 129 0022 8F91      		pop r24
 130 0024 0F90      		pop r0
 131 0026 0FBE      		out __SREG__,r0
 132 0028 0F90      		pop r0
 133 002a 1F90      		pop __zero_reg__
 134 002c 1895      		reti
 136               	.Lscope1:
 138               	.global	__vector_13
 140               	__vector_13:
  99:ir_heat.c     **** 
 100:ir_heat.c     **** SIGNAL(SIG_OVERFLOW1) {
 141               	,.LM3-.LFBB2
 142               	.LM3:
 143               	.LFBB2:
 144 002e 1F92      		push __zero_reg__
 145 0030 0F92      		push r0
 146 0032 0FB6      		in r0,__SREG__
 147 0034 0F92      		push r0
 148 0036 1124      		clr __zero_reg__
 149 0038 EF93      		push r30
 150 003a FF93      		push r31
 151 003c DF93      		push r29
 152 003e CF93      		push r28
 153 0040 CDB7      		in r28,__SP_L__
 154 0042 DEB7      		in r29,__SP_H__
 155               	/* prologue: Signal */
 156               	/* frame size = 0 */
 101:ir_heat.c     **** 	TIMER1_STOP;
 157               	,.LM4-.LFBB2
 158               	.LM4:
 159 0044 E1E8      		ldi r30,lo8(129)
 160 0046 F0E0      		ldi r31,hi8(129)
 161 0048 1082      		st Z,__zero_reg__
 102:ir_heat.c     **** 	TCNT1H = 0;
 162               	bn	68,0,102,.LM5-.LFBB2
 163               	.LM5:
 164 004a E5E8      		ldi r30,lo8(133)
 165 004c F0E0      		ldi r31,hi8(133)
 166 004e 1082      		st Z,__zero_reg__
 103:ir_heat.c     **** 	TCNT1L = 0;
 167               	bn	68,0,103,.LM6-.LFBB2
 168               	.LM6:
 169 0050 E4E8      		ldi r30,lo8(132)
 170 0052 F0E0      		ldi r31,hi8(132)
 171 0054 1082      		st Z,__zero_reg__
 172               	/* epilogue start */
 104:ir_heat.c     **** }
 173               	n	68,0,104,.LM7-.LFBB2
 174               	.LM7:
 175 0056 CF91      		pop r28
 176 0058 DF91      		pop r29
 177 005a FF91      		pop r31
 178 005c EF91      		pop r30
 179 005e 0F90      		pop r0
 180 0060 0FBE      		out __SREG__,r0
 181 0062 0F90      		pop r0
 182 0064 1F90      		pop __zero_reg__
 183 0066 1895      		reti
 185               	.Lscope2:
 186               		.lcomm c.1692,1
 188               	.global	__vector_16
 190               	__vector_16:
 105:ir_heat.c     **** 
 106:ir_heat.c     **** 
 107:ir_heat.c     **** // LED Flasher
 108:ir_heat.c     **** SIGNAL(SIG_OVERFLOW0) {
 191               	LM8-.LFBB3
 192               	.LM8:
 193               	.LFBB3:
 194 0068 1F92      		push __zero_reg__
 195 006a 0F92      		push r0
 196 006c 0FB6      		in r0,__SREG__
 197 006e 0F92      		push r0
 198 0070 1124      		clr __zero_reg__
 199 0072 2F93      		push r18
 200 0074 3F93      		push r19
 201 0076 4F93      		push r20
 202 0078 5F93      		push r21
 203 007a 8F93      		push r24
 204 007c 9F93      		push r25
 205 007e AF93      		push r26
 206 0080 BF93      		push r27
 207 0082 EF93      		push r30
 208 0084 FF93      		push r31
 209 0086 DF93      		push r29
 210 0088 CF93      		push r28
 211 008a 0F92      		push __tmp_reg__
 212 008c CDB7      		in r28,__SP_L__
 213 008e DEB7      		in r29,__SP_H__
 214               	/* prologue: Signal */
 215               	/* frame size = 1 */
 109:ir_heat.c     **** 	static uint8_t	c = 0;
 110:ir_heat.c     **** 	uint8_t slow=0;
 216               	BB3
 217               	.LM9:
 218 0090 1982      		std Y+1,__zero_reg__
 111:ir_heat.c     **** 	c++;
 219               	tabn	68,0,111,.LM10-.LFBB3
 220               	.LM10:
 221 0092 8091 0000 		lds r24,c.1692
 222 0096 8F5F      		subi r24,lo8(-(1))
 223 0098 8093 0000 		sts c.1692,r24
 112:ir_heat.c     **** 	if (mode==MODE_TEMP_PROT) {
 224               	bn	68,0,112,.LM11-.LFBB3
 225               	.LM11:
 226 009c 8091 0000 		lds r24,mode
 227 00a0 8330      		cpi r24,lo8(3)
 228 00a2 01F4      		brne .L6
 113:ir_heat.c     **** 		if(c > (6<<slow)) {
 229               	bn	68,0,113,.LM12-.LFBB3
 230               	.LM12:
 231 00a4 8091 0000 		lds r24,c.1692
 232 00a8 482F      		mov r20,r24
 233 00aa 50E0      		ldi r21,lo8(0)
 234 00ac 8981      		ldd r24,Y+1
 235 00ae 282F      		mov r18,r24
 236 00b0 30E0      		ldi r19,lo8(0)
 237 00b2 86E0      		ldi r24,lo8(6)
 238 00b4 90E0      		ldi r25,hi8(6)
 239 00b6 022E      		mov r0,r18
 240 00b8 00C0      		rjmp 2f
 241 00ba 880F      	1:	lsl r24
 242 00bc 991F      		rol r25
 243 00be 0A94      	2:	dec r0
 244 00c0 02F4      		brpl 1b
 245 00c2 8417      		cp r24,r20
 246 00c4 9507      		cpc r25,r21
 247 00c6 04F4      		brge .L6
 114:ir_heat.c     **** 			FLASH_LED_ON;
 248               	M13-.LFBB3
 249               	.LM13:
 250 00c8 A8E2      		ldi r26,lo8(40)
 251 00ca B0E0      		ldi r27,hi8(40)
 252 00cc E8E2      		ldi r30,lo8(40)
 253 00ce F0E0      		ldi r31,hi8(40)
 254 00d0 8081      		ld r24,Z
 255 00d2 8860      		ori r24,lo8(8)
 256 00d4 8C93      		st X,r24
 257               	.L6:
 115:ir_heat.c     **** 		}
 116:ir_heat.c     **** 	}
 117:ir_heat.c     **** 	if(c > (10<<slow)) {
 258               	,0,117,.LM14-.LFBB3
 259               	.LM14:
 260 00d6 8091 0000 		lds r24,c.1692
 261 00da 482F      		mov r20,r24
 262 00dc 50E0      		ldi r21,lo8(0)
 263 00de 8981      		ldd r24,Y+1
 264 00e0 282F      		mov r18,r24
 265 00e2 30E0      		ldi r19,lo8(0)
 266 00e4 8AE0      		ldi r24,lo8(10)
 267 00e6 90E0      		ldi r25,hi8(10)
 268 00e8 022E      		mov r0,r18
 269 00ea 00C0      		rjmp 2f
 270 00ec 880F      	1:	lsl r24
 271 00ee 991F      		rol r25
 272 00f0 0A94      	2:	dec r0
 273 00f2 02F4      		brpl 1b
 274 00f4 8417      		cp r24,r20
 275 00f6 9507      		cpc r25,r21
 276 00f8 04F4      		brge .L8
 118:ir_heat.c     **** 		c=0;
 277               	M15-.LFBB3
 278               	.LM15:
 279 00fa 1092 0000 		sts c.1692,__zero_reg__
 119:ir_heat.c     **** 		FLASH_LED_OFF;
 280               	tabn	68,0,119,.LM16-.LFBB3
 281               	.LM16:
 282 00fe A8E2      		ldi r26,lo8(40)
 283 0100 B0E0      		ldi r27,hi8(40)
 284 0102 E8E2      		ldi r30,lo8(40)
 285 0104 F0E0      		ldi r31,hi8(40)
 286 0106 8081      		ld r24,Z
 287 0108 877F      		andi r24,lo8(-9)
 288 010a 8C93      		st X,r24
 289               	.L8:
 290               	/* epilogue start */
 120:ir_heat.c     **** 	}
 121:ir_heat.c     **** }
 291               	0,121,.LM17-.LFBB3
 292               	.LM17:
 293 010c 0F90      		pop __tmp_reg__
 294 010e CF91      		pop r28
 295 0110 DF91      		pop r29
 296 0112 FF91      		pop r31
 297 0114 EF91      		pop r30
 298 0116 BF91      		pop r27
 299 0118 AF91      		pop r26
 300 011a 9F91      		pop r25
 301 011c 8F91      		pop r24
 302 011e 5F91      		pop r21
 303 0120 4F91      		pop r20
 304 0122 3F91      		pop r19
 305 0124 2F91      		pop r18
 306 0126 0F90      		pop r0
 307 0128 0FBE      		out __SREG__,r0
 308 012a 0F90      		pop r0
 309 012c 1F90      		pop __zero_reg__
 310 012e 1895      		reti
 316               	.Lscope3:
 317               		.lcomm running.1724,1
 319               	.global	__vector_1
 321               	__vector_1:
 122:ir_heat.c     **** 
 123:ir_heat.c     **** 
 124:ir_heat.c     **** 
 125:ir_heat.c     **** //*******************************************
 126:ir_heat.c     **** //
 127:ir_heat.c     **** // Taster IQR und Entprellung
 128:ir_heat.c     **** //
 129:ir_heat.c     **** SIGNAL(SIG_INTERRUPT0) {
 322               	LM18:
 323               	.LFBB4:
 324               		push __zero_reg__
 325 0130 1F92      		push r0
 326 0132 0F92      		in r0,__SREG__
 327 0134 0FB6      		push r0
 328 0136 0F92      		clr __zero_reg__
 329 0138 1124      		push r18
 330 013a 2F93      		push r24
 331 013c 8F93      		push r25
 332 013e 9F93      		push r30
 333 0140 EF93      		push r31
 334 0142 FF93      		push r29
 335 0144 DF93      		push r28
 336 0146 CF93      		rcall .
 337 0148 00D0      		push __tmp_reg__
 338 014a 0F92      		in r28,__SP_L__
 339 014c CDB7      		in r29,__SP_H__
 340 014e DEB7      	/* prologue: Signal */
 341               	/* frame size = 3 */
 130:ir_heat.c     **** 	static uint8_t running = 0;
 131:ir_heat.c     **** 	
 132:ir_heat.c     **** 	if(running | TCNT1H | TCNT1L){
 343               	33)
 344               		ldi r31,hi8(133)
 345 0150 E5E8      		ld r25,Z
 346 0152 F0E0      		lds r24,running.1724
 347 0154 9081      		or r25,r24
 348 0156 8091 0000 		ldi r30,lo8(132)
 349 015a 982B      		ldi r31,hi8(132)
 350 015c E4E8      		ld r24,Z
 351 015e F0E0      		or r24,r25
 352 0160 8081      		tst r24
 353 0162 892B      		breq .+2
 354 0164 8823      		rjmp .L19
 356 0168 00C0      	.LM20:
 133:ir_heat.c     **** //		printf("X");
 134:ir_heat.c     **** 		return;
 135:ir_heat.c     **** 	}
 136:ir_heat.c     **** 	running = 1;
 357               	)
 358               		sts running.1724,r24
 360 016c 8093 0000 	.LM21:
 137:ir_heat.c     **** 	
 138:ir_heat.c     **** 	uint16_t i;
 139:ir_heat.c     **** 	uint8_t 	c = 0;
 361               	 Y+1,__zero_reg__
 363 0170 1982      	.LM22:
 140:ir_heat.c     **** 	EIMSK = 0;
 364               	i r30,lo8(61)
 365               		ldi r31,hi8(61)
 366 0172 EDE3      		st Z,__zero_reg__
 368 0176 1082      	.LM23:
 141:ir_heat.c     **** 	sei();
 369               	PP */
 370               	 ;  141 "ir_heat.c" 1
 371               		sei
 372               	 ;  0 "" 2
 374               	.LM24:
 142:ir_heat.c     **** //	printf("In");
 143:ir_heat.c     **** 	for(i=0;i<2000;i++) if((PIND & (1<<SWITCH))) c++;
 375               	APP */
 376               		std Y+3,__zero_reg__
 377               		std Y+2,__zero_reg__
 378 017a 1B82      		rjmp .L11
 379 017c 1A82      	.L13:
 380 017e 00C0      		ldi r30,lo8(41)
 381               		ldi r31,hi8(41)
 382 0180 E9E2      		ld r24,Z
 383 0182 F0E0      		mov r24,r24
 384 0184 8081      		ldi r25,lo8(0)
 385 0186 882F      		andi r24,lo8(4)
 386 0188 90E0      		andi r25,hi8(4)
 387 018a 8470      		sbiw r24,0
 388 018c 9070      		breq .L12
 389 018e 0097      		ldd r24,Y+1
 390 0190 01F0      		subi r24,lo8(-(1))
 391 0192 8981      		std Y+1,r24
 392 0194 8F5F      	.L12:
 393 0196 8983      		ldd r24,Y+2
 394               		ldd r25,Y+3
 395 0198 8A81      		adiw r24,1
 396 019a 9B81      		std Y+3,r25
 397 019c 0196      		std Y+2,r24
 398 019e 9B83      	.L11:
 399 01a0 8A83      		ldd r24,Y+2
 400               		ldd r25,Y+3
 401 01a2 8A81      		ldi r18,hi8(2000)
 402 01a4 9B81      		cpi r24,lo8(2000)
 403 01a6 27E0      		cpc r25,r18
 404 01a8 803D      		brlo .L13
 406 01ac 00F0      	.LM25:
 144:ir_heat.c     **** //	printf(" %i ", c);
 145:ir_heat.c     **** 
 146:ir_heat.c     **** 	if(c < 100) {
 407               	brsh .L14
 409 01ae 8981      	.LM26:
 410 01b0 8436      		ldi r30,lo8(132)
 411 01b2 00F4      		ldi r31,hi8(132)
 147:ir_heat.c     **** 		TCNT1L = 1;
 412               	r24,lo8(1)
 413               		st Z,r24
 415 01b6 F0E0      	.LM27:
 416 01b8 81E0      		ldi r30,lo8(129)
 417 01ba 8083      		ldi r31,hi8(129)
 148:ir_heat.c     **** 		TIMER1_RUN;
 418               	24,lo8(2)
 419               		st Z,r24
 421 01be F0E0      	.LM28:
 422 01c0 82E0      		lds r24,mode
 423 01c2 8083      		mov r24,r24
 149:ir_heat.c     **** 		switch(mode) {
 424               	25,lo8(0)
 425               		sbiw r24,0
 426 01c4 8091 0000 		brne .L20
 427 01c8 882F      	.L16:
 429 01cc 0097      	.LM29:
 430 01ce 01F4      		lds r24,off_counter
 431               		tst r24
 150:ir_heat.c     **** 		case MODE_OFF:
 151:ir_heat.c     **** 			if(off_counter) mode = MODE_TEMP_PROT;
 432               	17
 433               		ldi r24,lo8(3)
 434 01d0 8091 0000 		sts mode,r24
 435 01d4 8823      		rjmp .L14
 436 01d6 01F0      	.L17:
 438 01da 8093 0000 	.LM30:
 439 01de 00C0      		ldi r24,lo8(1)
 440               		sts mode,r24
 152:ir_heat.c     **** 			else mode = MODE_ON;
 441               	4
 442               	.L20:
 444 01e2 8093 0000 	.LM31:
 445 01e6 00C0      		sts mode,__zero_reg__
 446               	.L14:
 153:ir_heat.c     **** 			break;
 154:ir_heat.c     **** 		case MODE_ON:
 155:ir_heat.c     **** 		case MODE_TEMP_PROT:
 156:ir_heat.c     **** 		default:
 157:ir_heat.c     **** 			mode = MODE_OFF;
 447               	n	68,0,161,.LM32-.LFBB4
 448               	.LM32:
 449 01e8 1092 0000 		ldi r30,lo8(60)
 450               		ldi r31,hi8(60)
 158:ir_heat.c     **** 		}
 159:ir_heat.c     **** 	}
 160:ir_heat.c     **** //	printf("Out\n");
 161:ir_heat.c     **** 	EIFR 		= (1<<INTF0);
 451               	 r24,lo8(1)
 452               		st Z,r24
 454 01ee F0E0      	.LM33:
 455 01f0 81E0      		ldi r30,lo8(61)
 456 01f2 8083      		ldi r31,hi8(61)
 162:ir_heat.c     **** 	EIMSK 	= (1<<INT0);
 457               	24,lo8(1)
 458               		st Z,r24
 460 01f6 F0E0      	.LM34:
 461 01f8 81E0      		sts running.1724,__zero_reg__
 462 01fa 8083      	.L19:
 163:ir_heat.c     **** 	running 	= 0;
 463               	logue start */
 465 01fc 1092 0000 	.LM35:
 466               		pop __tmp_reg__
 467               		pop __tmp_reg__
 164:ir_heat.c     **** //	printf("Exit\n");
 165:ir_heat.c     **** }
 468               	__tmp_reg__
 469               		pop r28
 470 0200 0F90      		pop r29
 471 0202 0F90      		pop r31
 472 0204 0F90      		pop r30
 473 0206 CF91      		pop r25
 474 0208 DF91      		pop r24
 475 020a FF91      		pop r18
 476 020c EF91      		pop r0
 477 020e 9F91      		out __SREG__,r0
 478 0210 8F91      		pop r0
 479 0212 2F91      		pop __zero_reg__
 480 0214 0F90      		reti
 487               	.Lscope4:
 489               	.global	__vector_18
 491               	__vector_18:
 493               	.LM36:
 494               	.LFBB5:
 495               		push __zero_reg__
 166:ir_heat.c     **** 
 167:ir_heat.c     **** 
 168:ir_heat.c     **** 
 169:ir_heat.c     **** SIGNAL(SIG_USART_RECV) {
 496               	sh r0
 497               		clr __zero_reg__
 498               		push r24
 499 021e 1F92      		push r25
 500 0220 0F92      		push r30
 501 0222 0FB6      		push r31
 502 0224 0F92      		push r29
 503 0226 1124      		push r28
 504 0228 8F93      		push __tmp_reg__
 505 022a 9F93      		in r28,__SP_L__
 506 022c EF93      		in r29,__SP_H__
 507 022e FF93      	/* prologue: Signal */
 508 0230 DF93      	/* frame size = 1 */
 510 0234 0F92      	.LM37:
 511 0236 CDB7      		ldi r30,lo8(198)
 512 0238 DEB7      		ldi r31,hi8(198)
 513               		ld r24,Z
 514               		std Y+1,r24
 170:ir_heat.c     **** //******************
 171:ir_heat.c     **** // RX interrupt handler
 172:ir_heat.c     **** //
 173:ir_heat.c     **** 	char c;	
 174:ir_heat.c     **** 	c = UDR0;							// Get received char
 515               	M38-.LFBB5
 516               	.LM38:
 517 023a E6EC      		lds r24,r_in
 518 023c F0E0      		mov r24,r24
 519 023e 8081      		ldi r25,lo8(0)
 520 0240 8983      		andi r24,lo8(31)
 175:ir_heat.c     **** 	rbuf[r_in & RMASK] = c;
 521               	r25,hi8(31)
 522               		movw r30,r24
 523 0242 8091 0000 		subi r30,lo8(-(rbuf))
 524 0246 882F      		sbci r31,hi8(-(rbuf))
 525 0248 90E0      		ldd r24,Y+1
 526 024a 8F71      		st Z,r24
 528 024e FC01      	.LM39:
 529 0250 E050      		lds r24,r_in
 530 0252 F040      		subi r24,lo8(-(1))
 531 0254 8981      		sts r_in,r24
 532 0256 8083      	/* epilogue start */
 176:ir_heat.c     **** 	r_in++;
 533               	,177,.LM40-.LFBB5
 534               	.LM40:
 535 0258 8091 0000 		pop __tmp_reg__
 536 025c 8F5F      		pop r28
 537 025e 8093 0000 		pop r29
 538               		pop r31
 177:ir_heat.c     **** }
 539               	30
 540               		pop r25
 541 0262 0F90      		pop r24
 542 0264 CF91      		pop r0
 543 0266 DF91      		out __SREG__,r0
 544 0268 FF91      		pop r0
 545 026a EF91      		pop __zero_reg__
 546 026c 9F91      		reti
 551 0276 1F90      	.Lscope5:
 553               	.global	__vector_19
 555               	__vector_19:
 557               	.LM41:
 558               	.LFBB6:
 559               		push __zero_reg__
 560               		push r0
 561               		in r0,__SREG__
 178:ir_heat.c     **** 
 179:ir_heat.c     **** SIGNAL(SIG_USART_DATA) {
 562               	g__
 563               		push r24
 564               		push r25
 565 027a 1F92      		push r26
 566 027c 0F92      		push r27
 567 027e 0FB6      		push r30
 568 0280 0F92      		push r31
 569 0282 1124      		push r29
 570 0284 8F93      		push r28
 571 0286 9F93      		in r28,__SP_L__
 572 0288 AF93      		in r29,__SP_H__
 573 028a BF93      	/* prologue: Signal */
 574 028c EF93      	/* frame size = 0 */
 576 0290 DF93      	.LM42:
 577 0292 CF93      		lds r25,t_in
 578 0294 CDB7      		lds r24,t_out
 579 0296 DEB7      		cp r25,r24
 580               		breq .L24
 180:ir_heat.c     **** //*******************
 181:ir_heat.c     **** // Data register empty interrupt handler.
 182:ir_heat.c     **** // Indicates that next char can be transmitted
 183:ir_heat.c     **** //
 184:ir_heat.c     **** 	if(t_in != t_out) {
 582               	198)
 583               		ldi r27,hi8(198)
 584 0298 9091 0000 		lds r24,t_out
 585 029c 8091 0000 		mov r24,r24
 586 02a0 9817      		ldi r25,lo8(0)
 587 02a2 01F0      		andi r24,lo8(31)
 185:ir_heat.c     **** 		UDR0 = tbuf[t_out & TMASK];
 588               	r25,hi8(31)
 589               		movw r30,r24
 590 02a4 A6EC      		subi r30,lo8(-(tbuf))
 591 02a6 B0E0      		sbci r31,hi8(-(tbuf))
 592 02a8 8091 0000 		ld r24,Z
 593 02ac 882F      		st X,r24
 595 02b0 8F71      	.LM44:
 596 02b2 9070      		lds r24,t_out
 597 02b4 FC01      		subi r24,lo8(-(1))
 598 02b6 E050      		sts t_out,r24
 599 02b8 F040      		rjmp .L26
 600 02ba 8081      	.L24:
 186:ir_heat.c     **** 		t_out++;	
 602               	6,lo8(193)
 603               		ldi r27,hi8(193)
 604 02be 8091 0000 		ldi r30,lo8(193)
 605 02c2 8F5F      		ldi r31,hi8(193)
 606 02c4 8093 0000 		ld r24,Z
 607 02c8 00C0      		andi r24,lo8(-33)
 608               		st X,r24
 187:ir_heat.c     **** 	}
 188:ir_heat.c     **** 	else {
 189:ir_heat.c     **** 		UCSR0B &= ~(1<<UDRIE0);
 609               	* epilogue start */
 611 02ca A1EC      	.LM46:
 612 02cc B0E0      		pop r28
 613 02ce E1EC      		pop r29
 614 02d0 F0E0      		pop r31
 615 02d2 8081      		pop r30
 616 02d4 8F7D      		pop r27
 617 02d6 8C93      		pop r26
 618               		pop r25
 619               		pop r24
 190:ir_heat.c     **** 	}
 191:ir_heat.c     **** }
 620               	t __SREG__,r0
 621               		pop r0
 622 02d8 CF91      		pop __zero_reg__
 623 02da DF91      		reti
 625 02de EF91      	.Lscope6:
 627 02e2 AF91      	.global	tbuflen
 629 02e6 8F91      	tbuflen:
 631 02ea 0FBE      	.LM47:
 632 02ec 0F90      	.LFBB7:
 633 02ee 1F90      		push r29
 634 02f0 1895      		push r28
 635               		in r28,__SP_L__
 636               		in r29,__SP_H__
 637               	/* prologue: function */
 638               	/* frame size = 0 */
 640               	.LM48:
 192:ir_heat.c     **** 
 193:ir_heat.c     **** char tbuflen(void) {
 641               	4,t_out
 642               		mov r18,r25
 643               		sub r18,r24
 644 02f2 DF93      		mov r24,r18
 645 02f4 CF93      	/* epilogue start */
 647 02f8 DEB7      	.LM49:
 648               		pop r28
 649               		pop r29
 194:ir_heat.c     **** //****************
 195:ir_heat.c     **** // Retrieve pending chars in TX buffer
 196:ir_heat.c     **** //
 197:ir_heat.c     **** 	return(t_in - t_out);
 650               	ze	tbuflen, .-tbuflen
 651               	.Lscope7:
 655 0304 281B      	.global	UART_putchar
 657               	UART_putchar:
 198:ir_heat.c     **** }
 658               	68,0,200,.LM50-.LFBB8
 659               	.LM50:
 660 0308 CF91      	.LFBB8:
 661 030a DF91      		push r29
 662 030c 0895      		push r28
 663               		rcall .
 664               		push __tmp_reg__
 665               		in r28,__SP_L__
 666               		in r29,__SP_H__
 667               	/* prologue: function */
 668               	/* frame size = 3 */
 669               		std Y+1,r24
 670               		std Y+3,r23
 199:ir_heat.c     **** 
 200:ir_heat.c     **** int UART_putchar(char c, FILE *stream) {
 671               	.L30:
 673               	.LM51:
 674 030e DF93      		call tbuflen
 675 0310 CF93      		mov r18,r24
 676 0312 00D0      		ldi r19,lo8(0)
 677 0314 0F92      		ldi r24,lo8(32)
 678 0316 CDB7      		ldi r25,hi8(32)
 679 0318 DEB7      		sub r24,r18
 680               		sbc r25,r19
 681               		cpi r24,3
 682 031a 8983      		cpc r25,__zero_reg__
 683 031c 7B83      		brlt .L30
 685               	.LM52:
 201:ir_heat.c     **** //*********************
 202:ir_heat.c     **** // Fills the transmit buffer, if it is full wait
 203:ir_heat.c     **** //
 204:ir_heat.c     **** 	while((TBUFSIZE - tbuflen()) <= 2);  // Wait...
 686               	mov r24,r24
 687               		ldi r25,lo8(0)
 688 0320 0E94 0000 		andi r24,lo8(31)
 689 0324 282F      		andi r25,hi8(31)
 690 0326 30E0      		movw r30,r24
 691 0328 80E2      		subi r30,lo8(-(tbuf))
 692 032a 90E0      		sbci r31,hi8(-(tbuf))
 693 032c 821B      		ldd r24,Y+1
 694 032e 930B      		st Z,r24
 696 0332 9105      	.LM53:
 697 0334 04F0      		lds r24,t_in
 205:ir_heat.c     **** 	
 206:ir_heat.c     **** 	// Add data to the transmit buffer, enable TXCIE
 207:ir_heat.c     **** 	//
 208:ir_heat.c     **** 	tbuf[t_in & TMASK] = c;
 698               	8(-(1))
 699               		sts t_in,r24
 701 033a 882F      	.LM54:
 702 033c 90E0      		ldi r26,lo8(193)
 703 033e 8F71      		ldi r27,hi8(193)
 704 0340 9070      		ldi r30,lo8(193)
 705 0342 FC01      		ldi r31,hi8(193)
 706 0344 E050      		ld r24,Z
 707 0346 F040      		ori r24,lo8(32)
 708 0348 8981      		st X,r24
 209:ir_heat.c     **** 	t_in++;	
 710               	r24,lo8(0)
 711               		ldi r25,hi8(0)
 712 034c 8091 0000 	/* epilogue start */
 714 0352 8093 0000 	.LM56:
 210:ir_heat.c     **** 	UCSR0B |= (1<<UDRIE0);			// Enable UDR empty interrupt	
 715               	__tmp_reg__
 716               		pop __tmp_reg__
 717 0356 A1EC      		pop __tmp_reg__
 718 0358 B0E0      		pop r28
 719 035a E1EC      		pop r29
 720 035c F0E0      		ret
 722 0360 8062      	.Lscope8:
 211:ir_heat.c     **** 	return(0);
 724               	buflen
 726 0364 80E0      	rbuflen:
 728               	.LM57:
 212:ir_heat.c     **** }
 729               	9:
 730               		push r29
 731 0368 0F90      		push r28
 732 036a 0F90      		in r28,__SP_L__
 733 036c 0F90      		in r29,__SP_H__
 734 036e CF91      	/* prologue: function */
 735 0370 DF91      	/* frame size = 0 */
 737               	.LM58:
 738               		lds r25,r_in
 739               		lds r24,r_out
 740               		mov r18,r25
 741               		sub r18,r24
 742               		mov r24,r18
 213:ir_heat.c     **** 
 214:ir_heat.c     **** char rbuflen(void) {
 743               	art */
 745               	.LM59:
 746 0374 DF93      		pop r28
 747 0376 CF93      		pop r29
 748 0378 CDB7      		ret
 750               	.Lscope9:
 215:ir_heat.c     **** // ***************
 216:ir_heat.c     **** // Retrive pending chars in RX buffer
 217:ir_heat.c     **** //
 218:ir_heat.c     **** 	return(r_in - r_out);
 752               	stream:p(0,16)",160,0,0,2
 753               	.global	UART_getchar
 755 0380 8091 0000 	UART_getchar:
 757 0386 281B      	.LM60:
 758 0388 822F      	.LFBB10:
 759               		push r29
 219:ir_heat.c     **** }
 760               	8
 761               		rcall .
 762 038a CF91      		push __tmp_reg__
 763 038c DF91      		in r28,__SP_L__
 764 038e 0895      		in r29,__SP_H__
 765               	/* prologue: function */
 766               	/* frame size = 3 */
 767               		std Y+3,r25
 768               		std Y+2,r24
 769               	.L35:
 771               	.LM61:
 220:ir_heat.c     **** 
 221:ir_heat.c     **** int UART_getchar(FILE *stream) {
 772               	n
 773               		tst r24
 774               		breq .L35
 776 0392 CF93      	.LM62:
 777 0394 00D0      		lds r24,r_out
 778 0396 0F92      		mov r24,r24
 779 0398 CDB7      		ldi r25,lo8(0)
 780 039a DEB7      		andi r24,lo8(31)
 781               		andi r25,hi8(31)
 782               		movw r30,r24
 783 039c 9B83      		subi r30,lo8(-(rbuf))
 784 039e 8A83      		sbci r31,hi8(-(rbuf))
 785               		ld r24,Z
 222:ir_heat.c     **** //*******************
 223:ir_heat.c     **** // Retieves character from UART. This function is to be passed
 224:ir_heat.c     **** // to fdevopen
 225:ir_heat.c     **** //
 226:ir_heat.c     **** 	unsigned char c;
 227:ir_heat.c     **** 	while(rbuflen() == 0);	  // Wait...
 787               	.LM63:
 788 03a0 0E94 0000 		lds r24,r_out
 789 03a4 8823      		subi r24,lo8(-(1))
 790 03a6 01F0      		sts r_out,r24
 228:ir_heat.c     **** 	c = rbuf[r_out & RMASK];
 791               	bn	68,0,230,.LM64-.LFBB10
 792               	.LM64:
 793 03a8 8091 0000 		ldd r24,Y+1
 794 03ac 882F      		mov r24,r24
 795 03ae 90E0      		ldi r25,lo8(0)
 796 03b0 8F71      	/* epilogue start */
 798 03b4 FC01      	.LM65:
 799 03b6 E050      		pop __tmp_reg__
 800 03b8 F040      		pop __tmp_reg__
 801 03ba 8081      		pop __tmp_reg__
 802 03bc 8983      		pop r28
 229:ir_heat.c     **** 	r_out++;	
 803               	t
 230:ir_heat.c     **** 	return(c);
 808               	pe10:
 810 03c8 8981      	.global	UART_first_init
 812 03cc 90E0      	UART_first_init:
 231:ir_heat.c     **** }
 814               	
 815               	.LFBB11:
 816 03ce 0F90      		push r29
 817 03d0 0F90      		push r28
 818 03d2 0F90      		in r28,__SP_L__
 819 03d4 CF91      		in r29,__SP_H__
 820 03d6 DF91      	/* prologue: function */
 821 03d8 0895      	/* frame size = 0 */
 823               	.LM67:
 824               		ldi r30,lo8(196)
 825               		ldi r31,hi8(196)
 826               		ldi r24,lo8(12)
 827               		ldi r25,hi8(12)
 828               		std Z+1,r25
 829               		st Z,r24
 232:ir_heat.c     **** 
 233:ir_heat.c     **** void UART_first_init(void) {
 831               	lo8(193)
 832               		ldi r31,hi8(193)
 833               		ldi r24,lo8(-104)
 834 03da DF93      		st Z,r24
 836 03de CDB7      	.LM69:
 837 03e0 DEB7      		ldi r30,lo8(194)
 838               		ldi r31,hi8(194)
 839               		ldi r24,lo8(6)
 234:ir_heat.c     **** //***********************
 235:ir_heat.c     **** // The function fdevopen(..) must contain as parameters the
 236:ir_heat.c     **** // corresponding  ..putchar() and  ..getchar() functions, defined before.
 237:ir_heat.c     **** //
 238:ir_heat.c     **** 	UBRR0 = 12;										 		// 4800 BPS
 840               	
 842 03e2 E4EC      	.LM70:
 843 03e4 F0E0      		ldi r24,lo8(gs(UART_putchar))
 844 03e6 8CE0      		ldi r25,hi8(gs(UART_putchar))
 845 03e8 90E0      		ldi r18,lo8(gs(UART_getchar))
 846 03ea 9183      		ldi r19,hi8(gs(UART_getchar))
 847 03ec 8083      		movw r22,r18
 239:ir_heat.c     **** 	
 240:ir_heat.c     **** 	UCSR0B = (1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0);	// 8 Databits, receive and transmit enabled, receive a
 848               	devopen
 850 03ee E1EC      	.LM71:
 851 03f0 F0E0      	/* #APP */
 852 03f2 88E9      	 ;  244 "ir_heat.c" 1
 853 03f4 8083      		sei
 241:ir_heat.c     **** 	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
 854               	"" 2
 855               	/* epilogue start */
 857 03f8 F0E0      	.LM72:
 858 03fa 86E0      	/* #NOAPP */
 859 03fc 8083      		pop r28
 242:ir_heat.c     **** 	
 243:ir_heat.c     **** 	fdevopen(UART_putchar, UART_getchar);
 860               	29
 861               		ret
 863 0400 90E0      	.Lscope11:
 864 0402 20E0      		.data
 865 0404 30E0      	.LC0:
 866 0406 B901      		.string	"Array:"
 867 0408 0E94 0000 	.LC1:
 244:ir_heat.c     **** 	sei();											 		// Global interrupt enable
 868               		" %i"
 869               		.text
 871               	.global	print_array
 873               	print_array:
 245:ir_heat.c     **** }
 875               	.LFBB12:
 876               		push r29
 877               		push r28
 878 040e CF91      		push __tmp_reg__
 879 0410 DF91      		in r28,__SP_L__
 880 0412 0895      		in r29,__SP_H__
 881               	/* prologue: function */
 882               	/* frame size = 1 */
 884               	.LM74:
 885 0001 4172 7261 		rcall .
 885      793A 00
 886               		in r30,__SP_L__
 887 0008 2025 6900 		in r31,__SP_H__
 888               		adiw r30,1
 889               		ldi r24,lo8(.LC0)
 890               		ldi r25,hi8(.LC0)
 891               		std Z+1,r25
 892               		st Z,r24
 246:ir_heat.c     **** 
 247:ir_heat.c     **** 
 248:ir_heat.c     **** 
 249:ir_heat.c     **** //*********************************************
 250:ir_heat.c     **** //
 251:ir_heat.c     **** // Gibt den Temperatur Ringspeicher
 252:ir_heat.c     **** // über den UART aus
 253:ir_heat.c     **** //
 254:ir_heat.c     **** void print_array(){
 893               	__tmp_reg__
 894               		pop __tmp_reg__
 896 0414 DF93      	.LM75:
 897 0416 CF93      		std Y+1,__zero_reg__
 898 0418 0F92      		rjmp .L40
 899 041a CDB7      	.L41:
 901               	.LM76:
 902               		ldd r24,Y+1
 255:ir_heat.c     **** 	uint8_t i;
 256:ir_heat.c     ****   	printf("Array:");
 903               	24
 904               		ldi r25,lo8(0)
 905 041e 00D0      		lsl r24
 906 0420 EDB7      		rol r25
 907 0422 FEB7      		movw r30,r24
 908 0424 3196      		subi r30,lo8(-(t_array))
 909 0426 80E0      		sbci r31,hi8(-(t_array))
 910 0428 90E0      		ld r18,Z
 911 042a 9183      		ldd r19,Z+1
 912 042c 8083      		rcall .
 913 042e 0E94 0000 		rcall .
 914 0432 0F90      		in r30,__SP_L__
 915 0434 0F90      		in r31,__SP_H__
 257:ir_heat.c     **** 	for(i=0;i<6;i++) {
 916               	ldi r24,lo8(.LC1)
 917               		ldi r25,hi8(.LC1)
 918 0436 1982      		std Z+1,r25
 919 0438 00C0      		st Z,r24
 920               		std Z+3,r19
 258:ir_heat.c     ****    	printf(" %i", t_array[i]);
 921               	Z+2,r18
 922               		call printf
 923 043a 8981      		pop __tmp_reg__
 924 043c 882F      		pop __tmp_reg__
 925 043e 90E0      		pop __tmp_reg__
 926 0440 880F      		pop __tmp_reg__
 928 0444 FC01      	.LM77:
 929 0446 E050      		ldd r24,Y+1
 930 0448 F040      		subi r24,lo8(-(1))
 931 044a 2081      		std Y+1,r24
 932 044c 3181      	.L40:
 933 044e 00D0      		ldd r24,Y+1
 934 0450 00D0      		cpi r24,lo8(6)
 935 0452 EDB7      		brlo .L41
 937 0456 3196      	.LM78:
 938 0458 80E0      		ldi r24,lo8(10)
 939 045a 90E0      		ldi r25,hi8(10)
 940 045c 9183      		call putchar
 941 045e 8083      	/* epilogue start */
 943 0462 2283      	.LM79:
 944 0464 0E94 0000 		pop __tmp_reg__
 945 0468 0F90      		pop r28
 946 046a 0F90      		pop r29
 947 046c 0F90      		ret
 952 0472 8F5F      	.Lscope12:
 955 0476 8981      	.global	add_value
 957 047a 00F0      	add_value:
 259:ir_heat.c     **** 	}
 260:ir_heat.c     ****   	printf("\n");
 958               	
 959               	.LFBB13:
 960 047c 8AE0      		push r29
 961 047e 90E0      		push r28
 962 0480 0E94 0000 		rcall .
 963               		push __tmp_reg__
 261:ir_heat.c     **** }
 964               	28,__SP_L__
 965               		in r29,__SP_H__
 966 0484 0F90      	/* prologue: function */
 967 0486 CF91      	/* frame size = 3 */
 968 0488 DF91      		std Y+3,r25
 969 048a 0895      		std Y+2,r24
 971               	.LM81:
 972               		lds r24,t_array
 973               		lds r25,(t_array)+1
 974               		sbiw r24,0
 975               		brne .L44
 977               	.LM82:
 978               		ldd r24,Y+2
 979               		ldd r25,Y+3
 262:ir_heat.c     **** 
 263:ir_heat.c     **** 
 264:ir_heat.c     **** 
 265:ir_heat.c     **** //*********************************************
 266:ir_heat.c     **** //
 267:ir_heat.c     **** // Fügt einen Meßwert zum Ringspeicher hinzu
 268:ir_heat.c     **** // Der Ringspeicher enthält die letzten 6 Werte
 269:ir_heat.c     **** // t_array[5] ist der neuste Wert
 270:ir_heat.c     **** //
 271:ir_heat.c     **** void add_value(uint16_t value) {
 980               	)+1,r25
 981               		sts t_array+10,r24
 982               		lds r24,t_array+10
 983 048c DF93      		lds r25,(t_array+10)+1
 984 048e CF93      		sts (t_array+8)+1,r25
 985 0490 00D0      		sts t_array+8,r24
 986 0492 0F92      		lds r24,t_array+8
 987 0494 CDB7      		lds r25,(t_array+8)+1
 988 0496 DEB7      		sts (t_array+6)+1,r25
 989               		sts t_array+6,r24
 990               		lds r24,t_array+6
 991 0498 9B83      		lds r25,(t_array+6)+1
 992 049a 8A83      		sts (t_array+4)+1,r25
 272:ir_heat.c     **** 	uint8_t i;
 273:ir_heat.c     **** 	if(t_array[0]==0) {
 993               	4,r24
 994               		lds r24,t_array+4
 995 049c 8091 0000 		lds r25,(t_array+4)+1
 996 04a0 9091 0000 		sts (t_array+2)+1,r25
 997 04a4 0097      		sts t_array+2,r24
 998 04a6 01F4      		lds r24,t_array+2
 274:ir_heat.c     **** 		t_array[0]=t_array[1]=t_array[2]=t_array[3]=t_array[4]=t_array[5]=value;
 999               	25,(t_array+2)+1
 1000               		sts (t_array)+1,r25
 1001 04a8 8A81      		sts t_array,r24
 1002 04aa 9B81      		rjmp .L48
 1003 04ac 9093 0000 	.L44:
 1005 04b4 8091 0000 	.LM83:
 1006 04b8 9091 0000 		std Y+1,__zero_reg__
 1007 04bc 9093 0000 		rjmp .L46
 1008 04c0 8093 0000 	.L47:
 1010 04c8 9091 0000 	.LM84:
 1011 04cc 9093 0000 		ldd r24,Y+1
 1012 04d0 8093 0000 		mov r20,r24
 1013 04d4 8091 0000 		ldi r21,lo8(0)
 1014 04d8 9091 0000 		ldd r24,Y+1
 1015 04dc 9093 0000 		mov r24,r24
 1016 04e0 8093 0000 		ldi r25,lo8(0)
 1017 04e4 8091 0000 		adiw r24,1
 1018 04e8 9091 0000 		lsl r24
 1019 04ec 9093 0000 		rol r25
 1020 04f0 8093 0000 		movw r30,r24
 1021 04f4 8091 0000 		subi r30,lo8(-(t_array))
 1022 04f8 9091 0000 		sbci r31,hi8(-(t_array))
 1023 04fc 9093 0000 		ld r18,Z
 1024 0500 8093 0000 		ldd r19,Z+1
 1025 0504 00C0      		movw r24,r20
 1026               		lsl r24
 275:ir_heat.c     **** 	}
 276:ir_heat.c     **** 	else {
 277:ir_heat.c     **** 		for(i=0;i<5;i++) {
 1027               	 r30,lo8(-(t_array))
 1028               		sbci r31,hi8(-(t_array))
 1029 0506 1982      		std Z+1,r19
 1030 0508 00C0      		st Z,r18
 278:ir_heat.c     **** 			t_array[i]=t_array[i+1];
 1032               	:
 1033               		ldd r24,Y+1
 1034 050a 8981      		subi r24,lo8(-(1))
 1035 050c 482F      		std Y+1,r24
 1036 050e 50E0      	.L46:
 1037 0510 8981      		ldd r24,Y+1
 1038 0512 882F      		cpi r24,lo8(5)
 1039 0514 90E0      		brlo .L47
 1041 0518 880F      	.LM86:
 1042 051a 991F      		ldd r24,Y+2
 1043 051c FC01      		ldd r25,Y+3
 1044 051e E050      		sts (t_array+10)+1,r25
 1045 0520 F040      		sts t_array+10,r24
 1047 0524 3181      	.LM87:
 1048 0526 CA01      		lds r18,t_array+10
 1049 0528 880F      		lds r19,(t_array+10)+1
 1050 052a 991F      		lds r24,t_array+8
 1051 052c FC01      		lds r25,(t_array+8)+1
 1052 052e E050      		movw r20,r18
 1053 0530 F040      		sub r20,r24
 1054 0532 3183      		sbc r21,r25
 1055 0534 2083      		movw r24,r20
 1056               		movw r18,r24
 1057               		lsl r18
 1058 0536 8981      		rol r19
 1059 0538 8F5F      		movw r24,r18
 1060 053a 8983      		lsl r24
 1061               		rol r25
 1062 053c 8981      		lsl r24
 1063 053e 8530      		rol r25
 1064 0540 00F0      		movw r22,r18
 279:ir_heat.c     **** 		}
 280:ir_heat.c     **** 		t_array[5] = value;
 1065               	0,slope2
 1066               		lds r21,(slope2)+1
 1067 0542 8A81      		movw r24,r20
 1068 0544 9B81      		lsl r24
 1069 0546 9093 0000 		rol r25
 1070 054a 8093 0000 		movw r18,r24
 281:ir_heat.c     **** 		slope2 = (10*(t_array[5]-t_array[4]) + 19*slope2) / 20;
 1071               	18
 1072               		rol r19
 1073 054e 2091 0000 		lsl r18
 1074 0552 3091 0000 		rol r19
 1075 0556 8091 0000 		lsl r18
 1076 055a 9091 0000 		rol r19
 1077 055e A901      		add r24,r18
 1078 0560 481B      		adc r25,r19
 1079 0562 590B      		add r24,r20
 1080 0564 CA01      		adc r25,r21
 1081 0566 9C01      		add r24,r22
 1082 0568 220F      		adc r25,r23
 1083 056a 331F      		ldi r18,lo8(20)
 1084 056c C901      		ldi r19,hi8(20)
 1085 056e 880F      		movw r22,r18
 1086 0570 991F      		call __divmodhi4
 1087 0572 880F      		movw r24,r22
 1088 0574 991F      		sts (slope2)+1,r25
 1089 0576 B901      		sts slope2,r24
 1090 0578 680F      	.L48:
 1091 057a 791F      	/* epilogue start */
 1093 0580 5091 0000 	.LM88:
 1094 0584 CA01      		pop __tmp_reg__
 1095 0586 880F      		pop __tmp_reg__
 1096 0588 991F      		pop __tmp_reg__
 1097 058a 9C01      		pop r28
 1098 058c 220F      		pop r29
 1099 058e 331F      		ret
 1104 0598 820F      	.Lscope13:
 1106 059c 840F      	.global	get_slope
 1108 05a0 860F      	get_slope:
 1110 05a4 24E1      	.LM89:
 1111 05a6 30E0      	.LFBB14:
 1112 05a8 B901      		push r29
 1113 05aa 0E94 0000 		push r28
 1114 05ae CB01      		rcall .
 1115 05b0 9093 0000 		rcall .
 1116 05b4 8093 0000 		rcall .
 1117               		in r28,__SP_L__
 1118               		in r29,__SP_H__
 282:ir_heat.c     **** 	}
 283:ir_heat.c     **** }
 1119               	stabn	68,0,295,.LM90-.LFBB14
 1120               	.LM90:
 1121 05b8 0F90      		lds r18,t_array+10
 1122 05ba 0F90      		lds r19,(t_array+10)+1
 1123 05bc 0F90      		lds r24,t_array
 1124 05be CF91      		lds r25,(t_array)+1
 1125 05c0 DF91      		movw r20,r18
 1126 05c2 0895      		sub r20,r24
 1127               		sbc r21,r25
 1128               		movw r24,r20
 1129               		std Y+6,r25
 1130               		std Y+5,r24
 1132               	.LM91:
 1133               		lds r18,t_array+8
 1134               		lds r19,(t_array+8)+1
 1135               		lds r24,t_array+2
 284:ir_heat.c     **** 
 285:ir_heat.c     **** 
 286:ir_heat.c     **** 
 287:ir_heat.c     **** //********************************************
 288:ir_heat.c     **** //
 289:ir_heat.c     **** // Gibt die gemittelte Steigung
 290:ir_heat.c     **** // über die letzten 4 Sekunden zurück
 291:ir_heat.c     **** //
 292:ir_heat.c     **** int16_t get_slope() {
 1136               	+2)+1
 1137               		movw r20,r18
 1138               		sub r20,r24
 1139 05c4 DF93      		sbc r21,r25
 1140 05c6 CF93      		movw r24,r20
 1141 05c8 00D0      		std Y+4,r25
 1142 05ca 00D0      		std Y+3,r24
 1144 05ce CDB7      	.LM92:
 1145 05d0 DEB7      		lds r18,t_array+6
 1146               		lds r19,(t_array+6)+1
 1147               		lds r24,t_array+4
 293:ir_heat.c     **** 	int16_t s1, s2, s3;
 294:ir_heat.c     **** 
 295:ir_heat.c     **** 	s1 = t_array[5] - t_array[0];
 1148               	array+4)+1
 1149               		movw r20,r18
 1150 05d2 2091 0000 		sub r20,r24
 1151 05d6 3091 0000 		sbc r21,r25
 1152 05da 8091 0000 		movw r24,r20
 1153 05de 9091 0000 		std Y+2,r25
 1154 05e2 A901      		std Y+1,r24
 1156 05e6 590B      	.LM93:
 1157 05e8 CA01      		ldd r18,Y+5
 1158 05ea 9E83      		ldd r19,Y+6
 1159 05ec 8D83      		movw r24,r18
 296:ir_heat.c     **** 	s2 = t_array[4] - t_array[1];
 1160               	l r25
 1161               		movw r20,r24
 1162 05ee 2091 0000 		add r20,r18
 1163 05f2 3091 0000 		adc r21,r19
 1164 05f6 8091 0000 		ldd r18,Y+3
 1165 05fa 9091 0000 		ldd r19,Y+4
 1166 05fe A901      		movw r24,r18
 1167 0600 481B      		lsl r24
 1168 0602 590B      		rol r25
 1169 0604 CA01      		lsl r24
 1170 0606 9C83      		rol r25
 1171 0608 8B83      		add r24,r18
 297:ir_heat.c     **** 	s3 = t_array[3] - t_array[2];
 1172               	
 1173               		add r20,r24
 1174 060a 2091 0000 		adc r21,r25
 1175 060e 3091 0000 		ldd r18,Y+1
 1176 0612 8091 0000 		ldd r19,Y+2
 1177 0616 9091 0000 		movw r24,r18
 1178 061a A901      		lsl r24
 1179 061c 481B      		rol r25
 1180 061e 590B      		add r24,r18
 1181 0620 CA01      		adc r25,r19
 1182 0622 9A83      		movw r18,r24
 1183 0624 8983      		lsl r18
 298:ir_heat.c     **** 	
 299:ir_heat.c     **** 	return ((3*s1+5*s2+15*s3)/9);
 1184               	sl r18
 1185               		rol r19
 1186 0626 2D81      		add r24,r18
 1187 0628 3E81      		adc r25,r19
 1188 062a C901      		add r24,r20
 1189 062c 880F      		adc r25,r21
 1190 062e 991F      		ldi r18,lo8(9)
 1191 0630 AC01      		ldi r19,hi8(9)
 1192 0632 420F      		movw r22,r18
 1193 0634 531F      		call __divmodhi4
 1194 0636 2B81      		movw r24,r22
 1195 0638 3C81      	/* epilogue start */
 1197 063c 880F      	.LM94:
 1198 063e 991F      		adiw r28,6
 1199 0640 880F      		in __tmp_reg__,__SREG__
 1200 0642 991F      		cli
 1201 0644 820F      		out __SP_H__,r29
 1202 0646 931F      		out __SREG__,__tmp_reg__
 1203 0648 480F      		out __SP_L__,r28
 1204 064a 591F      		pop r28
 1205 064c 2981      		pop r29
 1206 064e 3A81      		ret
 1213 065c 220F      	.Lscope14:
 1215 0660 220F      	.global	get_last_slope
 1217 0664 820F      	get_last_slope:
 1219 0668 840F      	.LM95:
 1220 066a 951F      	.LFBB15:
 1221 066c 29E0      		push r29
 1222 066e 30E0      		push r28
 1223 0670 B901      		in r28,__SP_L__
 1224 0672 0E94 0000 		in r29,__SP_H__
 1225 0676 CB01      	/* prologue: function */
 1226               	/* frame size = 0 */
 300:ir_heat.c     **** }
 1227               	r18,t_array+10
 1228               		lds r19,(t_array+10)+1
 1229 0678 2696      		lds r24,t_array+8
 1230 067a 0FB6      		lds r25,(t_array+8)+1
 1231 067c F894      		movw r20,r18
 1232 067e DEBF      		sub r20,r24
 1233 0680 0FBE      		sbc r21,r25
 1234 0682 CDBF      		movw r24,r20
 1235 0684 CF91      	/* epilogue start */
 1237 0688 0895      	.LM97:
 1238               		pop r28
 1239               		pop r29
 1240               		ret
 1242               	.Lscope15:
 1245               	.global	get_temperature
 1247               	get_temperature:
 301:ir_heat.c     **** 
 302:ir_heat.c     **** 
 303:ir_heat.c     **** 
 304:ir_heat.c     **** //********************************************
 305:ir_heat.c     **** //
 306:ir_heat.c     **** // Gibt die aktuelle Steigung der Temperatur zurück
 307:ir_heat.c     **** // in 0.1°C in 4s
 308:ir_heat.c     **** //
 309:ir_heat.c     **** int16_t	get_last_slope() {
 1249               	r29
 1250               		push r28
 1251               		in r28,__SP_L__
 1252 068a DF93      		in r29,__SP_H__
 1253 068c CF93      		sbiw r28,15
 1254 068e CDB7      		in __tmp_reg__,__SREG__
 1255 0690 DEB7      		cli
 1256               		out __SP_H__,r29
 1257               		out __SREG__,__tmp_reg__
 310:ir_heat.c     ****     return (t_array[5] - t_array[4]);
 1258               	_L__,r28
 1259               	/* prologue: function */
 1260 0692 2091 0000 	/* frame size = 15 */
 1261 0696 3091 0000 		std Y+13,r24
 1263 069e 9091 0000 	.LM99:
 1264 06a2 A901      		ldi r24,lo8(-76)
 1265 06a4 481B      		call i2c_start
 1267 06a8 CA01      	.LM100:
 1268               		ldd r24,Y+13
 311:ir_heat.c     **** }
 1269               	rite
 1271 06aa CF91      	.LM101:
 1272 06ac DF91      		ldi r24,lo8(-75)
 1273 06ae 0895      		call i2c_rep_start
 1274               		std Y+4,r24
 1276               	.LM102:
 1277               		ldd r24,Y+4
 1278               		tst r24
 1279               		breq .L54
 312:ir_heat.c     **** 
 313:ir_heat.c     **** 
 314:ir_heat.c     **** 
 315:ir_heat.c     **** //********************************************
 316:ir_heat.c     **** //
 317:ir_heat.c     **** // Liest die vom MLX90614 gemessene Temperatur aus
 318:ir_heat.c     **** // Rückgabe in 0.1°C, also 215 = 21.5°C
 319:ir_heat.c     **** //
 320:ir_heat.c     **** uint16_t get_temperature(uint8_t adr) {
 1281               	 r24,lo8(-75)
 1282               		call i2c_rep_start
 1283               	.L54:
 1285 06b2 CF93      	.LM104:
 1286 06b4 CDB7      		call i2c_read_ack
 1287 06b6 DEB7      		std Y+3,r24
 1289 06ba 0FB6      	.LM105:
 1290 06bc F894      		call i2c_read_ack
 1291 06be DEBF      		std Y+2,r24
 1293 06c2 CDBF      	.LM106:
 1294               		ldd r24,Y+2
 1295               		mov r24,r24
 1296 06c4 8D87      		ldi r25,lo8(0)
 321:ir_heat.c     **** 	uint16_t raw;
 322:ir_heat.c     **** 	uint8_t 	ret;
 323:ir_heat.c     **** 	uint8_t 	lo, hi, pec;
 324:ir_heat.c     **** 	uint8_t	pec_read[6];
 325:ir_heat.c     **** 
 326:ir_heat.c     **** 	i2c_start(MLX90614_WRITE);
 1297               	r r24
 1298               		movw r18,r24
 1299 06c6 84EB      		ldd r24,Y+3
 1300 06c8 0E94 0000 		mov r24,r24
 327:ir_heat.c     **** 	i2c_write(adr);
 1301               	 r25,lo8(0)
 1302               		add r24,r18
 1303 06cc 8D85      		adc r25,r19
 1304 06ce 0E94 0000 		std Y+6,r25
 328:ir_heat.c     **** 	
 329:ir_heat.c     **** 	ret = i2c_rep_start(MLX90614_READ);
 1305               	 Y+5,r24
 1307 06d2 85EB      	.LM107:
 1308 06d4 0E94 0000 		call i2c_read_ack
 1309 06d8 8C83      		std Y+1,r24
 330:ir_heat.c     **** 	if(ret) {
 1310               	bn	68,0,339,.LM108-.LFBB16
 1311               	.LM108:
 1312 06da 8C81      		call i2c_stop
 1314 06de 01F0      	.LM109:
 331:ir_heat.c     **** 		i2c_rep_start(MLX90614_READ);
 1315               	r24,Y+5
 1316               		ldd r25,Y+6
 1317 06e0 85EB      		tst r25
 1318 06e2 0E94 0000 		brge .L55
 1319               		std Y+15,__zero_reg__
 332:ir_heat.c     ****    }
 333:ir_heat.c     **** 
 334:ir_heat.c     **** 	lo = i2c_read_ack();
 1320               	Y+14,__zero_reg__
 1321               		rjmp .L56
 1322 06e6 0E94 0000 	.L55:
 335:ir_heat.c     **** 	hi = i2c_read_ack();
 1324               	10:
 1325               		ldd r24,Y+5
 1326 06ec 0E94 0000 		ldd r25,Y+6
 1327 06f0 8A83      		ldi r18,lo8(5)
 336:ir_heat.c     **** 	raw = (uint16_t)(hi<<8)+lo;
 1328               	 r19,hi8(5)
 1329               		movw r22,r18
 1330 06f2 8A81      		call __udivmodhi4
 1331 06f4 882F      		movw r24,r22
 1332 06f6 90E0      		movw r18,r24
 1333 06f8 982F      		subi r18,lo8(-(-2731))
 1334 06fa 8827      		sbci r19,hi8(-(-2731))
 1335 06fc 9C01      		std Y+15,r19
 1336 06fe 8B81      		std Y+14,r18
 1337 0700 882F      	.L56:
 1338 0702 90E0      		ldd r24,Y+14
 1339 0704 820F      		ldd r25,Y+15
 1340 0706 931F      	/* epilogue start */
 1342 070a 8D83      	.LM111:
 337:ir_heat.c     **** 	pec = i2c_read_ack();
 1343               	n __tmp_reg__,__SREG__
 1344               		cli
 1345 070c 0E94 0000 		out __SP_H__,r29
 1346 0710 8983      		out __SREG__,__tmp_reg__
 338:ir_heat.c     **** 	
 339:ir_heat.c     **** 	i2c_stop();
 1347               	 __SP_L__,r28
 1348               		pop r28
 1349 0712 0E94 0000 		pop r29
 340:ir_heat.c     **** 	
 341:ir_heat.c     **** 	if(raw & 0x8000) return 0;
 1350               	t
 342:ir_heat.c     **** 	
 343:ir_heat.c     **** 	return (raw / 5 - 2731); 					// 1 = 0.1°C
 1360               	
 1361               		.lcomm last.1944,1
 1362 0724 8D81      		.data
 1363 0726 9E81      	.LC2:
 1364 0728 25E0      		.string	">>> Relais ON"
 1365 072a 30E0      	.LC3:
 1366 072c B901      		.string	">>> Relais OFF"
 1367 072e 0E94 0000 		.text
 1370 0736 2B5A      	.global	set_relais
 1372 073a 3F87      	set_relais:
 1374               	.LM112:
 1375 073e 8E85      	.LFBB17:
 1376 0740 9F85      		push r29
 1377               		push r28
 344:ir_heat.c     **** }
 1378               	
 1379               		in r28,__SP_L__
 1380 0742 2F96      		in r29,__SP_H__
 1381 0744 0FB6      	/* prologue: function */
 1382 0746 F894      	/* frame size = 1 */
 1383 0748 DEBF      		std Y+1,r24
 1385 074c CDBF      	.LM113:
 1386 074e CF91      		ldd r24,Y+1
 1387 0750 DF91      		tst r24
 1388 0752 0895      		breq .L59
 1390               	.LM114:
 1391               		lds r25,last.1944
 1392               		ldd r24,Y+1
 1393               		cp r24,r25
 1394               		breq .L60
 1395               		ldi r24,lo8(.LC2)
 1396               		ldi r25,hi8(.LC2)
 1397               		call puts
 1398               	.L60:
 1400               	.LM115:
 1401               		ldi r26,lo8(37)
 1402 000c 3E3E 3E20 		ldi r27,hi8(37)
 1402      5265 6C61 
 1402      6973 204F 
 1402      4E00 
 1403               		ldi r30,lo8(37)
 1404 001a 3E3E 3E20 		ldi r31,hi8(37)
 1404      5265 6C61 
 1404      6973 204F 
 1404      4646 00
 1405               		ld r24,Z
 1406               		ori r24,lo8(64)
 1407               		st X,r24
 1408               		rjmp .L61
 1409               	.L59:
 345:ir_heat.c     **** 
 346:ir_heat.c     **** 
 347:ir_heat.c     **** //***************************************************
 348:ir_heat.c     **** //
 349:ir_heat.c     **** // Relais Ein- und Ausschalen
 350:ir_heat.c     **** //
 351:ir_heat.c     **** void set_relais(uint8_t on) {
 1411               	r24,Y+1
 1412               		cp r24,r25
 1413               		breq .L62
 1414 0754 DF93      		ldi r24,lo8(.LC3)
 1415 0756 CF93      		ldi r25,hi8(.LC3)
 1416 0758 0F92      		call puts
 1417 075a CDB7      	.L62:
 1419               	.LM117:
 1420               		ldi r26,lo8(37)
 1421 075e 8983      		ldi r27,hi8(37)
 352:ir_heat.c     **** 	static uint8_t last = 0;
 353:ir_heat.c     **** 	if(on) {
 1422               	8(37)
 1423               		ldi r31,hi8(37)
 1424 0760 8981      		ld r24,Z
 1425 0762 8823      		andi r24,lo8(-65)
 1426 0764 01F0      		st X,r24
 354:ir_heat.c     **** 		if(on != last) printf(">>> Relais ON\n");
 1427               	
 1429 0766 9091 0000 	.LM118:
 1430 076a 8981      		ldd r24,Y+1
 1431 076c 8917      		sts last.1944,r24
 1432 076e 01F0      	/* epilogue start */
 1434 0772 90E0      	.LM119:
 1435 0774 0E94 0000 		pop __tmp_reg__
 1436               		pop r28
 355:ir_heat.c     **** 		RELAIS_ON;
 1437               		ret
 1442 077e F0E0      	.Lscope17:
 1443 0780 8081      		.data
 1444 0782 8064      	.LC4:
 1445 0784 8C93      		.string	"\nStart"
 1446 0786 00C0      	.LC5:
 1447               		.string	"Error Temp=0"
 356:ir_heat.c     **** 	}
 357:ir_heat.c     **** 	else {
 358:ir_heat.c     **** 		if(on != last) printf(">>> Relais OFF\n");
 1448               	ing	"Startup %i "
 1449               	.LC7:
 1450 0788 9091 0000 		.string	"Temp: %i, "
 1451 078c 8981      	.LC8:
 1452 078e 8917      		.string	"sl_raw: %i, sl: %i, f: %i, int: %i\n"
 1453 0790 01F0      	.LC9:
 1454 0792 80E0      		.string	"On-Counter: %i; \n"
 1455 0794 90E0      	.LC10:
 1456 0796 0E94 0000 		.string	"Off-Counter: %i; \n"
 1457               		.text
 359:ir_heat.c     **** 		RELAIS_OFF;
 1458               	ain:F(0,1)",36,0,0,main
 1459               	.global	main
 1461 079c B0E0      	main:
 1463 07a0 F0E0      	.LM120:
 1464 07a2 8081      	.LFBB18:
 1465 07a4 8F7B      		push r29
 1466 07a6 8C93      		push r28
 1467               		in r28,__SP_L__
 360:ir_heat.c     **** 	}
 361:ir_heat.c     **** 	last = on;
 1468               	SP_H__
 1469               		sbiw r28,25
 1470 07a8 8981      		in __tmp_reg__,__SREG__
 1471 07aa 8093 0000 		cli
 1472               		out __SP_H__,r29
 362:ir_heat.c     **** }
 1473               	__SREG__,__tmp_reg__
 1474               		out __SP_L__,r28
 1475 07ae 0F90      	/* prologue: function */
 1476 07b0 CF91      	/* frame size = 25 */
 1478 07b4 0895      	.LM121:
 1479               		ldi r30,lo8(36)
 1480               		ldi r31,hi8(36)
 1481               		ldi r24,lo8(-64)
 1482               		st Z,r24
 1484               	.LM122:
 1485               		ldi r30,lo8(39)
 1486 0029 0A53 7461 		ldi r31,hi8(39)
 1486      7274 00
 1487               		ldi r24,lo8(8)
 1488 0030 4572 726F 		st Z,r24
 1488      7220 5465 
 1488      6D70 3D30 
 1488      00
 1490 003d 5374 6172 	.LM123:
 1490      7475 7020 
 1490      2569 2000 
 1491               		ldi r30,lo8(42)
 1492 0049 5465 6D70 		ldi r31,hi8(42)
 1492      3A20 2569 
 1492      2C20 00
 1493               		ldi r24,lo8(24)
 1494 0054 736C 5F72 		st Z,r24
 1494      6177 3A20 
 1494      2569 2C20 
 1494      736C 3A20 
 1494      2569 2C20 
 1496 0078 4F6E 2D43 	.LM124:
 1496      6F75 6E74 
 1496      6572 3A20 
 1496      2569 3B20 
 1496      0A00 
 1497               		ldi r30,lo8(37)
 1498 008a 4F66 662D 		ldi r31,hi8(37)
 1498      436F 756E 
 1498      7465 723A 
 1498      2025 693B 
 1498      200A 00
 1499               		ldi r24,lo8(63)
 1500               		st Z,r24
 1502               	.LM125:
 1503               		ldi r30,lo8(40)
 363:ir_heat.c     **** 
 364:ir_heat.c     **** 
 365:ir_heat.c     **** 
 366:ir_heat.c     **** 
 367:ir_heat.c     **** // ***********************************************************
 368:ir_heat.c     **** // Main program
 369:ir_heat.c     **** //
 370:ir_heat.c     **** int main(void) {
 1504               	9)
 1505               		st Z,r24
 1507 07b6 DF93      	.LM126:
 1508 07b8 CF93      		ldi r30,lo8(43)
 1509 07ba CDB7      		ldi r31,hi8(43)
 1510 07bc DEB7      		ldi r24,lo8(-25)
 1511 07be 6997      		st Z,r24
 1513 07c2 F894      	.LM127:
 1514 07c4 DEBF      		ldi r30,lo8(100)
 1515 07c6 0FBE      		ldi r31,hi8(100)
 1516 07c8 CDBF      		ld r18,Z
 1518               	.LM128:
 371:ir_heat.c     ****    // Ausgänge definieren
 372:ir_heat.c     **** 	DDRB = 0x00 | (1<<RELAIS) | (1<<BUZZER);
 1519               	385 "ir_heat.c" 1
 1520               		wdr
 1521 07ca E4E2      	 ;  0 "" 2
 1523 07ce 80EC      	.LM129:
 1524 07d0 8083      	/* #NOAPP */
 373:ir_heat.c     **** 	DDRC = 0x00 | (1<<FLASH_LED);
 1525               	24,lo8(24)
 1526               		ldi r25,hi8(24)
 1527 07d2 E7E2      		ldi r18,lo8(41)
 1528 07d4 F0E0      	/* #APP */
 1529 07d6 88E0      	 ;  386 "ir_heat.c" 1
 1530 07d8 8083      		in __tmp_reg__,__SREG__
 374:ir_heat.c     **** 	DDRD = 0x00 | (1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED);
 1531               	wdr
 1532               		sts 96,r24
 1533 07da EAE2      		out __SREG__,__tmp_reg__
 1534 07dc F0E0      		sts 96,r18
 1535 07de 88E1      		
 1536 07e0 8083      	 ;  0 "" 2
 375:ir_heat.c     **** 
 376:ir_heat.c     **** 	// Ausgänge ausschalten
 377:ir_heat.c     **** 	PORTB = ~((1<<RELAIS) | (1<<BUZZER));
 1537               	n	68,0,389,.LM130-.LFBB18
 1538               	.LM130:
 1539 07e2 E5E2      	/* #NOAPP */
 1540 07e4 F0E0      		call UART_first_init
 1542 07e8 8083      	.LM131:
 378:ir_heat.c     **** 	PORTC = ~(1<<FLASH_LED);
 1543               	i2c_init
 1545 07ea E8E2      	.LM132:
 1546 07ec F0E0      		sts interval,__zero_reg__
 1548 07f0 8083      	.LM133:
 379:ir_heat.c     **** 	PORTD = ~((1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED));
 1549               	30,lo8(177)
 1550               		ldi r31,hi8(177)
 1551 07f2 EBE2      		ldi r24,lo8(7)
 1552 07f4 F0E0      		st Z,r24
 1554 07f8 8083      	.LM134:
 380:ir_heat.c     **** 
 381:ir_heat.c     **** 	// TWI aus Energiesparmode rausnehmen
 382:ir_heat.c     **** 	PRR != ~(1<<PRTWI);
 1555               	30,lo8(112)
 1556               		ldi r31,hi8(112)
 1557 07fa E4E6      		ldi r24,lo8(1)
 1558 07fc F0E0      		st Z,r24
 383:ir_heat.c     **** 
 384:ir_heat.c     **** 	// Whatchdog initialisieren
 385:ir_heat.c     **** 	wdt_reset();
 1560               	5:
 1561               		ldi r30,lo8(68)
 1562               		ldi r31,hi8(68)
 1563               		st Z,__zero_reg__
 1565               	.LM136:
 386:ir_heat.c     **** 	wdt_enable(WDTO_8S);
 1566               	30,lo8(69)
 1567               		ldi r31,hi8(69)
 1568               		ldi r24,lo8(3)
 1569 0802 88E1      		st Z,r24
 1571 0806 29E2      	.LM137:
 1572               		ldi r30,lo8(110)
 1573               		ldi r31,hi8(110)
 1574 0808 0FB6      		ldi r24,lo8(1)
 1575 080a F894      		st Z,r24
 1577 080e 8093 6000 	.LM138:
 1578 0812 0FBE      		ldi r30,lo8(128)
 1579 0814 2093 6000 		ldi r31,hi8(128)
 1580               		st Z,__zero_reg__
 387:ir_heat.c     **** 	
 388:ir_heat.c     **** 	// UART initialisieren
 389:ir_heat.c     **** 	UART_first_init();
 1582               	,lo8(129)
 1583               		ldi r31,hi8(129)
 1584               		st Z,__zero_reg__
 390:ir_heat.c     **** 	i2c_init();
 1586               	40:
 1587               		ldi r30,lo8(130)
 1588 081c 0E94 0000 		ldi r31,hi8(130)
 391:ir_heat.c     **** 	
 392:ir_heat.c     **** 	interval=0;
 1589               	 Z,__zero_reg__
 1591 0820 1092 0000 	.LM141:
 393:ir_heat.c     **** 	
 394:ir_heat.c     **** 	// Timer 2 initialisieren (RTC)
 395:ir_heat.c     ****    TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);	// clk/256
 1592               	i r30,lo8(111)
 1593               		ldi r31,hi8(111)
 1594 0824 E1EB      		ldi r24,lo8(1)
 1595 0826 F0E0      		st Z,r24
 1597 082a 8083      	.LM142:
 396:ir_heat.c     ****    TIMSK2 = (1<<TOIE2);
 1598               	30,lo8(105)
 1599               		ldi r31,hi8(105)
 1600 082c E0E7      		ldi r24,lo8(2)
 1601 082e F0E0      		st Z,r24
 1603 0832 8083      	.LM143:
 397:ir_heat.c     **** 
 398:ir_heat.c     ****  	// Timer 0 initialisieren (Blinken)
 399:ir_heat.c     **** 	TCCR0A = 0;
 1604               	30,lo8(61)
 1605               		ldi r31,hi8(61)
 1606 0834 E4E4      		ldi r24,lo8(1)
 1607 0836 F0E0      		st Z,r24
 400:ir_heat.c     **** 	TCCR0B = (0<<CS02) | (1<<CS01) | (1<<CS00);
 1609               	4:
 1610               		ldi r24,lo8(.LC4)
 1611 083a E5E4      		ldi r25,hi8(.LC4)
 1612 083c F0E0      		call puts
 1614 0840 8083      	.LM145:
 401:ir_heat.c     **** 	TIMSK0 = (1<<TOIE0);
 1615               	26,lo8(43)
 1616               		ldi r27,hi8(43)
 1617 0842 EEE6      		ldi r30,lo8(43)
 1618 0844 F0E0      		ldi r31,hi8(43)
 1619 0846 81E0      		ld r24,Z
 1620 0848 8083      		ori r24,lo8(16)
 402:ir_heat.c     **** 	
 403:ir_heat.c     **** 	// Timer 1 initialisieren (Entprellen?)
 404:ir_heat.c     **** 	TCCR1A = 0;
 1621               	r24
 1623 084a E0E8      	.LM146:
 1624 084c F0E0      		ldi r26,lo8(43)
 1625 084e 1082      		ldi r27,hi8(43)
 405:ir_heat.c     **** 	TIMER1_STOP;
 1626               	r30,lo8(43)
 1627               		ldi r31,hi8(43)
 1628 0850 E1E8      		ld r24,Z
 1629 0852 F0E0      		andi r24,lo8(-9)
 1630 0854 1082      		st X,r24
 406:ir_heat.c     **** 	TCCR1C = 0;
 1631               	bn	68,0,417,.LM147-.LFBB18
 1632               	.LM147:
 1633 0856 E2E8      		ldi r24,lo8(0)
 1634 0858 F0E0      		call set_relais
 407:ir_heat.c     **** 	TIMSK1 = (1<<TOIE1);
 1636               	8:
 1637               		sts mode,__zero_reg__
 1639 085e F0E0      	.LM149:
 1640 0860 81E0      		std Y+14,__zero_reg__
 1641 0862 8083      		std Y+13,__zero_reg__
 408:ir_heat.c     **** 	
 409:ir_heat.c     **** 	// Interrupt für Taster initialisieren
 410:ir_heat.c     **** 	EICRA = (1<<ISC01);
 1642               	n	68,0,422,.LM150-.LFBB18
 1643               	.LM150:
 1644 0864 E9E6      		std Y+8,__zero_reg__
 1646 0868 82E0      	.LM151:
 1647 086a 8083      		ldi r24,lo8(-1)
 411:ir_heat.c     **** 	EIMSK = (1<<INT0);
 1648               	+7,r24
 1650 086c EDE3      	.LM152:
 1651 086e F0E0      		ldi r24,lo8(3)
 1652 0870 81E0      		std Y+6,r24
 412:ir_heat.c     **** 	
 413:ir_heat.c     **** 
 414:ir_heat.c     **** 	printf("\nStart\n");
 1654               	:
 1655               		std Y+5,__zero_reg__
 1657 0876 90E0      	.LM154:
 1658 0878 0E94 0000 		std Y+2,__zero_reg__
 415:ir_heat.c     **** 	STATUS_LED1_ON;		// grüne LED ein
 1659               	Y+1,__zero_reg__
 1661 087c ABE2      	.LM155:
 1662 087e B0E0      	/* #APP */
 1663 0880 EBE2      	 ;  430 "ir_heat.c" 1
 1664 0882 F0E0      		sei
 1665 0884 8081      	 ;  0 "" 2
 1666 0886 8061      	/* #NOAPP */
 1667 0888 8C93      	.L90:
 416:ir_heat.c     **** 	STATUS_LED2_OFF;		// rote LED aus
 1668               	8,0,433,.LM156-.LFBB18
 1669               	.LM156:
 1670 088a ABE2      		lds r24,interval
 1671 088c B0E0      		cpi r24,lo8(16)
 1672 088e EBE2      		brge .+2
 1673 0890 F0E0      		rjmp .L65
 1675 0894 877F      	.LM157:
 1676 0896 8C93      	/* #APP */
 417:ir_heat.c     **** 	set_relais(0);			// Relais aus
 1677               	ir_heat.c" 1
 1678               		wdr
 1679 0898 80E0      	 ;  0 "" 2
 418:ir_heat.c     **** 	mode = MODE_OFF;
 1681               	58:
 1682               	/* #NOAPP */
 1683 089e 1092 0000 		sts interval,__zero_reg__
 419:ir_heat.c     **** 	
 420:ir_heat.c     **** 	int16_t 	temp, temp_sum = 0;
 1684               	tabn	68,0,436,.LM159-.LFBB18
 1685               	.LM159:
 1686 08a2 1E86      		std Y+8,__zero_reg__
 421:ir_heat.c     **** 	int16_t	slope_raw, slope;
 422:ir_heat.c     **** 	uint8_t	count=0;
 1688               	60:
 1689               		ldd r24,Y+13
 1690 08a6 1886      		ldd r25,Y+14
 423:ir_heat.c     **** 	uint8_t  last_interval = 0xff;
 1691               	r r25
 1692               		ror r24
 1693 08a8 8FEF      		asr r25
 1694 08aa 8F83      		ror r24
 424:ir_heat.c     **** 	uint8_t	startup = 3;
 1695               	 r25
 1696               		ror r24
 1697 08ac 83E0      		asr r25
 1698 08ae 8E83      		ror r24
 425:ir_heat.c     **** 	uint8_t	on_counter = 0;
 1699               	 Y+16,r25
 1700               		std Y+15,r24
 426:ir_heat.c     **** 	int16_t	factor;
 427:ir_heat.c     **** 	int16_t	integral = 0;
 1702               	161:
 1703               		std Y+14,__zero_reg__
 1704 08b2 1A82      		std Y+13,__zero_reg__
 428:ir_heat.c     **** 		
 429:ir_heat.c     **** 	// Interrupts aktivieren
 430:ir_heat.c     **** 	sei();
 1706               	62:
 1707               		ldd r24,Y+15
 1708               		ldd r25,Y+16
 1709               		sbiw r24,0
 1710 08b6 7894      		brne .L66
 1712               	.LM163:
 1713               		rcall .
 431:ir_heat.c     **** 
 432:ir_heat.c     ****    while(1) {
 433:ir_heat.c     ****    	if(!(interval < 16)) { 					// Alle 16x (alle 4 Sekunden) Temperatur checken
 1714               	__SP_L__
 1715               		in r31,__SP_H__
 1716 08b8 8091 0000 		adiw r30,1
 1717 08bc 8031      		ldi r24,lo8(.LC5)
 1718 08be 04F4      		ldi r25,hi8(.LC5)
 1719 08c0 00C0      		std Z+1,r25
 434:ir_heat.c     ****    		wdt_reset();                  	// Whatchdog zurücksetzen
 1720               	r24
 1721               		call printf
 1722               		pop __tmp_reg__
 1723               		pop __tmp_reg__
 1724 08c2 A895      		rjmp .L67
 1725               	.L66:
 435:ir_heat.c     ****    		interval=0;
 1726               	n	68,0,446,.LM164-.LFBB18
 1727               	.LM164:
 1728               		ldd r24,Y+6
 1729 08c4 1092 0000 		tst r24
 436:ir_heat.c     ****    		count=0;
 1730               	q .L68
 1732 08c8 1886      	.LM165:
 437:ir_heat.c     **** 
 438:ir_heat.c     **** 			temp = temp_sum >> 4;				// Mittelwert der 16 Messungen ermitteln
 1733               	d r24,Y+6
 1734               		mov r18,r24
 1735 08ca 8D85      		ldi r19,lo8(0)
 1736 08cc 9E85      		rcall .
 1737 08ce 9595      		rcall .
 1738 08d0 8795      		in r30,__SP_L__
 1739 08d2 9595      		in r31,__SP_H__
 1740 08d4 8795      		adiw r30,1
 1741 08d6 9595      		ldi r24,lo8(.LC6)
 1742 08d8 8795      		ldi r25,hi8(.LC6)
 1743 08da 9595      		std Z+1,r25
 1744 08dc 8795      		st Z,r24
 1745 08de 988B      		std Z+3,r19
 1746 08e0 8F87      		std Z+2,r18
 439:ir_heat.c     **** 			temp_sum = 0;
 1747               	pop __tmp_reg__
 1748               		pop __tmp_reg__
 1749 08e2 1E86      		pop __tmp_reg__
 1750 08e4 1D86      		pop __tmp_reg__
 440:ir_heat.c     **** 	      //printf("Temp: %i\n", temp);
 441:ir_heat.c     **** 	      if(temp==0) {
 1751               	abn	68,0,449,.LM166-.LFBB18
 1752               	.LM166:
 1753 08e6 8F85      		ldd r24,Y+6
 1754 08e8 9889      		subi r24,lo8(-(-1))
 1755 08ea 0097      		std Y+6,r24
 442:ir_heat.c     **** 	      	// error!
 443:ir_heat.c     **** 	      	printf("Error Temp=0");
 1757               	:
 1758               		ldi r24,lo8(7)
 1759 08ee 00D0      		call get_temperature
 1760 08f0 EDB7      		std Y+16,r25
 1761 08f2 FEB7      		std Y+15,r24
 1763 08f6 80E0      	.LM168:
 1764 08f8 90E0      		std Y+10,__zero_reg__
 1765 08fa 9183      		std Y+9,__zero_reg__
 1766 08fc 8083      	.L68:
 1768 0902 0F90      	.LM169:
 1769 0904 0F90      		rcall .
 1770 0906 00C0      		rcall .
 1771               		in r30,__SP_L__
 444:ir_heat.c     **** 	      }
 445:ir_heat.c     **** 	      else {
 446:ir_heat.c     **** 				if (startup>0) {
 1772               	_
 1773               		adiw r30,1
 1774 0908 8E81      		ldi r24,lo8(.LC7)
 1775 090a 8823      		ldi r25,hi8(.LC7)
 1776 090c 01F0      		std Z+1,r25
 447:ir_heat.c     **** 					// wird nur beim ersten Durchlauf, direkt nach Startup ausgeführt
 448:ir_heat.c     **** 					printf("Startup %i ", startup);
 1777               	,r24
 1778               		ldd r24,Y+15
 1779 090e 8E81      		ldd r25,Y+16
 1780 0910 282F      		std Z+3,r25
 1781 0912 30E0      		std Z+2,r24
 1782 0914 00D0      		call printf
 1783 0916 00D0      		pop __tmp_reg__
 1784 0918 EDB7      		pop __tmp_reg__
 1785 091a FEB7      		pop __tmp_reg__
 1786 091c 3196      		pop __tmp_reg__
 1788 0920 90E0      	.LM170:
 1789 0922 9183      		ldd r24,Y+15
 1790 0924 8083      		ldd r25,Y+16
 1791 0926 3383      		call add_value
 1793 092a 0E94 0000 	.LM171:
 1794 092e 0F90      		call get_slope
 1795 0930 0F90      		std Y+12,r25
 1796 0932 0F90      		std Y+11,r24
 449:ir_heat.c     **** 					startup--;
 1798               	
 1799               		ldd r25,Y+16
 1800 0936 8E81      		subi r24,lo8(-(-620))
 1801 0938 8150      		sbci r25,hi8(-(-620))
 1802 093a 8E83      		ldi r18,lo8(-25)
 450:ir_heat.c     **** 					temp = get_temperature(ADR_T_OBJ1);
 1803               	 r19,hi8(-25)
 1804               		movw r22,r18
 1805 093c 87E0      		call __divmodhi4
 1806 093e 0E94 0000 		movw r24,r22
 1807 0942 988B      		std Y+4,r25
 1808 0944 8F87      		std Y+3,r24
 451:ir_heat.c     **** 					slope = 0;
 1809               	n	68,0,458,.LM173-.LFBB18
 1810               	.LM173:
 1811 0946 1A86      		ldd r24,Y+3
 1812 0948 1986      		ldd r25,Y+4
 1813               		tst r25
 452:ir_heat.c     **** 				}
 453:ir_heat.c     ****    	   	printf("Temp: %i, ", temp);
 1814               	 .L69
 1815               		std Y+4,__zero_reg__
 1816 094a 00D0      		std Y+3,__zero_reg__
 1817 094c 00D0      	.L69:
 1819 0950 FEB7      	.LM174:
 1820 0952 3196      		ldd r18,Y+11
 1821 0954 80E0      		ldd r19,Y+12
 1822 0956 90E0      		ldd r24,Y+3
 1823 0958 9183      		ldd r25,Y+4
 1824 095a 8083      		cp r24,r18
 1825 095c 8F85      		cpc r25,r19
 1826 095e 9889      		brge .L70
 1828 0962 8283      	.LM175:
 1829 0964 0E94 0000 		ldd r18,Y+1
 1830 0968 0F90      		ldd r19,Y+2
 1831 096a 0F90      		ldd r24,Y+11
 1832 096c 0F90      		ldd r25,Y+12
 1833 096e 0F90      		add r24,r18
 454:ir_heat.c     ****    	   	add_value(temp);									// Neue Temperatur zu Array hinzufügen
 1834               	4
 1835               		rol r25
 1836 0970 8F85      		lsl r24
 1837 0972 9889      		rol r25
 1838 0974 0E94 0000 		lsl r24
 455:ir_heat.c     ****    	   	slope_raw = get_slope();						// Aktuelle Steigung ermitteln
 1839               	r25
 1840               		ldd r18,Y+3
 1841 0978 0E94 0000 		ldd r19,Y+4
 1842 097c 9C87      		movw r22,r18
 1843 097e 8B87      		call __divmodhi4
 456:ir_heat.c     ****    	   	
 457:ir_heat.c     ****    	   	factor = (temp - 620) / -25;					// Fakort ermitteln
 1844               	 r24,r22
 1845               		std Y+2,r25
 1846 0980 8F85      		std Y+1,r24
 1847 0982 9889      		rjmp .L71
 1848 0984 8C56      	.L70:
 1850 0988 27EE      	.LM176:
 1851 098a 3FEF      		ldd r24,Y+1
 1852 098c B901      		ldd r25,Y+2
 1853 098e 0E94 0000 		std Y+21,r25
 1854 0992 CB01      		std Y+20,r24
 1855 0994 9C83      		ldd r24,Y+20
 1856 0996 8B83      		ldd r25,Y+21
 458:ir_heat.c     ****    	   	if(factor < 0) factor = 0;
 1857               	e .L72
 1858               		ldd r18,Y+20
 1859 0998 8B81      		ldd r19,Y+21
 1860 099a 9C81      		subi r18,lo8(-(3))
 1861 099c 9923      		sbci r19,hi8(-(3))
 1862 099e 04F4      		std Y+21,r19
 1863 09a0 1C82      		std Y+20,r18
 1864 09a2 1B82      	.L72:
 1865               		ldd r24,Y+20
 459:ir_heat.c     ****    	   	   	   	
 460:ir_heat.c     **** 				if(slope_raw > factor) { 						// "Steigungsintegral"
 1866               	Y+21
 1867               		asr r25
 1868 09a4 2B85      		ror r24
 1869 09a6 3C85      		asr r25
 1870 09a8 8B81      		ror r24
 1871 09aa 9C81      		std Y+2,r25
 1872 09ac 8217      		std Y+1,r24
 1873 09ae 9307      	.L71:
 461:ir_heat.c     **** 					integral = 8*(integral + slope_raw) / factor;
 1875               	ldd r24,Y+11
 1876               		ldd r25,Y+12
 1877 09b2 2981      		ldi r19,hi8(-10)
 1878 09b4 3A81      		cpi r24,lo8(-10)
 1879 09b6 8B85      		cpc r25,r19
 1880 09b8 9C85      		brge .L73
 1881 09ba 820F      		ldi r24,lo8(-10)
 1882 09bc 931F      		ldi r25,hi8(-10)
 1883 09be 880F      		std Y+12,r25
 1884 09c0 991F      		std Y+11,r24
 1885 09c2 880F      	.L73:
 1887 09c6 880F      	.LM178:
 1888 09c8 991F      		ldd r24,Y+11
 1889 09ca 2B81      		ldd r25,Y+12
 1890 09cc 3C81      		tst r25
 1891 09ce B901      		brge .L74
 1893 09d4 CB01      	.LM179:
 1894 09d6 9A83      		ldd r18,Y+9
 1895 09d8 8983      		ldd r19,Y+10
 1896 09da 00C0      		movw r24,r18
 1897               		lsl r24
 462:ir_heat.c     **** 				}
 463:ir_heat.c     **** 				else {
 464:ir_heat.c     **** 					integral = integral / 4;
 1898               	r25
 1899               		lsl r24
 1900 09dc 8981      		rol r25
 1901 09de 9A81      		movw r20,r24
 1902 09e0 9D8B      		sub r20,r18
 1903 09e2 8C8B      		sbc r21,r19
 1904 09e4 8C89      		ldd r24,Y+11
 1905 09e6 9D89      		ldd r25,Y+12
 1906 09e8 9923      		movw r18,r24
 1907 09ea 04F4      		lsl r18
 1908 09ec 2C89      		rol r19
 1909 09ee 3D89      		movw r24,r18
 1910 09f0 2D5F      		lsl r24
 1911 09f2 3F4F      		rol r25
 1912 09f4 3D8B      		lsl r24
 1913 09f6 2C8B      		rol r25
 1914               		add r24,r18
 1915 09f8 8C89      		adc r25,r19
 1916 09fa 9D89      		add r24,r20
 1917 09fc 9595      		adc r25,r21
 1918 09fe 8795      		std Y+23,r25
 1919 0a00 9595      		std Y+22,r24
 1920 0a02 8795      		ldd r24,Y+22
 1921 0a04 9A83      		ldd r25,Y+23
 1922 0a06 8983      		tst r25
 1923               		brge .L75
 465:ir_heat.c     **** 				}
 466:ir_heat.c     **** 				
 467:ir_heat.c     **** //				slope = (31*slope + 10*slope_raw)/32; 		// Steigung dämpfen
 468:ir_heat.c     **** 
 469:ir_heat.c     **** 				
 470:ir_heat.c     **** 				if(slope_raw < -10) slope_raw = -10;
 1924               	3
 1925               		subi r18,lo8(-(7))
 1926 0a08 8B85      		sbci r19,hi8(-(7))
 1927 0a0a 9C85      		std Y+23,r19
 1928 0a0c 3FEF      		std Y+22,r18
 1929 0a0e 863F      	.L75:
 1930 0a10 9307      		ldd r24,Y+22
 1931 0a12 04F4      		ldd r25,Y+23
 1932 0a14 86EF      		asr r25
 1933 0a16 9FEF      		ror r24
 1934 0a18 9C87      		asr r25
 1935 0a1a 8B87      		ror r24
 1936               		asr r25
 471:ir_heat.c     **** 				if(slope_raw<0) {									// Fallende Temperaturen werden stärker gewichtet
 1937               	 Y+10,r25
 1938               		std Y+9,r24
 1939 0a1c 8B85      		rjmp .L76
 1940 0a1e 9C85      	.L74:
 1942 0a22 04F4      	.LM180:
 472:ir_heat.c     **** 	   	   	slope = (7*slope + 10*slope_raw)/8;		// Negative Steigung wird mit einer Dämpfung von 8 ge
 1943               	18,Y+9
 1944               		ldd r19,Y+10
 1945 0a24 2985      		ldi r24,lo8(31)
 1946 0a26 3A85      		ldi r25,hi8(31)
 1947 0a28 C901      		mul r18,r24
 1948 0a2a 880F      		movw r20,r0
 1949 0a2c 991F      		mul r18,r25
 1950 0a2e 880F      		add r21,r0
 1951 0a30 991F      		mul r19,r24
 1952 0a32 880F      		add r21,r0
 1953 0a34 991F      		clr r1
 1954 0a36 AC01      		ldd r24,Y+11
 1955 0a38 421B      		ldd r25,Y+12
 1956 0a3a 530B      		movw r18,r24
 1957 0a3c 8B85      		lsl r18
 1958 0a3e 9C85      		rol r19
 1959 0a40 9C01      		movw r24,r18
 1960 0a42 220F      		lsl r24
 1961 0a44 331F      		rol r25
 1962 0a46 C901      		lsl r24
 1963 0a48 880F      		rol r25
 1964 0a4a 991F      		add r24,r18
 1965 0a4c 880F      		adc r25,r19
 1966 0a4e 991F      		add r24,r20
 1967 0a50 820F      		adc r25,r21
 1968 0a52 931F      		std Y+25,r25
 1969 0a54 840F      		std Y+24,r24
 1970 0a56 951F      		ldd r24,Y+24
 1971 0a58 9F8B      		ldd r25,Y+25
 1972 0a5a 8E8B      		tst r25
 1973 0a5c 8E89      		brge .L77
 1974 0a5e 9F89      		ldd r18,Y+24
 1975 0a60 9923      		ldd r19,Y+25
 1976 0a62 04F4      		subi r18,lo8(-(31))
 1977 0a64 2E89      		sbci r19,hi8(-(31))
 1978 0a66 3F89      		std Y+25,r19
 1979 0a68 295F      		std Y+24,r18
 1980 0a6a 3F4F      	.L77:
 1981 0a6c 3F8B      		ldd r24,Y+24
 1982 0a6e 2E8B      		ldd r25,Y+25
 1983               		asr r25
 1984 0a70 8E89      		ror r24
 1985 0a72 9F89      		asr r25
 1986 0a74 9595      		ror r24
 1987 0a76 8795      		asr r25
 1988 0a78 9595      		ror r24
 1989 0a7a 8795      		asr r25
 1990 0a7c 9595      		ror r24
 1991 0a7e 8795      		asr r25
 1992 0a80 9A87      		ror r24
 1993 0a82 8987      		std Y+10,r25
 1994 0a84 00C0      		std Y+9,r24
 1995               	.L76:
 473:ir_heat.c     **** 				}
 474:ir_heat.c     **** 				else {
 475:ir_heat.c     **** 	   	   	slope = (31*slope + 10*slope_raw)/32;	// Positive Steigung wird mit einer Dämpfung von 16 
 1996               	L__
 1997               		in r25,__SP_H__
 1998 0a86 2985      		sbiw r24,10
 1999 0a88 3A85      		in __tmp_reg__,__SREG__
 2000 0a8a 8FE1      		cli
 2001 0a8c 90E0      		out __SP_H__,r25
 2002 0a8e 289F      		out __SREG__,__tmp_reg__
 2003 0a90 A001      		out __SP_L__,r24
 2004 0a92 299F      		in r30,__SP_L__
 2005 0a94 500D      		in r31,__SP_H__
 2006 0a96 389F      		adiw r30,1
 2007 0a98 500D      		ldi r24,lo8(.LC8)
 2008 0a9a 1124      		ldi r25,hi8(.LC8)
 2009 0a9c 8B85      		std Z+1,r25
 2010 0a9e 9C85      		st Z,r24
 2011 0aa0 9C01      		ldd r24,Y+11
 2012 0aa2 220F      		ldd r25,Y+12
 2013 0aa4 331F      		std Z+3,r25
 2014 0aa6 C901      		std Z+2,r24
 2015 0aa8 880F      		ldd r24,Y+9
 2016 0aaa 991F      		ldd r25,Y+10
 2017 0aac 880F      		std Z+5,r25
 2018 0aae 991F      		std Z+4,r24
 2019 0ab0 820F      		ldd r24,Y+3
 2020 0ab2 931F      		ldd r25,Y+4
 2021 0ab4 840F      		std Z+7,r25
 2022 0ab6 951F      		std Z+6,r24
 2023 0ab8 998F      		ldd r24,Y+1
 2024 0aba 888F      		ldd r25,Y+2
 2025 0abc 888D      		std Z+9,r25
 2026 0abe 998D      		std Z+8,r24
 2027 0ac0 9923      		call printf
 2028 0ac2 04F4      		in r18,__SP_L__
 2029 0ac4 288D      		in r19,__SP_H__
 2030 0ac6 398D      		subi r18,lo8(-(10))
 2031 0ac8 215E      		sbci r19,hi8(-(10))
 2032 0aca 3F4F      		in __tmp_reg__,__SREG__
 2033 0acc 398F      		cli
 2034 0ace 288F      		out __SP_H__,r19
 2035               		out __SREG__,__tmp_reg__
 2036 0ad0 888D      		out __SP_L__,r18
 2038 0ad4 9595      	.LM182:
 2039 0ad6 8795      		call get_last_slope
 2040 0ad8 9595      		tst r25
 2041 0ada 8795      		brlt .L78
 2042 0adc 9595      		ldd r24,Y+9
 2043 0ade 8795      		ldd r25,Y+10
 2044 0ae0 9595      		cpi r24,56
 2045 0ae2 8795      		cpc r25,__zero_reg__
 2046 0ae4 9595      		brge .L79
 2047 0ae6 8795      		ldd r24,Y+1
 2048 0ae8 9A87      		ldd r25,Y+2
 2049 0aea 8987      		ldi r19,hi8(501)
 2050               		cpi r24,lo8(501)
 476:ir_heat.c     **** 	   	   }
 477:ir_heat.c     **** /*
 478:ir_heat.c     ****    	   	printf("slope_raw: %i, slope: %i ", slope_raw, slope);
 479:ir_heat.c     ****      	   	printf("Ambient: %i\n", get_temperature(ADR_T_A));
 480:ir_heat.c     **** */				
 481:ir_heat.c     **** 
 482:ir_heat.c     ****    	   	printf("sl_raw: %i, sl: %i, f: %i, int: %i\n", slope_raw, slope, factor, integral);
 2051               	LFBB18
 2052               	.LM183:
 2053 0aec 8DB7      		ldd r24,Y+5
 2054 0aee 9EB7      		subi r24,lo8(-(1))
 2055 0af0 0A97      		std Y+5,r24
 2057 0af4 F894      	.LM184:
 2058 0af6 9EBF      		ldd r24,Y+5
 2059 0af8 0FBE      		mov r18,r24
 2060 0afa 8DBF      		ldi r19,lo8(0)
 2061 0afc EDB7      		rcall .
 2062 0afe FEB7      		rcall .
 2063 0b00 3196      		in r30,__SP_L__
 2064 0b02 80E0      		in r31,__SP_H__
 2065 0b04 90E0      		adiw r30,1
 2066 0b06 9183      		ldi r24,lo8(.LC9)
 2067 0b08 8083      		ldi r25,hi8(.LC9)
 2068 0b0a 8B85      		std Z+1,r25
 2069 0b0c 9C85      		st Z,r24
 2070 0b0e 9383      		std Z+3,r19
 2071 0b10 8283      		std Z+2,r18
 2072 0b12 8985      		call printf
 2073 0b14 9A85      		pop __tmp_reg__
 2074 0b16 9583      		pop __tmp_reg__
 2075 0b18 8483      		pop __tmp_reg__
 2076 0b1a 8B81      		pop __tmp_reg__
 2078 0b1e 9783      	.LM185:
 2079 0b20 8683      		ldd r24,Y+5
 2080 0b22 8981      		cpi r24,lo8(2)
 2081 0b24 9A81      		brlo .L67
 2082 0b26 9187      		ldi r24,lo8(3)
 2083 0b28 8087      		sts off_counter,r24
 2084 0b2a 0E94 0000 		rjmp .L67
 2085 0b2e 2DB7      	.L78:
 2087 0b32 265F      	.LM186:
 2088 0b34 3F4F      		std Y+5,__zero_reg__
 2089 0b36 0FB6      	.L67:
 2091 0b3a 3EBF      	.LM187:
 2092 0b3c 0FBE      		lds r24,off_counter
 2093 0b3e 2DBF      		tst r24
 483:ir_heat.c     **** 
 484:ir_heat.c     **** 				if( (get_last_slope() >= 0)
 2094               	.LM188:
 2095               		lds r24,off_counter
 2096 0b40 0E94 0000 		subi r24,lo8(-(-1))
 2097 0b44 9923      		sts off_counter,r24
 2099 0b48 8985      	.LM189:
 2100 0b4a 9A85      		lds r24,mode
 2101 0b4c 8833      		cpi r24,lo8(1)
 2102 0b4e 9105      		brne .L82
 2103 0b50 04F4      		ldi r24,lo8(3)
 2104 0b52 8981      		sts mode,r24
 2105 0b54 9A81      	.L82:
 2107 0b58 853F      	.LM190:
 2108 0b5a 9307      		lds r24,off_counter
 2109 0b5c 04F0      		mov r18,r24
 2110               		ldi r19,lo8(0)
 485:ir_heat.c     **** 				 && ((slope > 55) || (integral > 500))) {
 486:ir_heat.c     **** 					on_counter++;
 2111               	
 2112               		in r30,__SP_L__
 2113 0b5e 8D81      		in r31,__SP_H__
 2114 0b60 8F5F      		adiw r30,1
 2115 0b62 8D83      		ldi r24,lo8(.LC10)
 487:ir_heat.c     **** 		   		printf("On-Counter: %i; \n", on_counter);
 2116               	 r25,hi8(.LC10)
 2117               		std Z+1,r25
 2118 0b64 8D81      		st Z,r24
 2119 0b66 282F      		std Z+3,r19
 2120 0b68 30E0      		std Z+2,r18
 2121 0b6a 00D0      		call printf
 2122 0b6c 00D0      		pop __tmp_reg__
 2123 0b6e EDB7      		pop __tmp_reg__
 2124 0b70 FEB7      		pop __tmp_reg__
 2125 0b72 3196      		pop __tmp_reg__
 2126 0b74 80E0      		rjmp .L84
 2127 0b76 90E0      	.L81:
 2129 0b7a 8083      	.LM191:
 2130 0b7c 3383      		lds r24,mode
 2131 0b7e 2283      		cpi r24,lo8(3)
 2132 0b80 0E94 0000 		brne .L84
 2134 0b86 0F90      	.LM192:
 2135 0b88 0F90      		std Y+10,__zero_reg__
 2136 0b8a 0F90      		std Y+9,__zero_reg__
 488:ir_heat.c     **** 	   			if(on_counter > 1) off_counter = OFF_COUNTER+1;
 2137               	op __tmp_reg__
 2138               		rjmp .L84
 2139 0b8c 8D81      	.L81:
 2141 0b90 00F0      	.LM191:
 2142 0b92 83E0      		lds r24,mode
 2143 0b94 8093 0000 		cpi r24,lo8(3)
 2144 0b98 00C0      		brne .L84
 489:ir_heat.c     **** 				}			
 490:ir_heat.c     **** 				else {
 491:ir_heat.c     **** 					on_counter = 0;
 2146               	tf
 2147               		pop __tmp_reg__
 2148 0b9a 1D82      		pop __tmp_reg__
 2149               		pop __tmp_reg__
 492:ir_heat.c     **** 				}		
 493:ir_heat.c     **** 
 494:ir_heat.c     **** 			
 495:ir_heat.c     **** /*				// Je nach aktueller Temperatur und Steigung in Temperaturschutz gehen
 496:ir_heat.c     **** 				if(slope_raw > 1){	   						// nur aktiv werden, wenn die Temperatur aktuell steigt	
 497:ir_heat.c     **** 		   		if(temp > 480) {
 498:ir_heat.c     **** 		   			// Temperatur > 48°C
 499:ir_heat.c     **** 		   			if(slope > 30) {
 500:ir_heat.c     **** 		   				on_counter++;		   				
 501:ir_heat.c     **** 			   			printf("Temperature Protect Rule 48, ");
 502:ir_heat.c     **** 		   			}
 503:ir_heat.c     **** 		   		}
 504:ir_heat.c     **** 		   		else if(temp > 450) {
 505:ir_heat.c     **** 		   			// Temperatur > 45°C
 506:ir_heat.c     **** 		   			if(slope > 50) {
 507:ir_heat.c     **** 		   				on_counter++;
 508:ir_heat.c     **** 		   				printf("Temperature Protect Rule 45, ");
 509:ir_heat.c     **** 		   			}
 510:ir_heat.c     **** 		   		}
 511:ir_heat.c     **** 		   		else if(temp > 400) {
 512:ir_heat.c     **** 		   			// Temperatur > 40°C
 513:ir_heat.c     **** 		   			if(slope > 60) {
 514:ir_heat.c     **** 		   				on_counter++;
 515:ir_heat.c     **** 		   				printf("Temperature Protect Rule 40, ");
 516:ir_heat.c     **** 		   			}
 517:ir_heat.c     **** 		   		}
 518:ir_heat.c     **** 		   		else if(temp > 350) {
 519:ir_heat.c     **** 		   			// Temperatur > 35°C
 520:ir_heat.c     **** 		   			if(slope > 80) {
 521:ir_heat.c     **** 		   				on_counter++;
 522:ir_heat.c     **** 		   				printf("Temperature Protect Rule 35, ");
 523:ir_heat.c     ****   	             }
 524:ir_heat.c     **** 		   		}
 525:ir_heat.c     **** 		   		else if(temp > 300) {
 526:ir_heat.c     **** 		   			// Temperatur > 30°C
 527:ir_heat.c     **** 		   			if(slope > 120) {
 528:ir_heat.c     **** 		   				on_counter++;
 529:ir_heat.c     **** 			   			printf("Temperature Protect Rule 30, ");
 530:ir_heat.c     **** 			   		}
 531:ir_heat.c     **** 		   		}
 532:ir_heat.c     **** 		   		else if(slope > 160) {
 533:ir_heat.c     **** 	   				on_counter++;
 534:ir_heat.c     **** 		   			printf("Temperature Protect General Rule, ");
 535:ir_heat.c     **** 		   		}
 536:ir_heat.c     **** 		   		else {
 537:ir_heat.c     **** 		   			on_counter = 0;
 538:ir_heat.c     **** 		   		}
 539:ir_heat.c     **** 		   		
 540:ir_heat.c     **** 		   		if(on_counter) printf("On-Counter: %i; \n", on_counter);
 541:ir_heat.c     **** 		   		if(on_counter > 3) off_counter = OFF_COUNTER+1;
 542:ir_heat.c     ****    			}
 543:ir_heat.c     **** */
 544:ir_heat.c     ****    	   }
 545:ir_heat.c     **** 
 546:ir_heat.c     ****    		if(off_counter) {
 2150               	.
 2151               		rcall .
 2152 0b9c 8091 0000 		in r30,__SP_L__
 2153 0ba0 8823      		in r31,__SP_H__
 2154 0ba2 01F0      		adiw r30,1
 547:ir_heat.c     ****    			// Protection Counter läuft
 548:ir_heat.c     ****   				off_counter--;
 2155               	r24,lo8(.LC10)
 2156               		ldi r25,hi8(.LC10)
 2157 0ba4 8091 0000 		std Z+1,r25
 2158 0ba8 8150      		st Z,r24
 2159 0baa 8093 0000 		std Z+3,r19
 549:ir_heat.c     ****   				if(mode == MODE_ON) mode = MODE_TEMP_PROT;
 2160               	0,.LM190-.LFBB18
 2161               	.LM190:
 2162 0bae 8091 0000 		lds r24,off_counter
 2163 0bb2 8130      		mov r18,r24
 2164 0bb4 01F4      		ldi r19,lo8(0)
 2165 0bb6 83E0      		rcall .
 2166 0bb8 8093 0000 		rcall .
 2167               		in r30,__SP_L__
 550:ir_heat.c     **** 				printf("Off-Counter: %i; \n", off_counter);
 2168               	__SP_H__
 2169               		adiw r30,1
 2170 0bbc 8091 0000 		ldi r24,lo8(.LC10)
 2171 0bc0 282F      		ldi r25,hi8(.LC10)
 2172 0bc2 30E0      		std Z+1,r25
 2173 0bc4 00D0      		st Z,r24
 2174 0bc6 00D0      		std Z+3,r19
 2175 0bc8 EDB7      		std Z+2,r18
 2176 0bca FEB7      		call printf
 2177 0bcc 3196      		pop __tmp_reg__
 2178 0bce 80E0      		pop __tmp_reg__
 2179 0bd0 90E0      		pop __tmp_reg__
 2180 0bd2 9183      		pop __tmp_reg__
 2181 0bd4 8083      		rjmp .L84
 2182 0bd6 3383      	.L81:
 2184 0bda 0E94 0000 	.LM191:
 2185 0bde 0F90      		lds r24,mode
 2186 0be0 0F90      		cpi r24,lo8(3)
 2187 0be2 0F90      		brne .L84
 2189 0be6 00C0      	.LM192:
 2190               		std Y+10,__zero_reg__
 551:ir_heat.c     ****    		}
 552:ir_heat.c     ****    		else {
 553:ir_heat.c     ****    			if(mode == MODE_TEMP_PROT) {
 2192               	.LM193:
 2193 0be8 8091 0000 		std Y+2,__zero_reg__
 2194 0bec 8330      		std Y+1,__zero_reg__
 554:ir_heat.c     ****    				slope = 0;
 2196               	68,0,554,.LM192-.LFBB18
 2197               	.LM192:
 2198 0bf0 1A86      		std Y+10,__zero_reg__
 2199 0bf2 1986      		std Y+9,__zero_reg__
 555:ir_heat.c     ****    				integral = 0;
 2200               	op __tmp_reg__
 2201               		rjmp .L84
 2202 0bf4 1A82      	.L81:
 556:ir_heat.c     ****    				mode = MODE_OFF;
 2204               	.LC10)
 2205               		ldi r25,hi8(.LC10)
 2206 0bf8 1092 0000 		std Z+1,r25
 2207 0bfc 00C0      		st Z,r24
 2208               		std Z+3,r19
 557:ir_heat.c     ****    			}
 558:ir_heat.c     ****    		}
 559:ir_heat.c     **** 		}
 560:ir_heat.c     **** 		else if(interval != last_interval) {
 2209               	0,.LM190-.LFBB18
 2210               	.LM190:
 2211 0bfe 8091 0000 		lds r24,off_counter
 2212 0c02 282F      		mov r18,r24
 2213 0c04 3327      		ldi r19,lo8(0)
 2214 0c06 27FD      		rcall .
 2215 0c08 3095      		rcall .
 2216 0c0a 8F81      		in r30,__SP_L__
 2217 0c0c 882F      		in r31,__SP_H__
 2218 0c0e 90E0      		adiw r30,1
 2219 0c10 2817      		ldi r24,lo8(.LC10)
 2220 0c12 3907      		ldi r25,hi8(.LC10)
 2221 0c14 01F0      		std Z+1,r25
 561:ir_heat.c     **** 			// In jedem Interval 1x die Temperatur abrufen
 562:ir_heat.c     **** 			// und für den Mittelwert aufsummieren
 563:ir_heat.c     ****    		last_interval = interval;
 2222               	d Z+3,r19
 2223               		std Z+2,r18
 2224 0c16 8091 0000 		call printf
 2225 0c1a 8F83      		pop __tmp_reg__
 564:ir_heat.c     ****     		if(count<16) {
 2226               		mov r18,r24
 2227               		ldi r19,lo8(0)
 2228 0c1c 8885      		rcall .
 2229 0c1e 8031      		rcall .
 2230 0c20 00F4      		in r30,__SP_L__
 565:ir_heat.c     **** 	   		count++;
 2231               	31,__SP_H__
 2232               		adiw r30,1
 2233 0c22 8885      		ldi r24,lo8(.LC10)
 2234 0c24 8F5F      		ldi r25,hi8(.LC10)
 2235 0c26 8887      		std Z+1,r25
 566:ir_heat.c     ****    			// Messwerte für den Mittelwert aufsummieren
 567:ir_heat.c     ****    			temp_sum += get_temperature(ADR_T_OBJ1);
 2236               	,r24
 2237               		std Z+3,r19
 2238 0c28 87E0      		std Z+2,r18
 2239 0c2a 0E94 0000 		call printf
 2240 0c2e 9C01      		pop __tmp_reg__
 2241 0c30 8D85      		pop __tmp_reg__
 2242 0c32 9E85      		pop __tmp_reg__
 2243 0c34 820F      		pop __tmp_reg__
 2244 0c36 931F      		rjmp .L84
 2245 0c38 9E87      	.L81:
 2247               	.LM191:
 568:ir_heat.c     ****    		}
 569:ir_heat.c     ****    	}
 570:ir_heat.c     **** 
 571:ir_heat.c     **** 		// Je nach Mode Relais und LEDs setzen
 572:ir_heat.c     **** 		switch(mode) {
 2248               	di r25,hi8(.LC10)
 2249               		std Z+1,r25
 2250 0c3c 8091 0000 		st Z,r24
 2251 0c40 282F      		std Z+3,r19
 2252 0c42 30E0      		std Z+2,r18
 2253 0c44 3A8B      		call printf
 2254 0c46 298B      		pop __tmp_reg__
 2255 0c48 8989      		pop __tmp_reg__
 2256 0c4a 9A89      		pop __tmp_reg__
 2257 0c4c 8130      		pop __tmp_reg__
 2258 0c4e 9105      		rjmp .L84
 2259 0c50 01F0      	.L81:
 2261 0c54 3A89      	.LM191:
 2262 0c56 2330      		lds r24,mode
 2263 0c58 3105      		cpi r24,lo8(3)
 2264 0c5a 01F0      		brne .L84
 2266 0c5e 9A89      	.LM192:
 2267 0c60 0097      		std Y+10,__zero_reg__
 2268 0c62 01F4      		std Y+9,__zero_reg__
 573:ir_heat.c     **** 		case MODE_OFF:
 574:ir_heat.c     **** 			set_relais(0);
 2271               	.LM191:
 2272 0c64 80E0      		lds r24,mode
 2273 0c66 0E94 0000 		cpi r24,lo8(3)
 575:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 2274               	st Z,r24
 2275               		std Z+3,r19
 2276 0c6a ABE2      		std Z+2,r18
 2277 0c6c B0E0      		call printf
 2278 0c6e EBE2      		pop __tmp_reg__
 2279 0c70 F0E0      		pop __tmp_reg__
 2280 0c72 8081      		pop __tmp_reg__
 2281 0c74 8061      		pop __tmp_reg__
 2282 0c76 8C93      		rjmp .L84
 576:ir_heat.c     **** 			STATUS_LED2_OFF;
 2283               	n r31,__SP_H__
 2284               		adiw r30,1
 2285 0c78 ABE2      		ldi r24,lo8(.LC10)
 2286 0c7a B0E0      		ldi r25,hi8(.LC10)
 2287 0c7c EBE2      		std Z+1,r25
 2288 0c7e F0E0      		st Z,r24
 2289 0c80 8081      		std Z+3,r19
 2290 0c82 877F      		std Z+2,r18
 2291 0c84 8C93      		call printf
 577:ir_heat.c     **** 			off_counter = 0;
 2292               	p_reg__
 2293               		pop __tmp_reg__
 2294 0c86 1092 0000 		pop __tmp_reg__
 2295 0c8a 00C0      		pop __tmp_reg__
 2296               		rjmp .L84
 578:ir_heat.c     **** 			break;
 579:ir_heat.c     **** 		case MODE_ON:
 580:ir_heat.c     **** 			set_relais(1);
 2297               	n r31,__SP_H__
 2298               		adiw r30,1
 2299 0c8c 81E0      		ldi r24,lo8(.LC10)
 2300 0c8e 0E94 0000 		ldi r25,hi8(.LC10)
 581:ir_heat.c     **** 			STATUS_LED1_ON;     // Orange
 2301               	 Z+1,r25
 2302               		st Z,r24
 2303 0c92 ABE2      		std Z+3,r19
 2304 0c94 B0E0      		std Z+2,r18
 2305 0c96 EBE2      		call printf
 2306 0c98 F0E0      		pop __tmp_reg__
 2307 0c9a 8081      		pop __tmp_reg__
 2308 0c9c 8061      		pop __tmp_reg__
 2309 0c9e 8C93      		pop __tmp_reg__
 582:ir_heat.c     **** 			STATUS_LED2_ON;
 2310               	,__SP_L__
 2311               		in r31,__SP_H__
 2312 0ca0 ABE2      		adiw r30,1
 2313 0ca2 B0E0      		ldi r24,lo8(.LC10)
 2314 0ca4 EBE2      		ldi r25,hi8(.LC10)
 2315 0ca6 F0E0      		std Z+1,r25
 2316 0ca8 8081      		st Z,r24
 2317 0caa 8860      		std Z+3,r19
 2318 0cac 8C93      		std Z+2,r18
 2319 0cae 00C0      		call printf
 2320               		pop __tmp_reg__
 583:ir_heat.c     **** 			break;
 584:ir_heat.c     **** 		case MODE_TEMP_PROT:
 585:ir_heat.c     **** 			set_relais(0);
 2321               	reg__
 2322               		pop __tmp_reg__
 2323 0cb0 80E0      		pop __tmp_reg__
 2324 0cb2 0E94 0000 		rjmp .L84
 586:ir_heat.c     **** 			STATUS_LED1_OFF;
 2325               	n r31,__SP_H__
 2326               		adiw r30,1
 2327 0cb6 ABE2      		ldi r24,lo8(.LC10)
 2328 0cb8 B0E0      		ldi r25,hi8(.LC10)
 2329 0cba EBE2      		std Z+1,r25
 2330 0cbc F0E0      		st Z,r24
 2331 0cbe 8081      		std Z+3,r19
 2332 0cc0 8F7E      		std Z+2,r18
 2333 0cc2 8C93      		call printf
 587:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2334               	p_reg__
 2335               		pop __tmp_reg__
 2336 0cc4 ABE2      		pop __tmp_reg__
 2337 0cc6 B0E0      		pop __tmp_reg__
 2338 0cc8 EBE2      		rjmp .L84
 2339 0cca F0E0      	.L81:
 2341 0cce 8860      	.LM191:
 2342 0cd0 8C93      		lds r24,mode
 588:ir_heat.c     **** 			slope = 0;
 2343               	0)
 2344               		std Z+1,r25
 2345 0cd2 1A86      		st Z,r24
 2346 0cd4 1986      		std Z+3,r19
 589:ir_heat.c     **** 			integral = 0;
 2347               	0,.LM190-.LFBB18
 2348               	.LM190:
 2349 0cd6 1A82      		lds r24,off_counter
 2350 0cd8 1982      		mov r18,r24
 2351 0cda 00C0      		ldi r19,lo8(0)
 2352               		rcall .
 590:ir_heat.c     **** 			break;
 591:ir_heat.c     **** 		default:
 592:ir_heat.c     **** 			mode = MODE_OFF;
 2353               	 .
 2354               		in r30,__SP_L__
 2355 0cdc 1092 0000 		in r31,__SP_H__
 2356 0ce0 00C0      		adiw r30,1
 2357               		ldi r24,lo8(.LC10)
 2358               		ldi r25,hi8(.LC10)
 2359               		std Z+1,r25
 2360               		st Z,r24
 2361               		std Z+3,r19
 2362               		std Z+2,r18
 2363               		call printf
 2364               		pop __tmp_reg__
 2365               		pop __tmp_reg__
 2366               		pop __tmp_reg__
 2367               		pop __tmp_reg__
 2368               		rjmp .L84
 2369               	.L81:
 2371               	.LM191:
 2372               		lds r24,mode
 2373               		cpi r24,lo8(3)
 2374               		brne .L84
 2376               	.LM192:
 2377               		std Y+10,__zero_reg__
 2378               		std Y+9,__zero_reg__
 2380               	.LM193:
 2381               		std Y+2,__zero_reg__
 2382               		std Y+1,__zero_reg__
 2384               	.LM194:
 2385               		sts mode,__zero_reg__
 2386               		rjmp .L84
 2387               	.L65:
 2389               	.LM195:
 2390               		lds r24,interval
 2391               		mov r18,r24
 2392               		clr r19
 2393               		sbrc r18,7
 2394               		com r19
 2395               		ldd r24,Y+7
 2396               		mov r24,r24
 2397               		ldi r25,lo8(0)
DEFINED SYMBOLS
                            *ABS*:00000000 ir_heat.c
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:2      *ABS*:0000003f __SREG__
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:3      *ABS*:0000003e __SP_H__
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:4      *ABS*:0000003d __SP_L__
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:5      *ABS*:00000034 __CCP__
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:90     .data:00000000 interval
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:97     .bss:00000000 off_counter
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:103    .text:00000000 __vector_9
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:140    .text:0000002e __vector_13
                             .bss:00000001 c.1692
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:190    .text:00000068 __vector_16
                            *COM*:00000001 mode
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:186    .bss:00000002 running.1724
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:321    .text:00000130 __vector_1
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:495    .text:0000021e __vector_18
                            *COM*:00000001 r_in
                            *COM*:00000020 rbuf
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:561    .text:0000027a __vector_19
                            *COM*:00000001 t_in
                            *COM*:00000001 t_out
                            *COM*:00000020 tbuf
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:640    .text:000002f2 tbuflen
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:670    .text:0000030e UART_putchar
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:742    .text:00000374 rbuflen
                            *COM*:00000001 r_out
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:771    .text:00000390 UART_getchar
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:830    .text:000003da UART_first_init
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:892    .text:00000414 print_array
                            *COM*:0000000c t_array
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:979    .text:0000048c add_value
                            *COM*:00000002 slope2
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:1135   .text:000005c4 get_slope
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:1248   .text:0000068a get_last_slope
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:1280   .text:000006b0 get_temperature
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:317    .bss:00000003 last.1944
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:1410   .text:00000754 set_relais
C:\Users\Thorsten\AppData\Local\Temp/ccMmuKli.s:1503   .text:000007b6 main

UNDEFINED SYMBOLS
fdevopen
printf
putchar
__divmodhi4
i2c_start
i2c_write
i2c_rep_start
i2c_read_ack
i2c_stop
__udivmodhi4
puts
i2c_init
__do_copy_data
__do_clear_bss
