   1               		.file	"ir_heat.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  91               	.global	__vector_9
  93               	__vector_9:
   1:ir_heat.c     **** // ***********************************************************
   2:ir_heat.c     **** // Project:
   3:ir_heat.c     **** // Author:
   4:ir_heat.c     **** // Module description:
   5:ir_heat.c     **** // ***********************************************************
   6:ir_heat.c     **** 
   7:ir_heat.c     **** #ifndef F_CPU
   8:ir_heat.c     **** #define F_CPU 2000000UL
   9:ir_heat.c     **** #endif
  10:ir_heat.c     **** 
  11:ir_heat.c     **** #include <avr\io.h>              // Most basic include files
  12:ir_heat.c     **** #include <avr\interrupt.h>       // Add the necessary ones
  13:ir_heat.c     **** //#include <avr\signal.h>          // here
  14:ir_heat.c     **** #include <avr\wdt.h>
  15:ir_heat.c     **** 
  16:ir_heat.c     **** #include <stdio.h>
  17:ir_heat.c     **** #include <string.h>
  18:ir_heat.c     **** #include <stdlib.h>
  19:ir_heat.c     **** #include <avr/power.h>
  20:ir_heat.c     **** #include	<util/delay.h>
  21:ir_heat.c     **** 
  22:ir_heat.c     **** #include "i2c_mast.h"
  23:ir_heat.c     **** #include "ir_heat.h"
  24:ir_heat.c     **** 
  25:ir_heat.c     **** #define 	MLX90614_WRITE	(0x5A<<1)
  26:ir_heat.c     **** #define 	MLX90614_READ	(MLX90614_WRITE+1)
  27:ir_heat.c     **** #define	ADR_T_A			0x06
  28:ir_heat.c     **** #define	ADR_T_OBJ1		0x07
  29:ir_heat.c     **** #define	ADR_T_OBJ2		0x08
  30:ir_heat.c     **** #define	DEFAULT_TEMP	150
  31:ir_heat.c     **** 
  32:ir_heat.c     **** 
  33:ir_heat.c     **** #define __STDIO_FDEVOPEN_COMPAT_12						
  34:ir_heat.c     **** // Buffer sizes must be 2^n
  35:ir_heat.c     **** //
  36:ir_heat.c     **** #define TBUFSIZE			32
  37:ir_heat.c     **** #define RBUFSIZE			32
  38:ir_heat.c     **** 
  39:ir_heat.c     **** #define TMASK				(TBUFSIZE-1)
  40:ir_heat.c     **** #define RMASK				(RBUFSIZE-1)
  41:ir_heat.c     **** 
  42:ir_heat.c     **** #define FLASH_LED			PC3
  43:ir_heat.c     **** #define STATUS_LED1		PD4
  44:ir_heat.c     **** #define STATUS_LED2		PD3
  45:ir_heat.c     **** #define RELAIS				PB6
  46:ir_heat.c     **** #define BUZZER				PB7
  47:ir_heat.c     **** #define SWITCH				PD2
  48:ir_heat.c     **** 
  49:ir_heat.c     **** #define RELAIS_ON			PORTB |= (1<<RELAIS)
  50:ir_heat.c     **** #define RELAIS_OFF		PORTB &=~(1<<RELAIS)
  51:ir_heat.c     **** 
  52:ir_heat.c     **** #define BUZZER_ON			PORTB |= (1<<BUZZER)
  53:ir_heat.c     **** #define BUZZER_OFF		PORTB &=~(1<<BUZZER)
  54:ir_heat.c     **** 
  55:ir_heat.c     **** #define STATUS_LED1_ON	PORTD |= (1<<STATUS_LED1)
  56:ir_heat.c     **** #define STATUS_LED1_OFF	PORTD &=~(1<<STATUS_LED1)
  57:ir_heat.c     **** 
  58:ir_heat.c     **** #define FLASH_LED_ON		PORTC |= (1<<FLASH_LED)
  59:ir_heat.c     **** #define FLASH_LED_OFF	PORTC &=~(1<<FLASH_LED)
  60:ir_heat.c     **** 
  61:ir_heat.c     **** #define STATUS_LED2_ON	PORTD |= (1<<STATUS_LED2)
  62:ir_heat.c     **** #define STATUS_LED2_OFF	PORTD &=~(1<<STATUS_LED2)
  63:ir_heat.c     **** 
  64:ir_heat.c     **** #define OFF_COUNTER		2
  65:ir_heat.c     **** 
  66:ir_heat.c     **** #define TIMER1_STOP		TCCR1B = 0
  67:ir_heat.c     **** #define TIMER1_RUN		TCCR1B = (0<<CS12) | (1<<CS11) | (0<<CS10)
  68:ir_heat.c     **** 
  69:ir_heat.c     **** #define	MODE_OFF				0
  70:ir_heat.c     **** #define	MODE_ON				1
  71:ir_heat.c     **** #define	MODE_ON_NO_PROT	2
  72:ir_heat.c     **** #define	MODE_TEMP_PROT		3
  73:ir_heat.c     **** 
  74:ir_heat.c     **** #define	BEEP_SHORT			1
  75:ir_heat.c     **** #define	BEEP_2SHORT			2
  76:ir_heat.c     **** #define	BEEP_LONG			3
  77:ir_heat.c     **** #define	BEEP_XLONG			4
  78:ir_heat.c     **** #define	BEEP_2LONG			5
  79:ir_heat.c     **** #define	BEEP_SHORT_LONG	6
  80:ir_heat.c     **** 
  81:ir_heat.c     **** // Define here the global static variables
  82:ir_heat.c     **** //
  83:ir_heat.c     **** volatile unsigned char tbuf[TBUFSIZE];  // TX buffer
  84:ir_heat.c     **** volatile unsigned char rbuf[RBUFSIZE];  // RX buffer
  85:ir_heat.c     **** 
  86:ir_heat.c     **** volatile unsigned char t_in;            // TX buffer in index
  87:ir_heat.c     **** volatile unsigned char t_out;           // TX buffer out index
  88:ir_heat.c     **** 
  89:ir_heat.c     **** volatile unsigned char r_in;            // RX buffer in index
  90:ir_heat.c     **** volatile unsigned char r_out;           // RX buffer out index
  91:ir_heat.c     **** 
  92:ir_heat.c     **** int8_t	interval = -12;
  93:ir_heat.c     **** int16_t 	t_array[6];
  94:ir_heat.c     **** uint8_t	off_counter = 0;
  95:ir_heat.c     **** uint8_t	mode;
  96:ir_heat.c     **** int16_t	slope2;
  97:ir_heat.c     **** uint8_t	flash_button = 0;
  98:ir_heat.c     **** uint8_t	flash_LED = 0;
  99:ir_heat.c     **** 
 100:ir_heat.c     **** /*
 101:ir_heat.c     **** uint16_t	t_la_threshold_up 	=  300;
 102:ir_heat.c     **** uint16_t	t_abs_threshold_up 	=  270;
 103:ir_heat.c     **** uint16_t	t_la_threshold_down 	=  250;
 104:ir_heat.c     **** uint16_t	t_abs_threshold_down	=  250;
 105:ir_heat.c     **** */
 106:ir_heat.c     **** 
 107:ir_heat.c     **** 
 108:ir_heat.c     **** // Clock Timer
 109:ir_heat.c     **** SIGNAL(SIG_OVERFLOW2) {
  94               		68,0,109,.LM0-.LFBB1
  95               	.LM0:
  96               	.LFBB1:
  97 0000 1F92      		push __zero_reg__
  98 0002 0F92      		push r0
  99 0004 0FB6      		in r0,__SREG__
 100 0006 0F92      		push r0
 101 0008 1124      		clr __zero_reg__
 102 000a 8F93      		push r24
 103               	/* prologue: Signal */
 104               	/* frame size = 0 */
 110:ir_heat.c     **** 	interval++;
 105               	0,110,.LM1-.LFBB1
 106               	.LM1:
 107 000c 8091 0000 		lds r24,interval
 108 0010 8F5F      		subi r24,lo8(-(1))
 109 0012 8093 0000 		sts interval,r24
 110               	/* epilogue start */
 111:ir_heat.c     **** }
 111               	n	68,0,111,.LM2-.LFBB1
 112               	.LM2:
 113 0016 8F91      		pop r24
 114 0018 0F90      		pop r0
 115 001a 0FBE      		out __SREG__,r0
 116 001c 0F90      		pop r0
 117 001e 1F90      		pop __zero_reg__
 118 0020 1895      		reti
 120               	.Lscope1:
 122               	.global	__vector_13
 124               	__vector_13:
 112:ir_heat.c     **** 
 113:ir_heat.c     **** SIGNAL(SIG_OVERFLOW1) {
 125               	13,.LM3-.LFBB2
 126               	.LM3:
 127               	.LFBB2:
 128 0022 1F92      		push __zero_reg__
 129 0024 0F92      		push r0
 130 0026 0FB6      		in r0,__SREG__
 131 0028 0F92      		push r0
 132 002a 1124      		clr __zero_reg__
 133               	/* prologue: Signal */
 134               	/* frame size = 0 */
 114:ir_heat.c     **** 	TIMER1_STOP;
 135               	,0,114,.LM4-.LFBB2
 136               	.LM4:
 137 002c 1092 8100 		sts 129,__zero_reg__
 115:ir_heat.c     **** 	TCNT1H = 0;
 138               	tabn	68,0,115,.LM5-.LFBB2
 139               	.LM5:
 140 0030 1092 8500 		sts 133,__zero_reg__
 116:ir_heat.c     **** 	TCNT1L = 0;
 141               	tabn	68,0,116,.LM6-.LFBB2
 142               	.LM6:
 143 0034 1092 8400 		sts 132,__zero_reg__
 144               	/* epilogue start */
 117:ir_heat.c     **** }
 145               	abn	68,0,117,.LM7-.LFBB2
 146               	.LM7:
 147 0038 0F90      		pop r0
 148 003a 0FBE      		out __SREG__,r0
 149 003c 0F90      		pop r0
 150 003e 1F90      		pop __zero_reg__
 151 0040 1895      		reti
 153               	.Lscope2:
 155               	.global	__vector_16
 157               	__vector_16:
 118:ir_heat.c     **** 
 119:ir_heat.c     **** 
 120:ir_heat.c     **** // LED Flasher
 121:ir_heat.c     **** SIGNAL(SIG_OVERFLOW0) {
 158               	121,.LM8-.LFBB3
 159               	.LM8:
 160               	.LFBB3:
 161 0042 1F92      		push __zero_reg__
 162 0044 0F92      		push r0
 163 0046 0FB6      		in r0,__SREG__
 164 0048 0F92      		push r0
 165 004a 1124      		clr __zero_reg__
 166 004c 2F93      		push r18
 167 004e 3F93      		push r19
 168 0050 4F93      		push r20
 169 0052 8F93      		push r24
 170 0054 9F93      		push r25
 171 0056 EF93      		push r30
 172 0058 FF93      		push r31
 173               	/* prologue: Signal */
 174               	/* frame size = 0 */
 122:ir_heat.c     **** 	static uint8_t	c1 = 0;
 123:ir_heat.c     **** 	static uint8_t c2 = 0;
 124:ir_heat.c     **** 	uint8_t slow=0;
 125:ir_heat.c     **** 	c1++;
 175               	.LM9-.LFBB3
 176               	.LM9:
 177 005a 8091 0000 		lds r24,c1.1739
 178 005e 282F      		mov r18,r24
 179 0060 2F5F      		subi r18,lo8(-(1))
 180 0062 2093 0000 		sts c1.1739,r18
 126:ir_heat.c     **** 	c2++;
 181               	n	68,0,126,.LM10-.LFBB3
 182               	.LM10:
 183 0066 8091 0000 		lds r24,c2.1740
 184 006a 382F      		mov r19,r24
 185 006c 3F5F      		subi r19,lo8(-(1))
 186 006e 3093 0000 		sts c2.1740,r19
 127:ir_heat.c     **** 	
 128:ir_heat.c     **** 	// Tasten LED
 129:ir_heat.c     **** 	if (mode==MODE_TEMP_PROT) {
 187               	n	68,0,129,.LM11-.LFBB3
 188               	.LM11:
 189 0072 4091 0000 		lds r20,mode
 190 0076 4330      		cpi r20,lo8(3)
 191 0078 01F4      		brne .L6
 130:ir_heat.c     **** 		if(c1 > (6<<slow)) {
 192               	bn	68,0,130,.LM12-.LFBB3
 193               	.LM12:
 194 007a 822F      		mov r24,r18
 195 007c 90E0      		ldi r25,lo8(0)
 196 007e 0797      		sbiw r24,7
 197 0080 04F0      		brlt .L6
 131:ir_heat.c     **** 			FLASH_LED_ON;
 198               	n	68,0,131,.LM13-.LFBB3
 199               	.LM13:
 200 0082 E8E2      		ldi r30,lo8(40)
 201 0084 F0E0      		ldi r31,hi8(40)
 202 0086 8081      		ld r24,Z
 203 0088 8860      		ori r24,lo8(8)
 204 008a 8083      		st Z,r24
 205               	.L6:
 132:ir_heat.c     **** 		}
 133:ir_heat.c     **** 	}
 134:ir_heat.c     **** 	if(c1 > (10<<slow)) {
 206               	68,0,134,.LM14-.LFBB3
 207               	.LM14:
 208 008c 822F      		mov r24,r18
 209 008e 90E0      		ldi r25,lo8(0)
 210 0090 0B97      		sbiw r24,11
 211 0092 04F0      		brlt .L7
 135:ir_heat.c     **** 		c1 = 0;
 212               	n	68,0,135,.LM15-.LFBB3
 213               	.LM15:
 214 0094 1092 0000 		sts c1.1739,__zero_reg__
 136:ir_heat.c     **** 		FLASH_LED_OFF;
 215               	tabn	68,0,136,.LM16-.LFBB3
 216               	.LM16:
 217 0098 E8E2      		ldi r30,lo8(40)
 218 009a F0E0      		ldi r31,hi8(40)
 219 009c 8081      		ld r24,Z
 220 009e 877F      		andi r24,lo8(-9)
 221 00a0 8083      		st Z,r24
 222               	.L7:
 137:ir_heat.c     **** 	}
 138:ir_heat.c     **** 	
 139:ir_heat.c     **** 	// Status LED
 140:ir_heat.c     **** 	if (mode==MODE_ON_NO_PROT) {
 223               	68,0,140,.LM17-.LFBB3
 224               	.LM17:
 225 00a2 4230      		cpi r20,lo8(2)
 226 00a4 01F4      		brne .L8
 141:ir_heat.c     **** 		if(c2 > 120) {
 227               	abn	68,0,141,.LM18-.LFBB3
 228               	.LM18:
 229 00a6 3937      		cpi r19,lo8(121)
 230 00a8 00F0      		brlo .L8
 142:ir_heat.c     **** 			STATUS_LED1_OFF;	// rot
 231               	abn	68,0,142,.LM19-.LFBB3
 232               	.LM19:
 233 00aa EBE2      		ldi r30,lo8(43)
 234 00ac F0E0      		ldi r31,hi8(43)
 235 00ae 8081      		ld r24,Z
 236 00b0 8F7E      		andi r24,lo8(-17)
 237 00b2 8083      		st Z,r24
 238               	.L8:
 143:ir_heat.c     **** 		}
 144:ir_heat.c     **** 	}
 145:ir_heat.c     **** 	if(c2 > 135) {
 239               	68,0,145,.LM20-.LFBB3
 240               	.LM20:
 241 00b4 3838      		cpi r19,lo8(-120)
 242 00b6 00F0      		brlo .L10
 146:ir_heat.c     **** 		c2 = 0;
 243               	abn	68,0,146,.LM21-.LFBB3
 244               	.LM21:
 245 00b8 1092 0000 		sts c2.1740,__zero_reg__
 147:ir_heat.c     **** 		STATUS_LED1_ON; 		// orange
 246               	tabn	68,0,147,.LM22-.LFBB3
 247               	.LM22:
 248 00bc EBE2      		ldi r30,lo8(43)
 249 00be F0E0      		ldi r31,hi8(43)
 250 00c0 8081      		ld r24,Z
 251 00c2 8061      		ori r24,lo8(16)
 252 00c4 8083      		st Z,r24
 253               	.L10:
 254               	/* epilogue start */
 148:ir_heat.c     **** 	}	
 149:ir_heat.c     **** }
 255               	8,0,149,.LM23-.LFBB3
 256               	.LM23:
 257 00c6 FF91      		pop r31
 258 00c8 EF91      		pop r30
 259 00ca 9F91      		pop r25
 260 00cc 8F91      		pop r24
 261 00ce 4F91      		pop r20
 262 00d0 3F91      		pop r19
 263 00d2 2F91      		pop r18
 264 00d4 0F90      		pop r0
 265 00d6 0FBE      		out __SREG__,r0
 266 00d8 0F90      		pop r0
 267 00da 1F90      		pop __zero_reg__
 268 00dc 1895      		reti
 274               	.Lscope3:
 276               	.global	__vector_18
 278               	__vector_18:
 150:ir_heat.c     **** 
 151:ir_heat.c     **** 
 152:ir_heat.c     **** 
 153:ir_heat.c     **** //*******************************************
 154:ir_heat.c     **** //
 155:ir_heat.c     **** // Taster IQR und Entprellung
 156:ir_heat.c     **** //
 157:ir_heat.c     **** SIGNAL(SIG_INTERRUPT0) {
 158:ir_heat.c     **** 	static uint8_t running = 0;
 159:ir_heat.c     **** 	
 160:ir_heat.c     **** 	if(running | TCNT1H | TCNT1L){
 161:ir_heat.c     **** //		printf("X");
 162:ir_heat.c     **** 		return;
 163:ir_heat.c     **** 	}
 164:ir_heat.c     **** 	running = 1;
 165:ir_heat.c     **** 	wdt_reset();
 166:ir_heat.c     **** 	
 167:ir_heat.c     **** 	uint16_t i;
 168:ir_heat.c     **** 	uint16_t c = 0;
 169:ir_heat.c     **** 	EIMSK = 0;
 170:ir_heat.c     **** 	sei();
 171:ir_heat.c     **** 	//printf("In");
 172:ir_heat.c     **** 	for(i=0;i<1000;i++) if((PIND & (1<<SWITCH))) c++;
 173:ir_heat.c     **** 	//printf(" %i ", c);
 174:ir_heat.c     **** 
 175:ir_heat.c     **** 	if(c < 200) {
 176:ir_heat.c     **** 		TCNT1L = 1;
 177:ir_heat.c     **** 		TIMER1_RUN;
 178:ir_heat.c     **** 		switch(mode) {
 179:ir_heat.c     **** 		case MODE_OFF:
 180:ir_heat.c     **** 			mode = MODE_ON;
 181:ir_heat.c     **** 			set_relais(1);
 182:ir_heat.c     **** 			STATUS_LED1_ON;			// orange
 183:ir_heat.c     **** 			STATUS_LED2_ON;
 184:ir_heat.c     **** 			c = 0;
 185:ir_heat.c     **** 			while((!(PIND & (1<<SWITCH))) && (c < 300)) {
 186:ir_heat.c     **** 				c++;
 187:ir_heat.c     **** 				_delay_ms (10);
 188:ir_heat.c     **** 			}
 189:ir_heat.c     **** 			//printf("c: %i", c);
 190:ir_heat.c     **** 
 191:ir_heat.c     **** 			if(c < 300) {
 192:ir_heat.c     **** 				// normal einnschalten
 193:ir_heat.c     **** 				mode = MODE_ON;
 194:ir_heat.c     **** 			}
 195:ir_heat.c     **** 			else {
 196:ir_heat.c     **** 				// einschalten, aber ohne Hitzeschutz
 197:ir_heat.c     **** 				mode = MODE_ON_NO_PROT;
 198:ir_heat.c     **** 				printf("Temperature Protection Off!\n");
 199:ir_heat.c     **** 				STATUS_LED1_OFF;		// rot
 200:ir_heat.c     **** 				STATUS_LED2_ON;
 201:ir_heat.c     **** 				beep(BEEP_SHORT_LONG);
 202:ir_heat.c     **** 			}
 203:ir_heat.c     **** 			break;
 204:ir_heat.c     **** 		case MODE_ON:
 205:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 206:ir_heat.c     **** 		case MODE_TEMP_PROT:
 207:ir_heat.c     **** 		default:
 208:ir_heat.c     **** 			printf("\nxXx\n");
 209:ir_heat.c     **** 			mode = MODE_OFF;
 210:ir_heat.c     **** 		}
 211:ir_heat.c     **** 	}
 212:ir_heat.c     **** //	printf("Out\n");
 213:ir_heat.c     **** 	EIFR 		= (1<<INTF0);
 214:ir_heat.c     **** 	EIMSK 	= (1<<INT0);
 215:ir_heat.c     **** 	running 	= 0;
 216:ir_heat.c     **** 	//printf("Exit\n");
 217:ir_heat.c     **** }
 218:ir_heat.c     **** 
 219:ir_heat.c     **** 
 220:ir_heat.c     **** 
 221:ir_heat.c     **** SIGNAL(SIG_USART_RECV) {
 279               	LFBB4
 280               	.LM24:
 281               	.LFBB4:
 282 00de 1F92      		push __zero_reg__
 283 00e0 0F92      		push r0
 284 00e2 0FB6      		in r0,__SREG__
 285 00e4 0F92      		push r0
 286 00e6 1124      		clr __zero_reg__
 287 00e8 8F93      		push r24
 288 00ea EF93      		push r30
 289 00ec FF93      		push r31
 290               	/* prologue: Signal */
 291               	/* frame size = 0 */
 222:ir_heat.c     **** //******************
 223:ir_heat.c     **** // RX interrupt handler
 224:ir_heat.c     **** //
 225:ir_heat.c     **** 	char c;	
 226:ir_heat.c     **** 	c = UDR0;							// Get received char
 292               	226,.LM25-.LFBB4
 293               	.LM25:
 294 00ee 8091 C600 		lds r24,198
 227:ir_heat.c     **** 	rbuf[r_in & RMASK] = c;
 295               	tabn	68,0,227,.LM26-.LFBB4
 296               	.LM26:
 297 00f2 E091 0000 		lds r30,r_in
 298 00f6 F0E0      		ldi r31,lo8(0)
 299 00f8 EF71      		andi r30,lo8(31)
 300 00fa F070      		andi r31,hi8(31)
 301 00fc E050      		subi r30,lo8(-(rbuf))
 302 00fe F040      		sbci r31,hi8(-(rbuf))
 303 0100 8083      		st Z,r24
 228:ir_heat.c     **** 	r_in++;
 304               	8,0,228,.LM27-.LFBB4
 305               	.LM27:
 306 0102 8091 0000 		lds r24,r_in
 307 0106 8F5F      		subi r24,lo8(-(1))
 308 0108 8093 0000 		sts r_in,r24
 309               	/* epilogue start */
 229:ir_heat.c     **** }
 310               	n	68,0,229,.LM28-.LFBB4
 311               	.LM28:
 312 010c FF91      		pop r31
 313 010e EF91      		pop r30
 314 0110 8F91      		pop r24
 315 0112 0F90      		pop r0
 316 0114 0FBE      		out __SREG__,r0
 317 0116 0F90      		pop r0
 318 0118 1F90      		pop __zero_reg__
 319 011a 1895      		reti
 324               	.Lscope4:
 326               	.global	__vector_19
 328               	__vector_19:
 230:ir_heat.c     **** 
 231:ir_heat.c     **** SIGNAL(SIG_USART_DATA) {
 329               	M29-.LFBB5
 330               	.LM29:
 331               	.LFBB5:
 332 011c 1F92      		push __zero_reg__
 333 011e 0F92      		push r0
 334 0120 0FB6      		in r0,__SREG__
 335 0122 0F92      		push r0
 336 0124 1124      		clr __zero_reg__
 337 0126 8F93      		push r24
 338 0128 9F93      		push r25
 339 012a EF93      		push r30
 340 012c FF93      		push r31
 341               	/* prologue: Signal */
 342               	/* frame size = 0 */
 232:ir_heat.c     **** //*******************
 233:ir_heat.c     **** // Data register empty interrupt handler.
 234:ir_heat.c     **** // Indicates that next char can be transmitted
 235:ir_heat.c     **** //
 236:ir_heat.c     **** 	if(t_in != t_out) {
 343               	36,.LM30-.LFBB5
 344               	.LM30:
 345 012e 9091 0000 		lds r25,t_in
 346 0132 8091 0000 		lds r24,t_out
 347 0136 9817      		cp r25,r24
 348 0138 01F0      		breq .L14
 237:ir_heat.c     **** 		UDR0 = tbuf[t_out & TMASK];
 349               	n	68,0,237,.LM31-.LFBB5
 350               	.LM31:
 351 013a E091 0000 		lds r30,t_out
 352 013e F0E0      		ldi r31,lo8(0)
 353 0140 EF71      		andi r30,lo8(31)
 354 0142 F070      		andi r31,hi8(31)
 355 0144 E050      		subi r30,lo8(-(tbuf))
 356 0146 F040      		sbci r31,hi8(-(tbuf))
 357 0148 8081      		ld r24,Z
 358 014a 8093 C600 		sts 198,r24
 238:ir_heat.c     **** 		t_out++;	
 359               	,0,238,.LM32-.LFBB5
 360               	.LM32:
 361 014e 8091 0000 		lds r24,t_out
 362 0152 8F5F      		subi r24,lo8(-(1))
 363 0154 8093 0000 		sts t_out,r24
 364 0158 00C0      		rjmp .L16
 365               	.L14:
 239:ir_heat.c     **** 	}
 240:ir_heat.c     **** 	else {
 241:ir_heat.c     **** 		UCSR0B &= ~(1<<UDRIE0);
 366               		68,0,241,.LM33-.LFBB5
 367               	.LM33:
 368 015a E1EC      		ldi r30,lo8(193)
 369 015c F0E0      		ldi r31,hi8(193)
 370 015e 8081      		ld r24,Z
 371 0160 8F7D      		andi r24,lo8(-33)
 372 0162 8083      		st Z,r24
 373               	.L16:
 374               	/* epilogue start */
 242:ir_heat.c     **** 	}
 243:ir_heat.c     **** }
 375               	8,0,243,.LM34-.LFBB5
 376               	.LM34:
 377 0164 FF91      		pop r31
 378 0166 EF91      		pop r30
 379 0168 9F91      		pop r25
 380 016a 8F91      		pop r24
 381 016c 0F90      		pop r0
 382 016e 0FBE      		out __SREG__,r0
 383 0170 0F90      		pop r0
 384 0172 1F90      		pop __zero_reg__
 385 0174 1895      		reti
 387               	.Lscope5:
 389               	.global	tbuflen
 391               	tbuflen:
 244:ir_heat.c     **** 
 245:ir_heat.c     **** char tbuflen(void) {
 392               	.LM35-.LFBB6
 393               	.LM35:
 394               	.LFBB6:
 395               	/* prologue: function */
 396               	/* frame size = 0 */
 246:ir_heat.c     **** //****************
 247:ir_heat.c     **** // Retrieve pending chars in TX buffer
 248:ir_heat.c     **** //
 249:ir_heat.c     **** 	return(t_in - t_out);
 397               	bn	68,0,249,.LM36-.LFBB6
 398               	.LM36:
 399 0176 8091 0000 		lds r24,t_in
 400 017a 9091 0000 		lds r25,t_out
 250:ir_heat.c     **** }
 401               	abn	68,0,250,.LM37-.LFBB6
 402               	.LM37:
 403 017e 891B      		sub r24,r25
 404               	/* epilogue start */
 405 0180 0895      		ret
 407               	.Lscope6:
 411               	.global	UART_putchar
 413               	UART_putchar:
 251:ir_heat.c     **** 
 252:ir_heat.c     **** int UART_putchar(char c, FILE *stream) {
 414               	252,.LM38-.LFBB7
 415               	.LM38:
 416               	.LFBB7:
 417 0182 1F93      		push r17
 418 0184 CF93      		push r28
 419 0186 DF93      		push r29
 420               	/* prologue: function */
 421               	/* frame size = 0 */
 422 0188 182F      		mov r17,r24
 253:ir_heat.c     **** //*********************
 254:ir_heat.c     **** // Fills the transmit buffer, if it is full wait
 255:ir_heat.c     **** //
 256:ir_heat.c     **** 	while((TBUFSIZE - tbuflen()) <= 2);  // Wait...
 423               	8,0,256,.LM39-.LFBB7
 424               	.LM39:
 425 018a C0E2      		ldi r28,lo8(32)
 426 018c D0E0      		ldi r29,hi8(32)
 427               	.L20:
 428 018e 0E94 0000 		call tbuflen
 429 0192 9E01      		movw r18,r28
 430 0194 281B      		sub r18,r24
 431 0196 3109      		sbc r19,__zero_reg__
 432 0198 2330      		cpi r18,3
 433 019a 3105      		cpc r19,__zero_reg__
 434 019c 04F0      		brlt .L20
 257:ir_heat.c     **** 	
 258:ir_heat.c     **** 	// Add data to the transmit buffer, enable TXCIE
 259:ir_heat.c     **** 	//
 260:ir_heat.c     **** 	tbuf[t_in & TMASK] = c;
 435               	,260,.LM40-.LFBB7
 436               	.LM40:
 437 019e E091 0000 		lds r30,t_in
 438 01a2 F0E0      		ldi r31,lo8(0)
 439 01a4 EF71      		andi r30,lo8(31)
 440 01a6 F070      		andi r31,hi8(31)
 441 01a8 E050      		subi r30,lo8(-(tbuf))
 442 01aa F040      		sbci r31,hi8(-(tbuf))
 443 01ac 1083      		st Z,r17
 261:ir_heat.c     **** 	t_in++;	
 444               	8,0,261,.LM41-.LFBB7
 445               	.LM41:
 446 01ae 8091 0000 		lds r24,t_in
 447 01b2 8F5F      		subi r24,lo8(-(1))
 448 01b4 8093 0000 		sts t_in,r24
 262:ir_heat.c     **** 	UCSR0B |= (1<<UDRIE0);			// Enable UDR empty interrupt	
 449               	bn	68,0,262,.LM42-.LFBB7
 450               	.LM42:
 451 01b8 E1EC      		ldi r30,lo8(193)
 452 01ba F0E0      		ldi r31,hi8(193)
 453 01bc 8081      		ld r24,Z
 454 01be 8062      		ori r24,lo8(32)
 455 01c0 8083      		st Z,r24
 263:ir_heat.c     **** 	return(0);
 264:ir_heat.c     **** }
 456               		68,0,264,.LM43-.LFBB7
 457               	.LM43:
 458 01c2 80E0      		ldi r24,lo8(0)
 459 01c4 90E0      		ldi r25,hi8(0)
 460               	/* epilogue start */
 461 01c6 DF91      		pop r29
 462 01c8 CF91      		pop r28
 463 01ca 1F91      		pop r17
 464 01cc 0895      		ret
 466               	.Lscope7:
 468               	.global	rbuflen
 470               	rbuflen:
 265:ir_heat.c     **** 
 266:ir_heat.c     **** char rbuflen(void) {
 471               	6,.LM44-.LFBB8
 472               	.LM44:
 473               	.LFBB8:
 474               	/* prologue: function */
 475               	/* frame size = 0 */
 267:ir_heat.c     **** // ***************
 268:ir_heat.c     **** // Retrive pending chars in RX buffer
 269:ir_heat.c     **** //
 270:ir_heat.c     **** 	return(r_in - r_out);
 476               	bn	68,0,270,.LM45-.LFBB8
 477               	.LM45:
 478 01ce 8091 0000 		lds r24,r_in
 479 01d2 9091 0000 		lds r25,r_out
 271:ir_heat.c     **** }
 480               	abn	68,0,271,.LM46-.LFBB8
 481               	.LM46:
 482 01d6 891B      		sub r24,r25
 483               	/* epilogue start */
 484 01d8 0895      		ret
 486               	.Lscope8:
 489               	.global	UART_getchar
 491               	UART_getchar:
 272:ir_heat.c     **** 
 273:ir_heat.c     **** int UART_getchar(FILE *stream) {
 492               	,273,.LM47-.LFBB9
 493               	.LM47:
 494               	.LFBB9:
 495               	/* prologue: function */
 496               	/* frame size = 0 */
 497               	.L26:
 274:ir_heat.c     **** //*******************
 275:ir_heat.c     **** // Retieves character from UART. This function is to be passed
 276:ir_heat.c     **** // to fdevopen
 277:ir_heat.c     **** //
 278:ir_heat.c     **** 	unsigned char c;
 279:ir_heat.c     **** 	while(rbuflen() == 0);	  // Wait...
 498               	n	68,0,279,.LM48-.LFBB9
 499               	.LM48:
 500 01da 0E94 0000 		call rbuflen
 501 01de 8823      		tst r24
 502 01e0 01F0      		breq .L26
 280:ir_heat.c     **** 	c = rbuf[r_out & RMASK];
 503               	bn	68,0,280,.LM49-.LFBB9
 504               	.LM49:
 505 01e2 E091 0000 		lds r30,r_out
 506 01e6 F0E0      		ldi r31,lo8(0)
 507 01e8 EF71      		andi r30,lo8(31)
 508 01ea F070      		andi r31,hi8(31)
 509 01ec E050      		subi r30,lo8(-(rbuf))
 510 01ee F040      		sbci r31,hi8(-(rbuf))
 511 01f0 8081      		ld r24,Z
 281:ir_heat.c     **** 	r_out++;	
 512               	8,0,281,.LM50-.LFBB9
 513               	.LM50:
 514 01f2 9091 0000 		lds r25,r_out
 515 01f6 9F5F      		subi r25,lo8(-(1))
 516 01f8 9093 0000 		sts r_out,r25
 282:ir_heat.c     **** 	return(c);
 283:ir_heat.c     **** }
 517               	bn	68,0,283,.LM51-.LFBB9
 518               	.LM51:
 519 01fc 90E0      		ldi r25,lo8(0)
 520               	/* epilogue start */
 521 01fe 0895      		ret
 526               	.Lscope9:
 529               	.global	exp_slope
 531               	exp_slope:
 284:ir_heat.c     **** 
 285:ir_heat.c     **** void UART_first_init(void) {
 286:ir_heat.c     **** //***********************
 287:ir_heat.c     **** // The function fdevopen(..) must contain as parameters the
 288:ir_heat.c     **** // corresponding  ..putchar() and  ..getchar() functions, defined before.
 289:ir_heat.c     **** //
 290:ir_heat.c     **** 	UBRR0 = 12;										 		// 4800 BPS
 291:ir_heat.c     **** 	
 292:ir_heat.c     **** 	//UCSR0A |= (1<<U2X0);
 293:ir_heat.c     **** 	UCSR0B = (1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0);	// 8 Databits, receive and transmit enabled, receive a
 294:ir_heat.c     **** 	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
 295:ir_heat.c     **** 	
 296:ir_heat.c     **** 	fdevopen(UART_putchar, UART_getchar);
 297:ir_heat.c     **** 	sei();											 		// Global interrupt enable
 298:ir_heat.c     **** }
 299:ir_heat.c     **** 
 300:ir_heat.c     **** 
 301:ir_heat.c     **** 
 302:ir_heat.c     **** 
 303:ir_heat.c     **** int16_t exp_slope(int16_t temp) {
 532               	3,.LM52-.LFBB10
 533               	.LM52:
 534               	.LFBB10:
 535               	/* prologue: function */
 536               	/* frame size = 0 */
 538               	.LM53:
 539 0200 2227      		clr r18
 540 0202 3327      		clr r19
 541 0204 281B      		sub r18,r24
 542 0206 390B      		sbc r19,r25
 543 0208 02F4      		brpl .L30
 544 020a 215F      		subi r18,lo8(-(15))
 545 020c 3F4F      		sbci r19,hi8(-(15))
 546               	.L30:
 547 020e C901      		movw r24,r18
 548 0210 9595      		asr r25
 549 0212 8795      		ror r24
 550 0214 9595      		asr r25
 551 0216 8795      		ror r24
 552 0218 9595      		asr r25
 553 021a 8795      		ror r24
 554 021c 9595      		asr r25
 555 021e 8795      		ror r24
 556 0220 9C01      		movw r18,r24
 557 0222 220F      		lsl r18
 558 0224 331F      		rol r19
 559 0226 880F      		lsl r24
 560 0228 991F      		rol r25
 561 022a 880F      		lsl r24
 562 022c 991F      		rol r25
 563 022e 880F      		lsl r24
 564 0230 991F      		rol r25
 565 0232 280F      		add r18,r24
 566 0234 391F      		adc r19,r25
 567 0236 215B      		subi r18,lo8(-(335))
 568 0238 3E4F      		sbci r19,hi8(-(335))
 304:ir_heat.c     **** 	return 10 * (-temp/16 + 32) + 15;
 305:ir_heat.c     **** }
 569               	
 570               		mov r24,r18
 571 023a 822F      		mov r25,r19
 572 023c 932F      	/* epilogue start */
 573               		ret
 575               	.Lscope10:
 577               	.global	get_slope2
 579               	get_slope2:
 306:ir_heat.c     **** 
 307:ir_heat.c     **** 
 308:ir_heat.c     **** int16_t get_slope2() {
 581               	B11:
 582               	/* prologue: function */
 583               	/* frame size = 0 */
 585               	.LM56:
 309:ir_heat.c     **** 	static int16_t last_slope = 0;
 310:ir_heat.c     **** //	last_slope = (200*(t_array[5]-t_array[2]) / 16 +  2*last_slope) / 3;
 311:ir_heat.c     **** 	last_slope = (16*(t_array[5]-t_array[2]) +  2*last_slope) / 3;
 586               	r24,t_array+10
 587               		lds r25,(t_array+10)+1
 588 0240 8091 0000 		lds r18,t_array+4
 589 0244 9091 0000 		lds r19,(t_array+4)+1
 590 0248 2091 0000 		sub r24,r18
 591 024c 3091 0000 		sbc r25,r19
 592 0250 821B      		lsl r24
 593 0252 930B      		rol r25
 594 0254 880F      		lsl r24
 595 0256 991F      		rol r25
 596 0258 880F      		lsl r24
 597 025a 991F      		rol r25
 598 025c 880F      		lds r18,last_slope.1898
 599 025e 991F      		lds r19,(last_slope.1898)+1
 600 0260 2091 0000 		add r24,r18
 601 0264 3091 0000 		adc r25,r19
 602 0268 820F      		lsl r24
 603 026a 931F      		rol r25
 604 026c 880F      		ldi r22,lo8(3)
 605 026e 991F      		ldi r23,hi8(3)
 606 0270 63E0      		call __divmodhi4
 607 0272 70E0      		mov r24,r22
 608 0274 0E94 0000 		mov r25,r23
 609 0278 862F      		sts last_slope.1898,r22
 610 027a 972F      		sts last_slope.1898+1,r23
 611 027c 6093 0000 	/* epilogue start */
 613               	.LM57:
 312:ir_heat.c     **** 	return last_slope;
 313:ir_heat.c     **** }
 614               	t_slope2
 618               	.Lscope11:
 620               	.global	add_value
 622               	add_value:
 624               	.LM58:
 625               	.LFBB12:
 314:ir_heat.c     **** 
 315:ir_heat.c     **** 
 316:ir_heat.c     **** 
 317:ir_heat.c     **** 
 318:ir_heat.c     **** //*********************************************
 319:ir_heat.c     **** //
 320:ir_heat.c     **** // Gibt den Temperatur Ringspeicher
 321:ir_heat.c     **** // über den UART aus
 322:ir_heat.c     **** //
 323:ir_heat.c     **** void print_array(){
 324:ir_heat.c     **** 	uint8_t i;
 325:ir_heat.c     ****   	printf("Array:");
 326:ir_heat.c     **** 	for(i=0;i<6;i++) {
 327:ir_heat.c     ****    	printf(" %i", t_array[i]);
 328:ir_heat.c     **** 	}
 329:ir_heat.c     ****   	printf("\n");
 330:ir_heat.c     **** }
 331:ir_heat.c     **** 
 332:ir_heat.c     **** 
 333:ir_heat.c     **** 
 334:ir_heat.c     **** //*********************************************
 335:ir_heat.c     **** //
 336:ir_heat.c     **** // Fügt einen Meßwert zum Ringspeicher hinzu
 337:ir_heat.c     **** // Der Ringspeicher enthält die letzten 6 Werte
 338:ir_heat.c     **** // t_array[5] ist der neuste Wert
 339:ir_heat.c     **** //
 340:ir_heat.c     **** void add_value(uint16_t value) {
 626               	 function */
 627               	/* frame size = 0 */
 628               		mov r20,r24
 629               		mov r21,r25
 631 0286 482F      	.LM59:
 632 0288 592F      		lds r24,t_array
 341:ir_heat.c     **** 	uint8_t i;
 342:ir_heat.c     **** 	if(t_array[0]==0) {
 633               	5,(t_array)+1
 634               		or r24,r25
 635 028a 8091 0000 		brne .L35
 637 0292 892B      	.LM60:
 638 0294 01F4      		ldi r30,lo8(t_array+10)
 343:ir_heat.c     **** 		t_array[0]=t_array[1]=t_array[2]=t_array[3]=t_array[4]=t_array[5]=value;
 639               	31,hi8(t_array+10)
 640               		st Z,r20
 641 0296 E0E0      		std Z+1,r21
 642 0298 F0E0      		movw r26,r30
 643 029a 4083      		sbiw r26,2
 644 029c 5183      		st X,r20
 645 029e DF01      		adiw r26,1
 646 02a0 1297      		st X,r21
 647 02a2 4C93      		movw r26,r30
 648 02a4 1196      		sbiw r26,4
 649 02a6 5C93      		st X,r20
 650 02a8 DF01      		adiw r26,1
 651 02aa 1497      		st X,r21
 652 02ac 4C93      		movw r26,r30
 653 02ae 1196      		sbiw r26,6
 654 02b0 5C93      		st X,r20
 655 02b2 DF01      		adiw r26,1
 656 02b4 1697      		st X,r21
 657 02b6 4C93      		movw r26,r30
 658 02b8 1196      		sbiw r26,8
 659 02ba 5C93      		st X,r20
 660 02bc DF01      		adiw r26,1
 661 02be 1897      		st X,r21
 662 02c0 4C93      		sbiw r30,10
 663 02c2 1196      		st Z,r20
 664 02c4 5C93      		std Z+1,r21
 665 02c6 3A97      		ret
 666 02c8 4083      	.L35:
 667 02ca 5183      		ldi r30,lo8(t_array)
 668 02cc 0895      		ldi r31,hi8(t_array)
 670 02ce E0E0      	.LM61:
 671 02d0 F0E0      		ldi r18,lo8(t_array+10)
 344:ir_heat.c     **** 	}
 345:ir_heat.c     **** 	else {
 346:ir_heat.c     **** 		for(i=0;i<5;i++) {
 672               	stabn	68,0,347,.LM62-.LFBB12
 673               	.LM62:
 674 02d2 20E0      		ldd r24,Z+2
 675 02d4 30E0      		ldd r25,Z+3
 676               		st Z+,r24
 347:ir_heat.c     **** 			t_array[i]=t_array[i+1];
 677               	+,r25
 679 02d6 8281      	.LM63:
 680 02d8 9381      		cp r30,r18
 681 02da 8193      		cpc r31,r19
 682 02dc 9193      		brne .L37
 684               	.LM64:
 685 02de E217      		mov r18,r20
 686 02e0 F307      		mov r19,r21
 687 02e2 01F4      		sts (t_array+10)+1,r19
 348:ir_heat.c     **** 		}
 349:ir_heat.c     **** 		t_array[5] = value;
 688               	y+10,r18
 690 02e4 242F      	.LM65:
 691 02e6 352F      		lds r24,t_array+8
 692 02e8 3093 0000 		lds r25,(t_array+8)+1
 693 02ec 2093 0000 		sub r18,r24
 350:ir_heat.c     **** 		slope2 = (10*(t_array[5]-t_array[4]) + 19*slope2) / 20;
 694               	19,r25
 695               		movw r24,r18
 696 02f0 8091 0000 		lsl r24
 697 02f4 9091 0000 		rol r25
 698 02f8 281B      		lsl r18
 699 02fa 390B      		rol r19
 700 02fc C901      		lsl r18
 701 02fe 880F      		rol r19
 702 0300 991F      		lsl r18
 703 0302 220F      		rol r19
 704 0304 331F      		add r24,r18
 705 0306 220F      		adc r25,r19
 706 0308 331F      		lds r22,slope2
 707 030a 220F      		lds r23,(slope2)+1
 708 030c 331F      		movw r18,r22
 709 030e 820F      		lsl r18
 710 0310 931F      		rol r19
 711 0312 6091 0000 		movw r20,r18
 712 0316 7091 0000 		lsl r20
 713 031a 9B01      		rol r21
 714 031c 220F      		lsl r20
 715 031e 331F      		rol r21
 716 0320 A901      		lsl r20
 717 0322 440F      		rol r21
 718 0324 551F      		add r18,r20
 719 0326 440F      		adc r19,r21
 720 0328 551F      		add r18,r22
 721 032a 440F      		adc r19,r23
 722 032c 551F      		add r24,r18
 723 032e 240F      		adc r25,r19
 724 0330 351F      		ldi r22,lo8(20)
 725 0332 260F      		ldi r23,hi8(20)
 726 0334 371F      		call __divmodhi4
 727 0336 820F      		sts (slope2)+1,r23
 728 0338 931F      		sts slope2,r22
 729 033a 64E1      		ret
 731 033e 0E94 0000 	.Lscope12:
 733 0346 6093 0000 	.global	get_slope
 735               	get_slope:
 737               	.LM66:
 738               	.LFBB13:
 739               	/* prologue: function */
 740               	/* frame size = 0 */
 351:ir_heat.c     **** 	}
 352:ir_heat.c     **** }
 353:ir_heat.c     **** 
 354:ir_heat.c     **** 
 355:ir_heat.c     **** 
 356:ir_heat.c     **** //********************************************
 357:ir_heat.c     **** //
 358:ir_heat.c     **** // Gibt die gemittelte Steigung
 359:ir_heat.c     **** // über die letzten 4 Sekunden zurück
 360:ir_heat.c     **** //
 361:ir_heat.c     **** int16_t get_slope() {
 741               	lo8(t_array+8)
 742               		ldi r27,hi8(t_array+8)
 743               		movw r30,r26
 744               		ld r18,Z+
 745               		ld r19,Z+
 746               		lds r24,t_array+2
 747               		lds r25,(t_array+2)+1
 748 034c A0E0      		sub r18,r24
 749 034e B0E0      		sbc r19,r25
 750 0350 FD01      		movw r24,r18
 751 0352 2191      		lsl r24
 752 0354 3191      		rol r25
 753 0356 8091 0000 		lsl r24
 754 035a 9091 0000 		rol r25
 755 035e 281B      		add r24,r18
 756 0360 390B      		adc r25,r19
 757 0362 C901      		sbiw r26,8
 758 0364 880F      		ld r20,Z
 759 0366 991F      		ldd r21,Z+1
 760 0368 880F      		ld r18,X+
 761 036a 991F      		ld r19,X
 762 036c 820F      		sbiw r26,1
 763 036e 931F      		sub r20,r18
 764 0370 1897      		sbc r21,r19
 765 0372 4081      		movw r18,r20
 766 0374 5181      		lsl r18
 767 0376 2D91      		rol r19
 768 0378 3C91      		add r18,r20
 769 037a 1197      		adc r19,r21
 770 037c 421B      		add r24,r18
 771 037e 530B      		adc r25,r19
 772 0380 9A01      		adiw r26,6
 773 0382 220F      		ld r20,X+
 774 0384 331F      		ld r21,X
 775 0386 240F      		sbiw r26,6+1
 776 0388 351F      		adiw r26,4
 777 038a 820F      		ld r18,X+
 778 038c 931F      		ld r19,X
 779 038e 1696      		sbiw r26,4+1
 780 0390 4D91      		sub r20,r18
 781 0392 5C91      		sbc r21,r19
 782 0394 1797      		movw r18,r20
 783 0396 1496      		lsl r18
 784 0398 2D91      		rol r19
 785 039a 3C91      		add r18,r20
 786 039c 1597      		adc r19,r21
 787 039e 421B      		movw r20,r18
 788 03a0 530B      		lsl r20
 789 03a2 9A01      		rol r21
 790 03a4 220F      		lsl r20
 791 03a6 331F      		rol r21
 792 03a8 240F      		add r18,r20
 793 03aa 351F      		adc r19,r21
 794 03ac A901      		add r24,r18
 795 03ae 440F      		adc r25,r19
 796 03b0 551F      		ldi r22,lo8(9)
 797 03b2 440F      		ldi r23,hi8(9)
 798 03b4 551F      		call __divmodhi4
 799 03b6 240F      		mov r24,r22
 800 03b8 351F      		mov r25,r23
 801 03ba 820F      	/* epilogue start */
 803 03be 69E0      	.LM68:
 804 03c0 70E0      		ret
 806 03c6 862F      	.Lscope13:
 808               	.global	get_last_slope
 362:ir_heat.c     **** 	int16_t s1, s2, s3;
 363:ir_heat.c     **** 
 364:ir_heat.c     **** 	s1 = t_array[5] - t_array[0];
 365:ir_heat.c     **** 	s2 = t_array[4] - t_array[1];
 366:ir_heat.c     **** 	s3 = t_array[3] - t_array[2];
 367:ir_heat.c     **** 	
 368:ir_heat.c     **** 	return ((3*s1+5*s2+15*s3)/9);
 369:ir_heat.c     **** }
 809               	M69-.LFBB14
 810               	.LM69:
 811 03ca 0895      	.LFBB14:
 812               	/* prologue: function */
 813               	/* frame size = 0 */
 815               	.LM70:
 816               		lds r18,t_array+10
 817               		lds r19,(t_array+10)+1
 370:ir_heat.c     **** 
 371:ir_heat.c     **** 
 372:ir_heat.c     **** 
 373:ir_heat.c     **** //********************************************
 374:ir_heat.c     **** //
 375:ir_heat.c     **** // Gibt die aktuelle Steigung der Temperatur zurück
 376:ir_heat.c     **** // in 0.1°C in 4s
 377:ir_heat.c     **** //
 378:ir_heat.c     **** int16_t	get_last_slope() {
 818               	t_array+8
 819               		lds r25,(t_array+8)+1
 820               		sub r18,r24
 821               		sbc r19,r25
 823               	.LM71:
 824               		mov r24,r18
 825 03cc 2091 0000 		mov r25,r19
 826 03d0 3091 0000 	/* epilogue start */
 827 03d4 8091 0000 		ret
 829 03dc 281B      	.Lscope14:
 379:ir_heat.c     ****     return (t_array[5] - t_array[4]);
 380:ir_heat.c     **** }
 831               	tion_ms:P(4,4)",64,0,0,24
 832               	.global	_beep
 834 03e2 932F      	_beep:
 836 03e4 0895      	.LM72:
 837               	.LFBB15:
 838               	/* prologue: function */
 839               	/* frame size = 0 */
 841               	.LM73:
 842               		ldi r30,lo8(37)
 843               		ldi r31,hi8(37)
 381:ir_heat.c     **** 
 382:ir_heat.c     **** 
 383:ir_heat.c     **** 
 384:ir_heat.c     **** //********************************************
 385:ir_heat.c     **** //
 386:ir_heat.c     **** // Liest die vom MLX90614 gemessene Temperatur aus
 387:ir_heat.c     **** // Rückgabe in 0.1°C, also 215 = 21.5°C
 388:ir_heat.c     **** //
 389:ir_heat.c     **** uint16_t get_temperature(uint8_t adr) {
 390:ir_heat.c     **** 	uint16_t raw;
 391:ir_heat.c     **** 	uint8_t 	ret;
 392:ir_heat.c     **** 	uint8_t 	lo, hi, pec;
 393:ir_heat.c     **** 	uint8_t	pec_read[6];
 394:ir_heat.c     **** 
 395:ir_heat.c     **** 	if(i2c_start(MLX90614_WRITE)) return DEFAULT_TEMP;
 396:ir_heat.c     **** 	if(i2c_write(adr)) return DEFAULT_TEMP;
 397:ir_heat.c     **** 	
 398:ir_heat.c     **** 	ret = i2c_rep_start(MLX90614_READ);
 399:ir_heat.c     **** 	if(ret) {
 400:ir_heat.c     **** 		i2c_rep_start(MLX90614_READ);
 401:ir_heat.c     ****    }
 402:ir_heat.c     **** 
 403:ir_heat.c     **** 	lo = i2c_readAck();
 404:ir_heat.c     **** 	hi = i2c_readAck();
 405:ir_heat.c     **** 	raw = (uint16_t)(hi<<8)+lo;
 406:ir_heat.c     **** 	pec = i2c_readAck();
 407:ir_heat.c     **** 	
 408:ir_heat.c     **** 	i2c_stop();
 409:ir_heat.c     **** 	
 410:ir_heat.c     **** 	if(raw & 0x8000) return DEFAULT_TEMP;
 411:ir_heat.c     **** 	
 412:ir_heat.c     **** 	return (raw / 5 - 2731); 					// 1 = 0.1°C
 413:ir_heat.c     **** }
 414:ir_heat.c     **** 
 415:ir_heat.c     **** 
 416:ir_heat.c     **** 
 417:ir_heat.c     **** void _beep(uint16_t duration_ms){
 844               	i r18,lo8(-128)
 845               		st Z,r18
 847               	.LM74:
 848               		ldi r22,lo8(20)
 418:ir_heat.c     **** 	uint16_t i;
 419:ir_heat.c     **** 	BUZZER_ON;
 849               	r23,hi8(20)
 850               		call __udivmodhi4
 851 03e6 E5E2      		mov r24,r22
 852 03e8 F0E0      		mov r25,r23
 853 03ea 2081      		sbiw r24,0
 854 03ec 2068      		breq .L45
 855 03ee 2083      		ldi r18,lo8(0)
 420:ir_heat.c     **** 	for(i=0;i<(duration_ms/20);i++) _delay_ms(20);
 856               	9,hi8(0)
 857               	.LBB37:
 858 03f0 64E1      	.LBB38:
 859 03f2 70E0      	.LBB39:
 860 03f4 0E94 0000 	.LBB40:
 862 03fa 972F      	.Ltext1:
 864 03fe 01F0      	.LM75:
 865 0400 20E0      		ldi r20,lo8(10000)
 866 0402 30E0      		ldi r21,hi8(10000)
 867               	.L46:
 868               		movw r30,r20
 869               	/* #APP */
 870               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 871               		1: sbiw r30,1
 872               		brne 1b
   1:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   5:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   8:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  11:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      distribution.
  15:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  16:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  20:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  32:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  34:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  37:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  39:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \file */
  40:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \code
  42:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \endcode
  44:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  45:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  53:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  60:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  62:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  63:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  64:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #endif
  68:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  69:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  71:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     register.
  76:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  77:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     can be achieved.
  79:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  80:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
  81:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
  83:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	);
  89:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** }
  90:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  91:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  93:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     counter register pair.
  98:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  99:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****  */
 102:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
 103:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
 105:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 873               	APP */
 874               	.LBE40:
 875 0404 40E1      	.LBE39:
 876 0406 57E2      	.LBE38:
 877               	.LBE37:
 879               	.Ltext2:
 881 040a 3197      	.LM76:
 882 040c 01F4      		subi r18,lo8(-(1))
 883               		sbci r19,hi8(-(1))
 884               		cp r18,r24
 885               		cpc r19,r25
 886               		brlo .L46
 887               	.L45:
 889               	.LM77:
 890               		ldi r30,lo8(37)
 891               		ldi r31,hi8(37)
 892               		ld r24,Z
 893 040e 2F5F      		andi r24,lo8(127)
 894 0410 3F4F      		st Z,r24
 895 0412 2817      	/* epilogue start */
 897 0416 00F0      	.LM78:
 898               		ret
 421:ir_heat.c     **** 	BUZZER_OFF;
 899               	abs	"i:r(4,4)",64,0,0,18
 902 041a F0E0      	.Lscope15:
 903 041c 8081      		.data
 904 041e 8F77      	.LC0:
 905 0420 8083      		.string	">>> Relais ON"
 906               	.LC1:
 422:ir_heat.c     **** }
 907               		">>> Relais OFF"
 908               		.text
 911               	.global	set_relais
 913               	set_relais:
 915               	.LM79:
 916               	.LFBB16:
 917 0000 3E3E 3E20 		push r17
 917      5265 6C61 
 917      6973 204F 
 917      4E00 
 918               	/* prologue: function */
 919 000e 3E3E 3E20 	/* frame size = 0 */
 919      5265 6C61 
 919      6973 204F 
 919      4646 00
 920               		mov r17,r24
 922               	.LM80:
 923               		tst r24
 924               		breq .L50
 423:ir_heat.c     **** 
 424:ir_heat.c     **** 
 425:ir_heat.c     **** void	beep(uint8_t type){
 426:ir_heat.c     **** 	cli();
 427:ir_heat.c     **** 	wdt_reset();
 428:ir_heat.c     **** 	switch(type){
 429:ir_heat.c     **** 	case BEEP_SHORT:
 430:ir_heat.c     **** 		_beep(120);
 431:ir_heat.c     **** 		break;
 432:ir_heat.c     **** 	case BEEP_LONG:
 433:ir_heat.c     **** 		_beep(200);
 434:ir_heat.c     **** 		break;
 435:ir_heat.c     **** 	case BEEP_XLONG:
 436:ir_heat.c     **** 		_beep(850);
 437:ir_heat.c     **** 		break;
 438:ir_heat.c     **** 	case BEEP_2SHORT:
 439:ir_heat.c     **** 		_beep(80);
 440:ir_heat.c     **** 		_delay_ms(80);
 441:ir_heat.c     **** 		_beep(80);
 442:ir_heat.c     **** 		break;
 443:ir_heat.c     **** 	case BEEP_SHORT_LONG:
 444:ir_heat.c     **** 		_beep(100);
 445:ir_heat.c     **** 		_delay_ms(180);
 446:ir_heat.c     **** 		_beep(350);		
 447:ir_heat.c     **** 	}
 448:ir_heat.c     **** 	sei();	
 449:ir_heat.c     **** 	printf("Beep\n");
 450:ir_heat.c     **** }
 451:ir_heat.c     **** 
 452:ir_heat.c     **** 
 453:ir_heat.c     **** 
 454:ir_heat.c     **** //***************************************************
 455:ir_heat.c     **** //
 456:ir_heat.c     **** // Relais Ein- und Ausschalen
 457:ir_heat.c     **** //
 458:ir_heat.c     **** void set_relais(uint8_t on) {
 926               	t.2012
 927               		cp r17,r24
 928               		breq .L51
 929 0424 1F93      		ldi r24,lo8(.LC0)
 930               		ldi r25,hi8(.LC0)
 931               		call puts
 932 0426 182F      	.L51:
 459:ir_heat.c     **** 	static uint8_t last = 0;
 460:ir_heat.c     **** 	if(on) {
 933               		68,0,462,.LM82-.LFBB16
 934               	.LM82:
 935 0428 8823      		ldi r30,lo8(37)
 936 042a 01F0      		ldi r31,hi8(37)
 461:ir_heat.c     **** 		if(on != last) printf(">>> Relais ON\n");
 937               	r24,Z
 938               		ori r24,lo8(64)
 939 042c 8091 0000 		st Z,r24
 940 0430 1817      		rjmp .L52
 941 0432 01F0      	.L50:
 943 0436 90E0      	.LM83:
 944 0438 0E94 0000 		lds r24,last.2012
 945               		tst r24
 462:ir_heat.c     **** 		RELAIS_ON;
 946               	3
 947               		ldi r24,lo8(.LC1)
 948 043c E5E2      		ldi r25,hi8(.LC1)
 949 043e F0E0      		call puts
 950 0440 8081      	.L53:
 952 0444 8083      	.LM84:
 953 0446 00C0      		ldi r30,lo8(37)
 954               		ldi r31,hi8(37)
 463:ir_heat.c     **** 	}
 464:ir_heat.c     **** 	else {
 465:ir_heat.c     **** 		if(on != last) printf(">>> Relais OFF\n");
 955               	
 956               		andi r24,lo8(-65)
 957 0448 8091 0000 		st Z,r24
 958 044c 8823      	.L52:
 960 0450 80E0      	.LM85:
 961 0452 90E0      		sts last.2012,r17
 962 0454 0E94 0000 	/* epilogue start */
 466:ir_heat.c     **** 		RELAIS_OFF;
 964               	pop r17
 965               		ret
 970 0460 8083      	.Lscope16:
 971               		.data
 467:ir_heat.c     **** 	}
 468:ir_heat.c     **** 	last = on;
 972               	string	"Beep"
 973               		.text
 469:ir_heat.c     **** }
 976               	bal	beep
 978 0466 1F91      	beep:
 980               	.LM87:
 981               	.LFBB17:
 982               	/* prologue: function */
 983               	/* frame size = 0 */
 985               	.LM88:
 986               	/* #APP */
 987 001d 4265 6570 	 ;  426 "ir_heat.c" 1
 987      00
 988               		cli
 989               	 ;  0 "" 2
 991               	.LM89:
 992               	 ;  427 "ir_heat.c" 1
 993               		wdr
 994               	 ;  0 "" 2
 996               	.LM90:
 997               	/* #NOAPP */
 998               		cpi r24,lo8(3)
 999               		breq .L59
 1000               		cpi r24,lo8(4)
 1001               		brsh .L62
 1002               		cpi r24,lo8(1)
 1003 046a F894      		breq .L57
 1004               		cpi r24,lo8(2)
 1005               		brne .L56
 1006               		rjmp .L66
 1007               	.L62:
 1008 046c A895      		cpi r24,lo8(4)
 1009               		breq .L60
 1010               		cpi r24,lo8(6)
 1011               		brne .L56
 1012               		rjmp .L67
 1013 046e 8330      	.L57:
 1015 0472 8430      	.LM91:
 1016 0474 00F4      		ldi r24,lo8(120)
 1017 0476 8130      		ldi r25,hi8(120)
 1018 0478 01F0      		call _beep
 1019 047a 8230      		rjmp .L56
 1020 047c 01F4      	.L59:
 1022               	.LM92:
 1023 0480 8430      		ldi r24,lo8(200)
 1024 0482 01F0      		ldi r25,hi8(200)
 1025 0484 8630      		call _beep
 1026 0486 01F4      		rjmp .L56
 1027 0488 00C0      	.L60:
 1029               	.LM93:
 1030               		ldi r24,lo8(850)
 1031 048a 88E7      		ldi r25,hi8(850)
 1032 048c 90E0      		call _beep
 1033 048e 0E94 0000 		rjmp .L56
 1034 0492 00C0      	.L66:
 1036               	.LM94:
 1037               		ldi r24,lo8(80)
 1038 0494 88EC      		ldi r25,hi8(80)
 1039 0496 90E0      		call _beep
 1040 0498 0E94 0000 	.LBB41:
 1041 049c 00C0      	.LBB42:
 1042               	.LBB43:
 1043               	.LBB44:
 1045 049e 82E5      	.Ltext3:
 1047 04a2 0E94 0000 	.LM95:
 1048 04a6 00C0      		ldi r24,lo8(-25536)
 1049               		ldi r25,hi8(-25536)
 1050               	/* #APP */
 1051               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1052 04a8 80E5      		1: sbiw r24,1
 1053 04aa 90E0      		brne 1b
 1054 04ac 0E94 0000 	 ;  0 "" 2
 1055               	/* #NOAPP */
 1056               	.LBE44:
 1057               	.LBE43:
 1058               	.LBE42:
 1059               	.LBE41:
 1061               	.Ltext4:
 1063 04b0 80E4      	.LM96:
 1064 04b2 9CE9      		ldi r24,lo8(80)
 1065               		ldi r25,hi8(80)
 1066               		call _beep
 1067 04b4 0197      		rjmp .L56
 1068 04b6 01F4      	.L67:
 1070               	.LM97:
 1071               		ldi r24,lo8(100)
 1072               		ldi r25,hi8(100)
 1073               		call _beep
 1074               		ldi r18,lo8(1800)
 1075               		ldi r19,hi8(1800)
 1076               	.LBB45:
 1077               	.LBB46:
 1078               	.LBB47:
 1079 04b8 80E5      	.LBB48:
 1081 04bc 0E94 0000 	.Ltext5:
 1083               	.LM98:
 1084               		ldi r20,lo8(50)
 1085               		ldi r21,hi8(50)
 1086 04c2 84E6      	.L63:
 1087 04c4 90E0      		movw r24,r20
 1088 04c6 0E94 0000 	/* #APP */
 1089 04ca 28E0      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1090 04cc 37E0      		1: sbiw r24,1
 1091               		brne 1b
 1092               	 ;  0 "" 2
 1093               	/* #NOAPP */
 1094               	.LBE48:
 1095               	.LBE47:
 1097               	.Ltext6:
 1099 04ce 42E3      	.LM99:
 1100 04d0 50E0      		subi r18,lo8(-(-1))
 1101               		sbci r19,hi8(-(-1))
 1103               	.LM100:
 1104               		brne .L63
 1105 04d4 0197      	.LBE46:
 1106 04d6 01F4      	.LBE45:
 1108               	.Ltext7:
 1110               	.LM101:
 1111               		ldi r24,lo8(350)
 1112               		ldi r25,hi8(350)
   1:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    All rights reserved.
   5:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
   6:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
   9:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  12:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      distribution.
  16:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  17:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  21:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  33:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /* $Id: delay.h,v 1.5.2.1 2009/02/25 10:14:03 joerg_wunsch Exp $ */
  34:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  35:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  38:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #include <inttypes.h>
  39:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  40:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  41:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /** \file */
  42:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  43:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \code
  44:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  45:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  46:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     #include <util/delay.h>
  47:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \endcode
  48:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  49:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  50:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  51:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  52:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     used.
  53:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  54:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  55:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  56:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  57:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  58:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  59:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  60:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  61:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  62:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  63:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  64:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  65:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  66:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  67:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  68:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  69:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  70:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     routines linked into the application.
  71:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  72:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  73:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  74:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  75:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  76:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** */
  77:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  78:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  79:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  80:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  81:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #endif
  82:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  83:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #ifndef F_CPU
  84:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  85:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  86:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  87:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #endif
  88:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  89:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  90:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  91:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #endif
  92:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  93:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /**
  94:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    \ingroup util_delay
  95:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  96:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
  97:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  98:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
  99:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 100:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 101:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 102:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 103:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 104:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 105:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 106:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 107:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 108:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****  */
 109:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** void
 110:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** _delay_ms(double __ms)
 111:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** {
 112:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	uint16_t __ticks;
 113:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 114:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 115:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = 1;
 116:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 117:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	{
 118:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 119:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 120:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		while(__ticks)
 121:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		{
 122:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 			// wait 1/10 ms
 123:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 124:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 			__ticks --;
 1113               	7
 1114               	.LM103:
 1115 04d8 2150      	/* #NOAPP */
 1116 04da 3040      		ldi r24,lo8(.LC2)
 1117               		ldi r25,hi8(.LC2)
 1118               		call puts
 1119 04dc 01F4      	/* epilogue start */
 1121               	.LM104:
 1122               		ret
 1130               	.Lscope17:
 1131               		.data
 1132               	.LC3:
 1133               		.string	"Temperature Protection Off!"
 1134 04e6 7894      	.LC4:
 1135               		.string	"\nxXx"
 1136               		.text
 1138               	.global	__vector_1
 1140 04ea 90E0      	__vector_1:
 1142               	.LM105:
 1143               	.LFBB18:
 1144               		push __zero_reg__
 1145 04f0 0895      		push r0
 1146               		in r0,__SREG__
 1147               		push r0
 1148               		clr __zero_reg__
 1149               		push r18
 1150               		push r19
 1151               		push r20
 1152               		push r21
 1153               		push r22
 1154               		push r23
 1155               		push r24
 1156 0022 5465 6D70 		push r25
 1156      6572 6174 
 1156      7572 6520 
 1156      5072 6F74 
 1156      6563 7469 
 1157               		push r26
 1158 003e 0A78 5878 		push r27
 1158      00
 1159               		push r30
 1160               		push r31
 1161               	/* prologue: Signal */
 1162               	/* frame size = 0 */
 1164               	.LM106:
 1165               		lds r24,133
 1166               		lds r18,132
 1167 04f2 1F92      		lds r25,running.1766
 1168 04f4 0F92      		or r24,r25
 1169 04f6 0FB6      		or r24,r18
 1170 04f8 0F92      		breq .+2
 1171 04fa 1124      		rjmp .L79
 1173 04fe 3F93      	.LM107:
 1174 0500 4F93      		ldi r24,lo8(1)
 1175 0502 5F93      		sts running.1766,r24
 1177 0506 7F93      	.LM108:
 1178 0508 8F93      	/* #APP */
 1179 050a 9F93      	 ;  165 "ir_heat.c" 1
 1180 050c AF93      		wdr
 1181 050e BF93      	 ;  0 "" 2
 1183 0512 FF93      	.LM109:
 1184               	/* #NOAPP */
 1185               		out 61-32,__zero_reg__
 1187               	.LM110:
 1188 0514 8091 8500 	/* #APP */
 1189 0518 2091 8400 	 ;  170 "ir_heat.c" 1
 1190 051c 9091 0000 		sei
 1191 0520 892B      	 ;  0 "" 2
 1192 0522 822B      	/* #NOAPP */
 1193 0524 01F0      		ldi r18,lo8(0)
 1194 0526 00C0      		ldi r19,hi8(0)
 1195               		ldi r20,lo8(0)
 1196               		ldi r21,hi8(0)
 1198 052a 8093 0000 	.LM111:
 1199               		ldi r30,lo8(41)
 1200               		ldi r31,hi8(41)
 1201               	.L71:
 1202               		ld r24,Z
 1203 052e A895      		sbrs r24,2
 1204               		rjmp .L70
 1205               		subi r20,lo8(-(1))
 1206               		sbci r21,hi8(-(1))
 1207               	.L70:
 1208 0530 1DBA      		subi r18,lo8(-(1))
 1209               		sbci r19,hi8(-(1))
 1210               		ldi r24,hi8(1000)
 1211               		cpi r18,lo8(1000)
 1212               		cpc r19,r24
 1213 0532 7894      		brne .L71
 1215               	.LM112:
 1216 0534 20E0      		cpi r20,200
 1217 0536 30E0      		cpc r21,__zero_reg__
 1218 0538 40E0      		brlo .+2
 1219 053a 50E0      		rjmp .L72
 1221               	.LM113:
 1222 053c E9E2      		ldi r24,lo8(1)
 1223 053e F0E0      		sts 132,r24
 1225 0540 8081      	.LM114:
 1226 0542 82FF      		ldi r24,lo8(2)
 1227 0544 00C0      		sts 129,r24
 1229 0548 5F4F      	.LM115:
 1230               		lds r24,mode
 1231 054a 2F5F      		tst r24
 1232 054c 3F4F      		breq .+2
 1233 054e 83E0      		rjmp .L82
 1235 0552 3807      	.LM116:
 1236 0554 01F4      		ldi r24,lo8(1)
 1237               		sts mode,r24
 1239 0556 483C      	.LM117:
 1240 0558 5105      		call set_relais
 1242 055c 00C0      	.LM118:
 1243               		ldi r30,lo8(43)
 1244               		ldi r31,hi8(43)
 1245 055e 81E0      		ld r24,Z
 1246 0560 8093 8400 		ori r24,lo8(16)
 1247               		st Z,r24
 1249 0564 82E0      	.LM119:
 1250 0566 8093 8100 		ld r24,Z
 1251               		ori r24,lo8(8)
 1252               		st Z,r24
 1254 056e 8823      	.LM120:
 1255 0570 01F0      		sbic 41-32,2
 1256 0572 00C0      		rjmp .L75
 1257               		ldi r18,lo8(0)
 1258               		ldi r19,hi8(0)
 1259 0574 81E0      	.LBB49:
 1260 0576 8093 0000 	.LBB50:
 1261               	.LBB51:
 1262               	.LBB52:
 1264               	.Ltext8:
 1266 057e EBE2      	.LM121:
 1267 0580 F0E0      		ldi r20,lo8(5000)
 1268 0582 8081      		ldi r21,hi8(5000)
 1269 0584 8061      	.LBE52:
 1270 0586 8083      	.LBE51:
 1271               	.LBE50:
 1272               	.LBE49:
 1274 058a 8860      	.Ltext9:
 1276               	.LM122:
 1277               		ldi r30,lo8(41)
 1278 058e 4A99      		ldi r31,hi8(41)
 1279 0590 00C0      	.L77:
 1281 0594 30E0      	.LM123:
 1282               		subi r18,lo8(-(1))
 1283               		sbci r19,hi8(-(1))
 1284               	.LBB56:
 1285               	.LBB55:
 1286               	.LBB54:
 1287               	.LBB53:
 1289               	.Ltext10:
 1291 0598 53E1      	.LM124:
 1292               		movw r24,r20
 1293               	/* #APP */
 1294               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1295               		1: sbiw r24,1
 1296               		brne 1b
 1297               	 ;  0 "" 2
 1298               	/* #NOAPP */
 1299               	.LBE53:
 1300 059a E9E2      	.LBE54:
 1301 059c F0E0      	.LBE55:
 1302               	.LBE56:
 1304               	.Ltext11:
 1306 05a0 3F4F      	.LM125:
 1307               		ld r24,Z
 1308               		sbrc r24,2
 1309               		rjmp .L76
 1310               		ldi r24,hi8(300)
 1311               		cpi r18,lo8(300)
 1312               		cpc r19,r24
 1313               		brne .L77
 1314               		rjmp .L78
 1315 05a2 CA01      	.L76:
 1317               	.LM126:
 1318 05a4 0197      		subi r18,lo8(300)
 1319 05a6 01F4      		sbci r19,hi8(300)
 1320               		brsh .L78
 1321               	.L75:
 1323               	.LM127:
 1324               		ldi r24,lo8(1)
 1325               		sts mode,r24
 1326               		rjmp .L72
 1327               	.L78:
 1329               	.LM128:
 1330 05a8 8081      		ldi r24,lo8(2)
 1331 05aa 82FD      		sts mode,r24
 1333 05ae 81E0      	.LM129:
 1334 05b0 2C32      		ldi r24,lo8(.LC3)
 1335 05b2 3807      		ldi r25,hi8(.LC3)
 1336 05b4 01F4      		call puts
 1338               	.LM130:
 1339               		ldi r30,lo8(43)
 1340               		ldi r31,hi8(43)
 1341 05b8 2C52      		ld r24,Z
 1342 05ba 3140      		andi r24,lo8(-17)
 1343 05bc 00F4      		st Z,r24
 1345               	.LM131:
 1346               		ld r24,Z
 1347 05be 81E0      		ori r24,lo8(8)
 1348 05c0 8093 0000 		st Z,r24
 1350               	.LM132:
 1351               		ldi r24,lo8(6)
 1352               		call beep
 1353 05c6 82E0      		rjmp .L72
 1354 05c8 8093 0000 	.L82:
 1356               	.LM133:
 1357 05cc 80E0      		ldi r24,lo8(.LC4)
 1358 05ce 90E0      		ldi r25,hi8(.LC4)
 1359 05d0 0E94 0000 		call puts
 1361               	.LM134:
 1362 05d4 EBE2      		sts mode,__zero_reg__
 1363 05d6 F0E0      	.L72:
 1365 05da 8F7E      	.LM135:
 1366 05dc 8083      		ldi r24,lo8(1)
 1367               		out 60-32,r24
 1369 05de 8081      	.LM136:
 1370 05e0 8860      		out 61-32,r24
 1372               	.LM137:
 1373               		sts running.1766,__zero_reg__
 1374 05e4 86E0      	.L79:
 1375 05e6 0E94 0000 	/* epilogue start */
 1377               	.LM138:
 1378               		pop r31
 1379               		pop r30
 1380 05ec 80E0      		pop r27
 1381 05ee 90E0      		pop r26
 1382 05f0 0E94 0000 		pop r25
 1383               		pop r24
 1384               		pop r23
 1385 05f4 1092 0000 		pop r22
 1386               		pop r21
 1387               		pop r20
 1388               		pop r19
 1389 05f8 81E0      		pop r18
 1390 05fa 8CBB      		pop r0
 1391               		out __SREG__,r0
 1392               		pop r0
 1393 05fc 8DBB      		pop __zero_reg__
 1394               		reti
 1401 0602 FF91      	.Lscope18:
 1404 0608 AF91      	.global	get_temperature
 1406 060c 8F91      	get_temperature:
 1408 0610 6F91      	.LM139:
 1409 0612 5F91      	.LFBB19:
 1410 0614 4F91      		push r17
 1411 0616 3F91      		push r28
 1412 0618 2F91      		push r29
 1413 061a 0F90      	/* prologue: function */
 1414 061c 0FBE      	/* frame size = 0 */
 1415 061e 0F90      		mov r17,r24
 1417 0622 1895      	.LM140:
 1418               		ldi r24,lo8(-76)
 1419               		call i2c_start
 1420               		tst r24
 1421               		brne .L84
 1423               	.LM141:
 1424               		mov r24,r17
 1425               		call i2c_write
 1426               		tst r24
 1427               		brne .L84
 1429               	.LM142:
 1430               		ldi r24,lo8(181)
 1431               		ldi r25,hi8(181)
 1432               		call i2c_rep_start
 1434 0626 CF93      	.LM143:
 1435 0628 DF93      		tst r24
 1436               		breq .L85
 1438 062a 182F      	.LM144:
 1439               		ldi r24,lo8(181)
 1440               		ldi r25,hi8(181)
 1441 062c 84EB      		call i2c_rep_start
 1442 062e 0E94 0000 	.L85:
 1444 0634 01F4      	.LM145:
 1445               		call i2c_readAck
 1446               		mov r17,r24
 1448 0638 0E94 0000 	.LM146:
 1449 063c 8823      		call i2c_readAck
 1451               	.LM147:
 1452               		mov r19,r24
 1453 0640 85EB      		ldi r18,lo8(0)
 1454 0642 90E0      		movw r28,r18
 1455 0644 0E94 0000 		add r28,r17
 1456               		adc r29,__zero_reg__
 1458 0648 8823      	.LM148:
 1459 064a 01F0      		call i2c_readAck
 1461               	.LM149:
 1462 064c 85EB      		call i2c_stop
 1464 0650 0E94 0000 	.LM150:
 1465               		tst r29
 1466               		brlt .L84
 1468 0654 0E94 0000 	.LM151:
 1469 0658 182F      		movw r24,r28
 1470               		ldi r22,lo8(5)
 1471               		ldi r23,hi8(5)
 1472 065a 0E94 0000 		call __udivmodhi4
 1473               		subi r22,lo8(-(-2731))
 1474               		sbci r23,hi8(-(-2731))
 1475 065e 382F      		rjmp .L86
 1476 0660 20E0      	.L84:
 1477 0662 E901      		ldi r22,lo8(150)
 1478 0664 C10F      		ldi r23,hi8(150)
 1479 0666 D11D      	.L86:
 1481               	.LM152:
 1482 0668 0E94 0000 		mov r24,r22
 1483               		mov r25,r23
 1484               	/* epilogue start */
 1485 066c 0E94 0000 		pop r29
 1486               		pop r28
 1487               		pop r17
 1488 0670 DD23      		ret
 1493 0676 65E0      	.Lscope19:
 1494 0678 70E0      		.data
 1495 067a 0E94 0000 	.LC5:
 1496 067e 6B5A      		.string	"Array:"
 1497 0680 7A40      	.LC6:
 1498 0682 00C0      		.string	" %i"
 1499               		.text
 1501 0686 70E0      	.global	print_array
 1503               	print_array:
 1505 0688 862F      	.LM153:
 1506 068a 972F      	.LFBB20:
 1507               		push r12
 1508 068c DF91      		push r13
 1509 068e CF91      		push r14
 1510 0690 1F91      		push r15
 1511 0692 0895      		push r16
 1512               		push r17
 1513               	/* prologue: function */
 1514               	/* frame size = 0 */
 1516               	.LM154:
 1517               		rcall .
 1518               		ldi r24,lo8(.LC5)
 1519 0043 4172 7261 		ldi r25,hi8(.LC5)
 1519      793A 00
 1520               		in r26,__SP_L__
 1521 004a 2025 6900 		in r27,__SP_H__
 1522               		adiw r26,1+1
 1523               		st X,r25
 1524               		st -X,r24
 1525               		sbiw r26,1
 1526               		call printf
 1528               	.LM155:
 1529               		rcall .
 1530 0694 CF92      		in r30,__SP_L__
 1531 0696 DF92      		in r31,__SP_H__
 1532 0698 EF92      		adiw r30,1
 1533 069a FF92      		mov __tmp_reg__,r31
 1534 069c 0F93      		ldi r31,lo8(.LC6)
 1535 069e 1F93      		mov r14,r31
 1536               		ldi r31,hi8(.LC6)
 1537               		mov r15,r31
 1538               		mov r31,__tmp_reg__
 1539               		std Z+1,r15
 1540 06a0 00D0      		st Z,r14
 1541 06a2 80E0      		mov __tmp_reg__,r31
 1542 06a4 90E0      		ldi r31,lo8(t_array)
 1543 06a6 ADB7      		mov r12,r31
 1544 06a8 BEB7      		ldi r31,hi8(t_array)
 1545 06aa 1296      		mov r13,r31
 1546 06ac 9C93      		mov r31,__tmp_reg__
 1547 06ae 8E93      		movw r26,r12
 1548 06b0 1197      		ld r24,X+
 1549 06b2 0E94 0000 		ld r25,X+
 1550               		movw r16,r26
 1551               		std Z+3,r25
 1552 06b6 00D0      		std Z+2,r24
 1553 06b8 EDB7      		call printf
 1554 06ba FEB7      		in r30,__SP_L__
 1555 06bc 3196      		in r31,__SP_H__
 1556 06be 0F2E      		adiw r30,1
 1557 06c0 F0E0      		std Z+1,r15
 1558 06c2 EF2E      		st Z,r14
 1559 06c4 F0E0      		movw r26,r16
 1560 06c6 FF2E      		ld r24,X+
 1561 06c8 F02D      		ld r25,X
 1562 06ca F182      		std Z+3,r25
 1563 06cc E082      		std Z+2,r24
 1564 06ce 0F2E      		call printf
 1565 06d0 F0E0      		in r30,__SP_L__
 1566 06d2 CF2E      		in r31,__SP_H__
 1567 06d4 F0E0      		adiw r30,1
 1568 06d6 DF2E      		std Z+1,r15
 1569 06d8 F02D      		st Z,r14
 1570 06da D601      		movw r26,r12
 1571 06dc 8D91      		adiw r26,4
 1572 06de 9D91      		ld r24,X+
 1573 06e0 8D01      		ld r25,X
 1574 06e2 9383      		sbiw r26,4+1
 1575 06e4 8283      		std Z+3,r25
 1576 06e6 0E94 0000 		std Z+2,r24
 1577 06ea EDB7      		call printf
 1578 06ec FEB7      		in r30,__SP_L__
 1579 06ee 3196      		in r31,__SP_H__
 1580 06f0 F182      		adiw r30,1
 1581 06f2 E082      		std Z+1,r15
 1582 06f4 D801      		st Z,r14
 1583 06f6 8D91      		movw r26,r12
 1584 06f8 9C91      		adiw r26,6
 1585 06fa 9383      		ld r24,X+
 1586 06fc 8283      		ld r25,X
 1587 06fe 0E94 0000 		sbiw r26,6+1
 1588 0702 EDB7      		std Z+3,r25
 1589 0704 FEB7      		std Z+2,r24
 1590 0706 3196      		call printf
 1591 0708 F182      		in r30,__SP_L__
 1592 070a E082      		in r31,__SP_H__
 1593 070c D601      		adiw r30,1
 1594 070e 1496      		std Z+1,r15
 1595 0710 8D91      		st Z,r14
 1596 0712 9C91      		movw r26,r12
 1597 0714 1597      		adiw r26,8
 1598 0716 9383      		ld r24,X+
 1599 0718 8283      		ld r25,X
 1600 071a 0E94 0000 		sbiw r26,8+1
 1601 071e EDB7      		std Z+3,r25
 1602 0720 FEB7      		std Z+2,r24
 1603 0722 3196      		call printf
 1604 0724 F182      		in r30,__SP_L__
 1605 0726 E082      		in r31,__SP_H__
 1606 0728 D601      		adiw r30,1
 1607 072a 1696      		std Z+1,r15
 1608 072c 8D91      		st Z,r14
 1609 072e 9C91      		movw r26,r12
 1610 0730 1797      		adiw r26,10
 1611 0732 9383      		ld r24,X+
 1612 0734 8283      		ld r25,X
 1613 0736 0E94 0000 		sbiw r26,10+1
 1614 073a EDB7      		std Z+3,r25
 1615 073c FEB7      		std Z+2,r24
 1616 073e 3196      		call printf
 1618 0742 E082      	.LM156:
 1619 0744 D601      		pop __tmp_reg__
 1620 0746 1896      		pop __tmp_reg__
 1621 0748 8D91      		pop __tmp_reg__
 1622 074a 9C91      		pop __tmp_reg__
 1623 074c 1997      		ldi r24,lo8(10)
 1624 074e 9383      		ldi r25,hi8(10)
 1625 0750 8283      		call putchar
 1626 0752 0E94 0000 	/* epilogue start */
 1628 0758 FEB7      	.LM157:
 1629 075a 3196      		pop r17
 1630 075c F182      		pop r16
 1631 075e E082      		pop r15
 1632 0760 D601      		pop r14
 1633 0762 1A96      		pop r13
 1634 0764 8D91      		pop r12
 1635 0766 9C91      		ret
 1637 076a 9383      	.Lscope20:
 1639 076e 0E94 0000 	.global	UART_first_init
 1641               	UART_first_init:
 1643 0774 0F90      	.LM158:
 1644 0776 0F90      	.LFBB21:
 1645 0778 0F90      	/* prologue: function */
 1646 077a 8AE0      	/* frame size = 0 */
 1648 077e 0E94 0000 	.LM159:
 1649               		ldi r24,lo8(12)
 1650               		ldi r25,hi8(12)
 1651               		sts (196)+1,r25
 1652 0782 1F91      		sts 196,r24
 1654 0786 FF90      	.LM160:
 1655 0788 EF90      		ldi r24,lo8(-104)
 1656 078a DF90      		sts 193,r24
 1658 078e 0895      	.LM161:
 1659               		ldi r24,lo8(6)
 1660               		sts 194,r24
 1662               	.LM162:
 1663               		ldi r24,lo8(gs(UART_putchar))
 1664               		ldi r25,hi8(gs(UART_putchar))
 1665               		ldi r22,lo8(gs(UART_getchar))
 1666               		ldi r23,hi8(gs(UART_getchar))
 1667               		call fdevopen
 1669               	.LM163:
 1670               	/* #APP */
 1671               	 ;  297 "ir_heat.c" 1
 1672 0790 8CE0      		sei
 1673 0792 90E0      	 ;  0 "" 2
 1674 0794 9093 C500 	/* epilogue start */
 1676               	.LM164:
 1677               	/* #NOAPP */
 1678 079c 88E9      		ret
 1680               	.Lscope21:
 1681               		.data
 1682 07a2 86E0      	.LC7:
 1683 07a4 8093 C200 		.string	"\n\nStart\n"
 1684               	.LC8:
 1685               		.string	"Error Temp=0"
 1686 07a8 80E0      	.LC9:
 1687 07aa 90E0      		.string	"Startup %i "
 1688 07ac 60E0      	.LC10:
 1689 07ae 70E0      		.string	"Temp: %i, "
 1690 07b0 0E94 0000 	.LC11:
 1691               		.string	"exp_s: %i, s2: %i, bc: %i, fx: %i\n"
 1692               	.LC12:
 1693               		.string	"On-Counter: %i; \n"
 1694               	.LC13:
 1695 07b4 7894      		.string	"Off-Counter: %i; \n"
 1696               		.text
 1698               	.global	main
 1700               	main:
 1702               	.LM165:
 1703               	.LFBB22:
 1704               		push r2
 1705               		push r3
 1706 004e 0A0A 5374 		push r4
 1706      6172 740A 
 1706      00
 1707               		push r5
 1708 0057 4572 726F 		push r6
 1708      7220 5465 
 1708      6D70 3D30 
 1708      00
 1709               		push r7
 1710 0064 5374 6172 		push r8
 1710      7475 7020 
 1710      2569 2000 
 1711               		push r9
 1712 0070 5465 6D70 		push r10
 1712      3A20 2569 
 1712      2C20 00
 1713               		push r11
 1714 007b 6578 705F 		push r12
 1714      733A 2025 
 1714      692C 2073 
 1714      323A 2025 
 1714      692C 2062 
 1715               		push r13
 1716 009e 4F6E 2D43 		push r14
 1716      6F75 6E74 
 1716      6572 3A20 
 1716      2569 3B20 
 1716      0A00 
 1717               		push r15
 1718 00b0 4F66 662D 		push r16
 1718      436F 756E 
 1718      7465 723A 
 1718      2025 693B 
 1718      200A 00
 1719               		push r17
 1720               		push r29
 1721               		push r28
 1722               		rcall .
 1723               		push __tmp_reg__
 470:ir_heat.c     **** 
 471:ir_heat.c     **** 
 472:ir_heat.c     **** 
 473:ir_heat.c     **** 
 474:ir_heat.c     **** // ***********************************************************
 475:ir_heat.c     **** // Main program
 476:ir_heat.c     **** //
 477:ir_heat.c     **** int main(void) {
 1724               	LFBB22
 1725               	.LM166:
 1726               		ldi r24,lo8(-64)
 1727 07b8 2F92      		out 36-32,r24
 1729 07bc 4F92      	.LM167:
 1730 07be 5F92      		ldi r24,lo8(8)
 1731 07c0 6F92      		out 39-32,r24
 1733 07c4 8F92      	.LM168:
 1734 07c6 9F92      		ldi r24,lo8(24)
 1735 07c8 AF92      		out 42-32,r24
 1737 07cc CF92      	.LM169:
 1738 07ce DF92      		ldi r24,lo8(63)
 1739 07d0 EF92      		out 37-32,r24
 1741 07d4 0F93      	.LM170:
 1742 07d6 1F93      		ldi r24,lo8(-9)
 1743 07d8 DF93      		out 40-32,r24
 1745 07dc 00D0      	.LM171:
 1746 07de 0F92      		ldi r16,lo8(43)
 1747 07e0 CDB7      		ldi r17,hi8(43)
 1748 07e2 DEB7      		ldi r24,lo8(-25)
 1749               		movw r30,r16
 1750               		st Z,r24
 478:ir_heat.c     ****    // Ausgänge definieren
 479:ir_heat.c     **** 	DDRB = 0x00 | (1<<RELAIS) | (1<<BUZZER);
 1751               	BB22
 1752               	.LM172:
 1753 07e4 80EC      		lds r24,100
 480:ir_heat.c     **** 	DDRC = 0x00 | (1<<FLASH_LED);
 1755               	73:
 1756               	/* #APP */
 1757 07e8 88E0      	 ;  492 "ir_heat.c" 1
 1758 07ea 87B9      		wdr
 481:ir_heat.c     **** 	DDRD = 0x00 | (1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED);
 1759               	0 "" 2
 1761 07ec 88E1      	.LM174:
 1762 07ee 8AB9      	/* #NOAPP */
 482:ir_heat.c     **** 
 483:ir_heat.c     **** 	// Ausgänge ausschalten
 484:ir_heat.c     **** 	PORTB = ~((1<<RELAIS) | (1<<BUZZER));
 1763               	 r18,lo8(41)
 1764               		ldi r24,lo8(24)
 1765 07f0 8FE3      		ldi r25,hi8(24)
 1766 07f2 85B9      	/* #APP */
 485:ir_heat.c     **** 	PORTC = ~(1<<FLASH_LED);
 1767               	493 "ir_heat.c" 1
 1768               		in __tmp_reg__,__SREG__
 1769 07f4 87EF      		cli
 1770 07f6 88B9      		wdr
 486:ir_heat.c     **** 	PORTD = ~((1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED));
 1771               	 96,r24
 1772               		out __SREG__,__tmp_reg__
 1773 07f8 0BE2      		sts 96,r18
 1774 07fa 10E0      		
 1775 07fc 87EE      	 ;  0 "" 2
 1776 07fe F801      	/* #NOAPP */
 1777 0800 8083      	.LBB57:
 487:ir_heat.c     **** 
 488:ir_heat.c     **** 	// TWI aus Energiesparmode rausnehmen
 489:ir_heat.c     **** 	PRR != ~(1<<PRTWI);
 1778               		68,0,496,.LM175-.LFBB22
 1779               	.LM175:
 1780 0802 8091 6400 		ldi r24,lo8(2)
 490:ir_heat.c     **** 
 491:ir_heat.c     **** 	// Whatchdog initialisieren
 492:ir_heat.c     **** 	wdt_reset();
 1781               	i r25,hi8(2)
 1782               		ldi r18,lo8(-128)
 1783               	/* #APP */
 1784               	 ;  496 "ir_heat.c" 1
 1785 0806 A895      		in __tmp_reg__,__SREG__
 1786               		cli
 493:ir_heat.c     **** 	wdt_enable(WDTO_8S);
 1787               	7, r18
 1788               		sts 97, r24
 1789               		out __SREG__, __tmp_reg__
 1790 0808 29E2      	 ;  0 "" 2
 1791 080a 88E1      	/* #NOAPP */
 1792 080c 90E0      	.LBE57:
 1794               	.LM176:
 1795 080e 0FB6      		call UART_first_init
 1797 0812 A895      	.LM177:
 1798 0814 8093 6000 		call i2c_init
 1800 081a 2093 6000 	.LM178:
 1801               		sts interval,__zero_reg__
 1803               	.LM179:
 1804               		ldi r24,lo8(7)
 494:ir_heat.c     **** 	
 495:ir_heat.c     **** 	// Set clock divider to 4 => 2MHz
 496:ir_heat.c     **** 	clock_prescale_set(clock_div_4);
 1805               	bn	68,0,506,.LM180-.LFBB22
 1806               	.LM180:
 1807 081e 82E0      		ldi r25,lo8(1)
 1808 0820 90E0      		sts 112,r25
 1810               	.LM181:
 1811               		out 68-32,__zero_reg__
 1813 0826 F894      	.LM182:
 1814 0828 2093 6100 		ldi r24,lo8(3)
 1815 082c 8093 6100 		out 69-32,r24
 1817               	.LM183:
 1818               		sts 110,r25
 497:ir_heat.c     **** 	
 498:ir_heat.c     **** 	// UART initialisieren
 499:ir_heat.c     **** 	UART_first_init();
 1820               	8,__zero_reg__
 1822 0832 0E94 0000 	.LM185:
 500:ir_heat.c     **** 	i2c_init();
 1823               	s 129,__zero_reg__
 1825 0836 0E94 0000 	.LM186:
 501:ir_heat.c     **** 	
 502:ir_heat.c     **** 	interval=0;
 1826               	s 130,__zero_reg__
 1828 083a 1092 0000 	.LM187:
 503:ir_heat.c     **** 	
 504:ir_heat.c     **** 	// Timer 2 initialisieren (RTC)
 505:ir_heat.c     ****    TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);	// clk/256
 1829               	s 111,r25
 1831 083e 87E0      	.LM188:
 1832 0840 8093 B100 		ldi r24,lo8(2)
 506:ir_heat.c     ****    TIMSK2 = (1<<TOIE2);
 1833               	 105,r24
 1835 0844 91E0      	.LM189:
 1836 0846 9093 7000 		out 61-32,r25
 507:ir_heat.c     **** 
 508:ir_heat.c     ****  	// Timer 0 initialisieren (Blinken)
 509:ir_heat.c     **** 	TCCR0A = 0;
 1837               	abn	68,0,524,.LM190-.LFBB22
 1838               	.LM190:
 1839 084a 14BC      		ldi r24,lo8(.LC7)
 510:ir_heat.c     **** 	TCCR0B = (0<<CS02) | (1<<CS01) | (1<<CS00);
 1840               	i r25,hi8(.LC7)
 1841               		call puts
 1843 084e 85BD      	.LM191:
 511:ir_heat.c     **** 	TIMSK0 = (1<<TOIE0);
 1844               	w r30,r16
 1845               		ld r24,Z
 1846 0850 9093 6E00 		ori r24,lo8(16)
 512:ir_heat.c     **** 	
 513:ir_heat.c     **** 	// Timer 1 initialisieren (Entprellen?)
 514:ir_heat.c     **** 	TCCR1A = 0;
 1847               	 Z,r24
 1849 0854 1092 8000 	.LM192:
 515:ir_heat.c     **** 	TIMER1_STOP;
 1850               	 r24,Z
 1851               		andi r24,lo8(-9)
 1852 0858 1092 8100 		st Z,r24
 516:ir_heat.c     **** 	TCCR1C = 0;
 1853               	tabn	68,0,527,.LM193-.LFBB22
 1854               	.LM193:
 1855 085c 1092 8200 		ldi r24,lo8(0)
 517:ir_heat.c     **** 	TIMSK1 = (1<<TOIE1);
 1856               	ll set_relais
 1858 0860 9093 6F00 	.LM194:
 518:ir_heat.c     **** 	
 519:ir_heat.c     **** 	// Interrupt für Taster initialisieren
 520:ir_heat.c     **** 	EICRA = (1<<ISC01);
 1859               	s mode,__zero_reg__
 1861 0864 82E0      	.LM195:
 1862 0866 8093 6900 	/* #APP */
 521:ir_heat.c     **** 	EIMSK = (1<<INT0);
 1863               	549 "ir_heat.c" 1
 1864               		sei
 1865 086a 9DBB      	 ;  0 "" 2
 522:ir_heat.c     **** 	
 523:ir_heat.c     **** 
 524:ir_heat.c     **** 	printf("\n\nStart\n\n");
 1866               	#NOAPP */
 1867               		clr r10
 1868 086c 80E0      		clr r11
 1869 086e 90E0      		clr r7
 1870 0870 0E94 0000 		clr r14
 525:ir_heat.c     **** 	STATUS_LED1_ON;		// grüne LED ein
 1871               	r15
 1872               		ldi r16,lo8(0)
 1873 0874 F801      		ldi r31,lo8(-1)
 1874 0876 8081      		std Y+1,r31
 1875 0878 8061      		mov __tmp_reg__,r31
 1876 087a 8083      		ldi r31,lo8(3)
 526:ir_heat.c     **** 	STATUS_LED2_OFF;		// rote LED aus
 1877               	6,r31
 1878               		mov r31,__tmp_reg__
 1880 087e 877F      	.LM196:
 1881 0880 8083      		mov __tmp_reg__,r31
 527:ir_heat.c     **** 	set_relais(0);			// Relais aus
 1882               	r31,lo8(43)
 1883               		mov r12,r31
 1884 0882 80E0      		clr r13
 1885 0884 0E94 0000 		mov r31,__tmp_reg__
 528:ir_heat.c     **** 	mode = MODE_OFF;
 1886               	abn	68,0,679,.LM197-.LFBB22
 1887               	.LM197:
 1888 0888 1092 0000 		clr r2
 529:ir_heat.c     **** 	
 530:ir_heat.c     **** //	int16_t temp, temp_sum, temp_a;
 531:ir_heat.c     **** //	int16_t	lookahead;
 532:ir_heat.c     **** //	int16_t 	slope, max_slope;
 533:ir_heat.c     **** //	int16_t	slope_raw;
 534:ir_heat.c     **** 	int16_t 	temp, temp_sum = 0;
 535:ir_heat.c     **** 	int16_t	slope_raw, slope = 0, temp_a, max_slope;
 536:ir_heat.c     **** 	uint8_t	count=0;
 537:ir_heat.c     **** 	uint8_t  last_interval = 0xff;
 538:ir_heat.c     **** 	uint8_t	startup = 3;
 539:ir_heat.c     **** 	uint8_t	on_counter = 0;
 540:ir_heat.c     **** 	int8_t	beep_counter = 0;
 541:ir_heat.c     **** 	int16_t	factor;
 542:ir_heat.c     **** 	int16_t	integral = 0;
 543:ir_heat.c     **** 	int8_t	fx = 0;
 544:ir_heat.c     **** 	
 545:ir_heat.c     **** 	int16_t	slope_std = 0;
 546:ir_heat.c     **** 	int16_t	slope_real = 0;
 547:ir_heat.c     **** 		
 548:ir_heat.c     **** 	// Interrupts aktivieren
 549:ir_heat.c     **** 	sei();
 1889               	r r3
 1890               	.LBB58:
 1891               	.LBB59:
 1892               	.LBB60:
 1893 088c 7894      	.LBB61:
 1895               	.Ltext12:
 1897 0890 BB24      	.LM198:
 1898 0892 7724      		mov __tmp_reg__,r31
 1899 0894 EE24      		ldi r31,lo8(-15536)
 1900 0896 FF24      		mov r4,r31
 1901 0898 00E0      		ldi r31,hi8(-15536)
 1902 089a FFEF      		mov r5,r31
 1903 089c F983      		mov r31,__tmp_reg__
 1904 089e 0F2E      	.L119:
 1905 08a0 F3E0      	.LBE61:
 1906 08a2 6F2E      	.LBE60:
 1907 08a4 F02D      	.LBE59:
 550:ir_heat.c     **** 
 551:ir_heat.c     ****    while(1) {
 552:ir_heat.c     ****    	if(!(interval < 16)) { 					// Alle 16x (alle 4 Sekunden) Temperatur checken
 553:ir_heat.c     ****    		wdt_reset();                  	// Whatchdog zurücksetzen
 554:ir_heat.c     **** 
 555:ir_heat.c     **** 			temp = temp_sum / count;				// Mittelwert der 16 Messungen ermitteln
 556:ir_heat.c     **** 
 557:ir_heat.c     ****    		interval=0;
 558:ir_heat.c     ****    		count=0;
 559:ir_heat.c     **** 			temp_sum = 0;
 560:ir_heat.c     **** 	      //printf("Temp: %i\n", temp);
 561:ir_heat.c     **** 	      if(temp==0) {
 562:ir_heat.c     **** 	      	// error!
 563:ir_heat.c     **** 	      	printf("Error Temp=0");
 564:ir_heat.c     **** 	      }
 565:ir_heat.c     **** 	      else {
 566:ir_heat.c     **** 				if (startup>0) {
 567:ir_heat.c     **** 					// wird nur beim ersten Durchlauf, direkt nach Startup ausgeführt
 568:ir_heat.c     **** 					printf("Startup %i ", startup);
 569:ir_heat.c     **** 					startup--;
 570:ir_heat.c     **** 					temp = get_temperature(ADR_T_OBJ1);
 571:ir_heat.c     **** 					slope = 0;
 572:ir_heat.c     **** 				}
 573:ir_heat.c     ****    	   	printf("Temp: %i, ", temp);
 574:ir_heat.c     ****    	   	add_value(temp);									// Neue Temperatur zu Array hinzufügen
 575:ir_heat.c     ****    	   	slope_raw = get_slope();						// Aktuelle Steigung ermitteln
 576:ir_heat.c     ****    	   	if (slope_raw < -100) slope_raw = -100;
 577:ir_heat.c     ****    	   	
 578:ir_heat.c     ****    	   	factor = (temp - 620) / -25;					// Fakort ermitteln
 579:ir_heat.c     ****    	   	temp_a = get_temperature(ADR_T_A);
 580:ir_heat.c     ****    	   	//factor = (temp - 900 + 2*temp_a ) / -25;					// Fakort ermitteln
 581:ir_heat.c     ****    	   	if(factor < 0) factor = 0;
 582:ir_heat.c     ****    	   	   	   	
 583:ir_heat.c     **** 				if(slope_raw > factor) { 						// "Steigungsintegral"
 584:ir_heat.c     **** 					integral = 8*(integral + slope_raw) / factor;
 585:ir_heat.c     **** 					if(integral > 2000) integral = 2000;
 586:ir_heat.c     **** 				}
 587:ir_heat.c     **** 				else {
 588:ir_heat.c     **** 					integral = integral / 4;
 589:ir_heat.c     **** 				}
 590:ir_heat.c     **** 				
 591:ir_heat.c     **** //				slope = (31*slope + 10*slope_raw)/32; 		// Steigung dämpfen
 592:ir_heat.c     **** 
 593:ir_heat.c     **** 				
 594:ir_heat.c     **** 				if(slope_raw < -10) slope_raw = -10;
 595:ir_heat.c     **** 				if(slope_raw<0) {									// Fallende Temperaturen werden stärker gewichtet
 596:ir_heat.c     **** 	   	   	slope = (3*slope + 10*slope_raw)/4;		// Negative Steigung wird mit einer Dämpfung von 8 ge
 597:ir_heat.c     **** 				}
 598:ir_heat.c     **** 				else {
 599:ir_heat.c     **** 	   	   	slope = (31*slope + 10*slope_raw)/32;	// Positive Steigung wird mit einer Dämpfung von 16 
 600:ir_heat.c     **** 	   	   }
 601:ir_heat.c     **** 	   	
 602:ir_heat.c     **** 
 603:ir_heat.c     **** 	   		slope_real = get_slope2();
 604:ir_heat.c     **** 
 605:ir_heat.c     **** 				//printf("bc: %i,sr: %i", beep_counter, slope_real);
 606:ir_heat.c     **** 				if(beep_counter > 0) {
 607:ir_heat.c     **** 					beep_counter++;
 608:ir_heat.c     **** 					if((slope_real < 0)) {
 609:ir_heat.c     **** 						fx = fx+20;
 610:ir_heat.c     **** 						beep_counter = -10;
 611:ir_heat.c     **** 					}
 612:ir_heat.c     **** 				}
 613:ir_heat.c     **** 				
 614:ir_heat.c     **** 				if(fx > 60) fx= 60;
 615:ir_heat.c     **** 
 616:ir_heat.c     **** 	   		slope_std = exp_slope(temp) + fx;
 617:ir_heat.c     **** 	   	
 618:ir_heat.c     **** /*
 619:ir_heat.c     ****    	   	printf("slope_raw: %i, slope: %i ", slope_raw, slope);
 620:ir_heat.c     ****      	   	printf("Ambient: %i\n", get_temperature(ADR_T_A));
 621:ir_heat.c     **** */				
 622:ir_heat.c     **** 
 623:ir_heat.c     **** 				// temp_a 150 -> 45
 624:ir_heat.c     **** 				// temp_a 100 -> 60
 625:ir_heat.c     **** //   	   	max_slope = temp_a * -1.3 + 240;
 626:ir_heat.c     **** //   	   	max_slope = max_slope * (600-temp)/50;
 627:ir_heat.c     **** 				max_slope = (float)temp * -0.8 + 360;
 628:ir_heat.c     **** 
 629:ir_heat.c     **** //   	   	printf("sl_raw: %i, sl: %i, s_max: %i, f: %i, int: %i t_a: %i\n", slope_raw, slope, max_s
 630:ir_heat.c     ****    	   	printf("exp_s: %i, s2: %i, bc: %i, fx: %i\n", slope_std, slope_real, beep_counter, fx);
 631:ir_heat.c     **** 
 632:ir_heat.c     **** //				if((slope > max_slope) || (integral > 500)) {
 633:ir_heat.c     **** 				if(slope_real > slope_std) {
 634:ir_heat.c     **** 					on_counter++;
 635:ir_heat.c     **** 		   		printf("On-Counter: %i; \n", on_counter);
 636:ir_heat.c     **** 	   			if(mode == MODE_ON_NO_PROT){
 637:ir_heat.c     **** 						//on_counter++;
 638:ir_heat.c     **** 	   				if(on_counter==3){
 639:ir_heat.c     **** 	   					beep(BEEP_SHORT);
 640:ir_heat.c     **** 	   					beep_counter=1;
 641:ir_heat.c     **** 	   					on_counter = 0;
 642:ir_heat.c     **** 	   				}
 643:ir_heat.c     ****   					}
 644:ir_heat.c     ****    				else {
 645:ir_heat.c     ****    					if(get_last_slope() > 0) {
 646:ir_heat.c     **** 							//on_counter++;
 647:ir_heat.c     **** 			   			if((on_counter > 11) || (temp > 520)) {
 648:ir_heat.c     ****    							off_counter = OFF_COUNTER+1;
 649:ir_heat.c     ****    							on_counter = 0;
 650:ir_heat.c     ****    							if(mode == MODE_ON) {
 651:ir_heat.c     **** 	   							beep(BEEP_XLONG);
 652:ir_heat.c     ****    								if(temp<500) {
 653:ir_heat.c     **** 				   					beep_counter=1;
 654:ir_heat.c     ****    									//fx = fx+20;
 655:ir_heat.c     ****    								}
 656:ir_heat.c     ****    							}
 657:ir_heat.c     **** 		   				}
 658:ir_heat.c     **** 		   				else {
 659:ir_heat.c     **** 		   					if( ((on_counter > 4) && ((on_counter % 3) == 0)) || (temp > 500) ) {
 660:ir_heat.c     **** 		   						beep(BEEP_LONG);
 661:ir_heat.c     **** 		   						beep_counter = 1;
 662:ir_heat.c     **** 		   					}
 663:ir_heat.c     ****    						}
 664:ir_heat.c     ****    					}
 665:ir_heat.c     ****    					else {
 666:ir_heat.c     ****    						if(slope_raw<0) on_counter=0;
 667:ir_heat.c     ****    					}
 668:ir_heat.c     ****    				}
 669:ir_heat.c     **** 				}			
 670:ir_heat.c     **** 				else {
 671:ir_heat.c     **** 					on_counter = 0;
 672:ir_heat.c     **** 				}					
 673:ir_heat.c     ****    	   }
 674:ir_heat.c     **** 
 675:ir_heat.c     ****    		if(off_counter) {
 676:ir_heat.c     ****    			// Protection Counter läuft
 677:ir_heat.c     ****   				off_counter--;
 678:ir_heat.c     ****   				if(mode == MODE_ON) mode = MODE_TEMP_PROT;
 679:ir_heat.c     **** 				printf("Off-Counter: %i; \n", off_counter);
 680:ir_heat.c     ****    		}
 681:ir_heat.c     ****    		else {
 682:ir_heat.c     ****    			if(mode == MODE_TEMP_PROT) {
 683:ir_heat.c     ****    				slope = 0;
 684:ir_heat.c     ****    				integral = 0;
 685:ir_heat.c     ****    				mode = MODE_OFF;
 686:ir_heat.c     ****    			}
 687:ir_heat.c     ****    		}
 688:ir_heat.c     **** 		}
 689:ir_heat.c     **** 		else if(interval != last_interval) {
 690:ir_heat.c     **** 			// In jedem Interval 1x die Temperatur abrufen
 691:ir_heat.c     **** 			// und für den Mittelwert aufsummieren
 692:ir_heat.c     ****    		last_interval = interval;
 693:ir_heat.c     ****     		if(count<16) {
 694:ir_heat.c     **** 	   		count++;
 695:ir_heat.c     ****    			// Messwerte für den Mittelwert aufsummieren
 696:ir_heat.c     ****    			temp_sum += get_temperature(ADR_T_OBJ1);
 697:ir_heat.c     ****    		}
 698:ir_heat.c     ****    	}
 699:ir_heat.c     **** 
 700:ir_heat.c     **** 		// Je nach Mode Relais und LEDs setzen
 701:ir_heat.c     **** 		switch(mode) {
 702:ir_heat.c     **** 		case MODE_OFF:
 703:ir_heat.c     **** 			set_relais(0);
 704:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 1908               	_heat.c",132,0,0,.Ltext13
 1909               	.Ltext13:
 1911 08a8 FBE2      	.LM199:
 1912 08aa CF2E      		lds r20,interval
 1913 08ac DD24      		cpi r20,lo8(16)
 1914 08ae F02D      		brge .+2
 1915               		rjmp .L93
 1917 08b0 2224      	.LM200:
 1918 08b2 3324      	/* #APP */
 1919               	 ;  553 "ir_heat.c" 1
 1920               		wdr
 1921               	 ;  0 "" 2
 1923               	.LM201:
 1924               	/* #NOAPP */
 1925               		movw r24,r14
 1926               		mov r22,r16
 1927 08b4 0F2E      		ldi r23,lo8(0)
 1928 08b6 F0E5      		call __divmodhi4
 1929 08b8 4F2E      		mov r24,r22
 1930 08ba F3EC      		mov r25,r23
 1931 08bc 5F2E      		movw r14,r24
 1933               	.LM202:
 1934               		sts interval,__zero_reg__
 1936               	.LM203:
 1937               		cp r14,__zero_reg__
 1938               		cpc r15,__zero_reg__
 1939               		brne .L94
 1941               	.LM204:
 1942 08c0 4091 0000 		rcall .
 1943 08c4 4031      		ldi r24,lo8(.LC8)
 1944 08c6 04F4      		ldi r25,hi8(.LC8)
 1945 08c8 00C0      		in r30,__SP_L__
 1946               		in r31,__SP_H__
 1947               		std Z+2,r25
 1948               		std Z+1,r24
 1949               		call printf
 1950 08ca A895      		pop __tmp_reg__
 1951               		pop __tmp_reg__
 1952               		rjmp .L95
 1953               	.L94:
 1955 08cc C701      	.LM205:
 1956 08ce 602F      		tst r6
 1957 08d0 70E0      		breq .L96
 1959 08d6 862F      	.LM206:
 1960 08d8 972F      		rcall .
 1961 08da 7C01      		rcall .
 1962               		in r30,__SP_L__
 1963               		in r31,__SP_H__
 1964 08dc 1092 0000 		adiw r30,1
 1965               		ldi r24,lo8(.LC9)
 1966               		ldi r25,hi8(.LC9)
 1967 08e0 E114      		std Z+1,r25
 1968 08e2 F104      		st Z,r24
 1969 08e4 01F4      		std Z+2,r6
 1970               		std Z+3,__zero_reg__
 1971               		call printf
 1973 08e8 80E0      	.LM207:
 1974 08ea 90E0      		dec r6
 1976 08ee FEB7      	.LM208:
 1977 08f0 9283      		pop __tmp_reg__
 1978 08f2 8183      		pop __tmp_reg__
 1979 08f4 0E94 0000 		pop __tmp_reg__
 1980 08f8 0F90      		pop __tmp_reg__
 1981 08fa 0F90      		ldi r24,lo8(7)
 1982 08fc 00C0      		call get_temperature
 1983               		movw r14,r24
 1984               	.L96:
 1986 08fe 6620      	.LM209:
 1987 0900 01F0      		rcall .
 1988               		rcall .
 1989               		in r30,__SP_L__
 1990 0902 00D0      		in r31,__SP_H__
 1991 0904 00D0      		adiw r30,1
 1992 0906 EDB7      		ldi r24,lo8(.LC10)
 1993 0908 FEB7      		ldi r25,hi8(.LC10)
 1994 090a 3196      		std Z+1,r25
 1995 090c 80E0      		st Z,r24
 1996 090e 90E0      		std Z+3,r15
 1997 0910 9183      		std Z+2,r14
 1998 0912 8083      		call printf
 2000 0916 1382      	.LM210:
 2001 0918 0E94 0000 		pop __tmp_reg__
 2002               		pop __tmp_reg__
 2003               		pop __tmp_reg__
 2004 091c 6A94      		pop __tmp_reg__
 2005               		movw r24,r14
 2006               		call add_value
 2008 0920 0F90      	.LM211:
 2009 0922 0F90      		call get_slope
 2010 0924 0F90      		movw r8,r24
 2012 0928 0E94 0000 	.LM212:
 2013 092c 7C01      		ldi r24,lo8(6)
 2014               		call get_temperature
 2016               	.LM213:
 2017 092e 00D0      		call get_slope2
 2018 0930 00D0      		std Y+3,r25
 2019 0932 EDB7      		std Y+2,r24
 2021 0936 3196      	.LM214:
 2022 0938 80E0      		cp __zero_reg__,r11
 2023 093a 90E0      		brge .L97
 2025 093e 8083      	.LM215:
 2026 0940 F382      		tst r25
 2027 0942 E282      		brlt .L98
 2029               	.LM216:
 2030               		inc r11
 2031 0948 0F90      		rjmp .L97
 2032 094a 0F90      	.L98:
 2034 094e 0F90      	.LM217:
 2035 0950 C701      		ldi r25,lo8(20)
 2036 0952 0E94 0000 		add r7,r25
 2037               		mov __tmp_reg__,r31
 2038               		ldi r31,lo8(-10)
 2039 0956 0E94 0000 		mov r11,r31
 2040 095a 4C01      		mov r31,__tmp_reg__
 2041               	.L97:
 2042               		ldi r30,lo8(60)
 2043 095c 86E0      		cp r30,r7
 2044 095e 0E94 0000 		brge .L99
 2045               		mov __tmp_reg__,r31
 2046               		ldi r31,lo8(60)
 2047 0962 0E94 0000 		mov r7,r31
 2048 0966 9B83      		mov r31,__tmp_reg__
 2049 0968 8A83      	.L99:
 2051               	.LM218:
 2052 096a 1B14      		movw r24,r14
 2053 096c 04F4      		call exp_slope
 2054               		mov r18,r7
 2055               		clr r19
 2056 096e 9923      		sbrc r18,7
 2057 0970 04F0      		com r19
 2058               		movw r16,r18
 2059               		add r16,r24
 2060 0972 B394      		adc r17,r25
 2062               	.LM219:
 2063               		in r24,__SP_L__
 2064               		in r25,__SP_H__
 2065 0976 94E1      		sbiw r24,10
 2066 0978 790E      		in __tmp_reg__,__SREG__
 2067 097a 0F2E      		cli
 2068 097c F6EF      		out __SP_H__,r25
 2069 097e BF2E      		out __SREG__,__tmp_reg__
 2070 0980 F02D      		out __SP_L__,r24
 2071               		in r30,__SP_L__
 2072 0982 ECE3      		in r31,__SP_H__
 2073 0984 E715      		adiw r30,1
 2074 0986 04F4      		ldi r24,lo8(.LC11)
 2075 0988 0F2E      		ldi r25,hi8(.LC11)
 2076 098a FCE3      		std Z+1,r25
 2077 098c 7F2E      		st Z,r24
 2078 098e F02D      		std Z+3,r17
 2079               		std Z+2,r16
 2080               		ldd r24,Y+2
 2081               		ldd r25,Y+3
 2082 0990 C701      		std Z+5,r25
 2083 0992 0E94 0000 		std Z+4,r24
 2084 0996 272D      		mov r24,r11
 2085 0998 3327      		clr r25
 2086 099a 27FD      		sbrc r24,7
 2087 099c 3095      		com r25
 2088 099e 8901      		std Z+7,r25
 2089 09a0 080F      		std Z+6,r24
 2090 09a2 191F      		std Z+9,r19
 2091               		std Z+8,r18
 2092               		call printf
 2094 09a6 9EB7      	.LM220:
 2095 09a8 0A97      		in r30,__SP_L__
 2096 09aa 0FB6      		in r31,__SP_H__
 2097 09ac F894      		adiw r30,10
 2098 09ae 9EBF      		in __tmp_reg__,__SREG__
 2099 09b0 0FBE      		cli
 2100 09b2 8DBF      		out __SP_H__,r31
 2101 09b4 EDB7      		out __SREG__,__tmp_reg__
 2102 09b6 FEB7      		out __SP_L__,r30
 2103 09b8 3196      		ldd r24,Y+2
 2104 09ba 80E0      		ldd r25,Y+3
 2105 09bc 90E0      		cp r16,r24
 2106 09be 9183      		cpc r17,r25
 2107 09c0 8083      		brlt .+2
 2108 09c2 1383      		rjmp .L100
 2110 09c6 8A81      	.LM221:
 2111 09c8 9B81      		inc r10
 2113 09cc 8483      	.LM222:
 2114 09ce 8B2D      		rcall .
 2115 09d0 9927      		rcall .
 2116 09d2 87FD      		in r30,__SP_L__
 2117 09d4 9095      		in r31,__SP_H__
 2118 09d6 9783      		adiw r30,1
 2119 09d8 8683      		ldi r24,lo8(.LC12)
 2120 09da 3187      		ldi r25,hi8(.LC12)
 2121 09dc 2087      		std Z+1,r25
 2122 09de 0E94 0000 		st Z,r24
 2123               		std Z+2,r10
 2124               		std Z+3,__zero_reg__
 2125 09e2 EDB7      		call printf
 2127 09e6 3A96      	.LM223:
 2128 09e8 0FB6      		pop __tmp_reg__
 2129 09ea F894      		pop __tmp_reg__
 2130 09ec FEBF      		pop __tmp_reg__
 2131 09ee 0FBE      		pop __tmp_reg__
 2132 09f0 EDBF      		lds r24,mode
 2133 09f2 8A81      		cpi r24,lo8(2)
 2134 09f4 9B81      		brne .L101
 2136 09f8 1907      	.LM224:
 2137 09fa 04F0      		ldi r25,lo8(3)
 2138 09fc 00C0      		cp r10,r25
 2139               		breq .+2
 2140               		rjmp .L95
 2142               	.LM225:
 2143               		ldi r24,lo8(1)
 2144 0a00 00D0      		call beep
 2145 0a02 00D0      		clr r10
 2146 0a04 EDB7      		clr r11
 2147 0a06 FEB7      		inc r11
 2148 0a08 3196      		rjmp .L95
 2149 0a0a 80E0      	.L101:
 2151 0a0e 9183      	.LM226:
 2152 0a10 8083      		call get_last_slope
 2153 0a12 A282      		cp __zero_reg__,r24
 2154 0a14 1382      		cpc __zero_reg__,r25
 2155 0a16 0E94 0000 		brge .L102
 2157               	.LM227:
 2158 0a1a 0F90      		ldi r30,lo8(11)
 2159 0a1c 0F90      		cp r30,r10
 2160 0a1e 0F90      		brlo .L103
 2161 0a20 0F90      		ldi r31,lo8(521)
 2162 0a22 8091 0000 		cp r14,r31
 2163 0a26 8230      		ldi r31,hi8(521)
 2164 0a28 01F4      		cpc r15,r31
 2165               		brlt .L104
 2166               	.L103:
 2168 0a2c A916      	.LM228:
 2169 0a2e 01F0      		ldi r21,lo8(3)
 2170 0a30 00C0      		sts off_counter,r21
 2172               	.LM229:
 2173 0a32 81E0      		lds r24,mode
 2174 0a34 0E94 0000 		cpi r24,lo8(1)
 2175 0a38 AA24      		breq .L105
 2176 0a3a BB24      		clr r10
 2177 0a3c B394      		ldi r24,lo8(3)
 2178 0a3e 00C0      		rjmp .L106
 2179               	.L105:
 2181               	.LM230:
 2182 0a40 0E94 0000 		ldi r24,lo8(4)
 2183 0a44 1816      		call beep
 2185 0a48 04F4      	.LM231:
 2186               		ldi r24,lo8(500)
 2187               		cp r14,r24
 2188 0a4a EBE0      		ldi r24,hi8(500)
 2189 0a4c EA15      		cpc r15,r24
 2190 0a4e 00F0      		brge .L100
 2191 0a50 F9E0      		clr r10
 2192 0a52 EF16      		clr r11
 2193 0a54 F2E0      		inc r11
 2194 0a56 FF06      		rjmp .L95
 2195 0a58 04F0      	.L104:
 2197               	.LM232:
 2198               		ldi r25,lo8(4)
 2199 0a5a 53E0      		cp r25,r10
 2200 0a5c 5093 0000 		brsh .L107
 2201               		mov r24,r10
 2202               		ldi r22,lo8(3)
 2203 0a60 8091 0000 		call __udivmodqi4
 2204 0a64 8130      		tst r25
 2205 0a66 01F0      		breq .L108
 2206 0a68 AA24      	.L107:
 2207 0a6a 83E0      		ldi r30,lo8(501)
 2208 0a6c 00C0      		cp r14,r30
 2209               		ldi r30,hi8(501)
 2210               		cpc r15,r30
 2211               		brlt .L95
 2212 0a6e 84E0      	.L108:
 2214               	.LM233:
 2215               		ldi r24,lo8(3)
 2216 0a74 84EF      		call beep
 2217 0a76 E816      		clr r11
 2218 0a78 81E0      		inc r11
 2219 0a7a F806      		rjmp .L95
 2220 0a7c 04F4      	.L102:
 2222 0a80 BB24      	.LM234:
 2223 0a82 B394      		tst r9
 2224 0a84 00C0      		brge .L95
 2225               	.L100:
 2226               		clr r10
 2227               	.L95:
 2229 0a88 9A15      	.LM235:
 2230 0a8a 00F4      		lds r24,off_counter
 2231 0a8c 8A2D      		tst r24
 2232 0a8e 63E0      		breq .L109
 2233 0a90 0E94 0000 	.L106:
 2235 0a96 01F0      	.LM236:
 2236               		subi r24,lo8(-(-1))
 2237 0a98 E5EF      		sts off_counter,r24
 2239 0a9c E1E0      	.LM237:
 2240 0a9e FE06      		lds r24,mode
 2241 0aa0 04F0      		cpi r24,lo8(1)
 2242               		brne .L110
 2243               		ldi r31,lo8(3)
 2244               		sts mode,r31
 2245 0aa2 83E0      	.L110:
 2247 0aa8 BB24      	.LM238:
 2248 0aaa B394      		rcall .
 2249 0aac 00C0      		rcall .
 2250               		in r30,__SP_L__
 2251               		in r31,__SP_H__
 2252               		adiw r30,1
 2253 0aae 9920      		ldi r24,lo8(.LC13)
 2254 0ab0 04F4      		ldi r25,hi8(.LC13)
 2255               		std Z+1,r25
 2256 0ab2 AA24      		st Z,r24
 2257               		lds r24,off_counter
 2258               		std Z+2,r24
 2259               		std Z+3,__zero_reg__
 2260 0ab4 8091 0000 		call printf
 2261 0ab8 8823      		movw r14,r2
 2262 0aba 01F0      		ldi r16,lo8(0)
 2263               		pop __tmp_reg__
 2264               		pop __tmp_reg__
 2265               		pop __tmp_reg__
 2266 0abc 8150      		pop __tmp_reg__
 2267 0abe 8093 0000 		rjmp .L111
 2268               	.L109:
 2270 0ac2 8091 0000 	.LM239:
 2271 0ac6 8130      		lds r24,mode
 2272 0ac8 01F4      		cpi r24,lo8(3)
 2273 0aca F3E0      		breq .L112
 2274 0acc F093 0000 		movw r14,r2
 2275               		ldi r16,lo8(0)
 2276               		rjmp .L111
 2277               	.L112:
 2279 0ad2 00D0      	.LM240:
 2280 0ad4 EDB7      		sts mode,__zero_reg__
 2281 0ad6 FEB7      		movw r14,r2
 2282 0ad8 3196      		ldi r16,lo8(0)
 2283 0ada 80E0      		rjmp .L113
 2284 0adc 90E0      	.L93:
 2286 0ae0 8083      	.LM241:
 2287 0ae2 8091 0000 		mov r18,r20
 2288 0ae6 8283      		clr r19
 2289 0ae8 1382      		sbrc r18,7
 2290 0aea 0E94 0000 		com r19
 2291 0aee 7101      		ldd r30,Y+1
 2292 0af0 00E0      		mov r24,r30
 2293 0af2 0F90      		ldi r25,lo8(0)
 2294 0af4 0F90      		cp r18,r24
 2295 0af6 0F90      		cpc r19,r25
 2296 0af8 0F90      		breq .L111
 2298               	.LM242:
 2299               		std Y+1,r20
 2301 0afc 8091 0000 	.LM243:
 2302 0b00 8330      		cpi r16,lo8(16)
 2303 0b02 01F0      		brsh .L111
 2305 0b06 00E0      	.LM244:
 2306 0b08 00C0      		subi r16,lo8(-(1))
 2308               	.LM245:
 2309               		ldi r24,lo8(7)
 2310 0b0a 1092 0000 		call get_temperature
 2311 0b0e 7101      		add r14,r24
 2312 0b10 00E0      		adc r15,r25
 2313 0b12 00C0      	.L111:
 2315               	.LM246:
 2316               		lds r24,mode
 2317 0b14 242F      		cpi r24,lo8(1)
 2318 0b16 3327      		breq .L115
 2319 0b18 27FD      		cpi r24,lo8(1)
 2320 0b1a 3095      		brlo .L113
 2321 0b1c E981      		cpi r24,lo8(2)
 2322 0b1e 8E2F      		breq .L116
 2323 0b20 90E0      		cpi r24,lo8(3)
 2324 0b22 2817      		brne .L121
 2325 0b24 3907      		rjmp .L122
 2326 0b26 01F0      	.L113:
 2328               	.LM247:
 2329 0b28 4983      		ldi r24,lo8(0)
 2330               		call set_relais
 2332 0b2a 0031      	.LM248:
 2333 0b2c 00F4      		movw r30,r12
 2334               		ld r24,Z
 2335               		ori r24,lo8(16)
 2336 0b2e 0F5F      		st Z,r24
 2338               	.LM249:
 2339 0b30 87E0      		ld r24,Z
 2340 0b32 0E94 0000 		andi r24,lo8(-9)
 2341 0b36 E80E      		st Z,r24
 2343               	.LM250:
 2344               		sts off_counter,__zero_reg__
 2345               		clr r10
 2346 0b3a 8091 0000 		clr r11
 2347 0b3e 8130      		rjmp .L118
 2348 0b40 01F0      	.L115:
 2350 0b44 00F0      	.LM251:
 2351 0b46 8230      		movw r30,r12
 2352 0b48 01F0      		ld r24,Z
 2353 0b4a 8330      		ori r24,lo8(16)
 2354 0b4c 01F4      		st Z,r24
 2355 0b4e 00C0      	.L116:
 2357               	.LM252:
 2358               		ldi r24,lo8(1)
 2359 0b50 80E0      		call set_relais
 2361               	.LM253:
 2362               		movw r30,r12
 2363 0b56 F601      		ld r24,Z
 2364 0b58 8081      		ori r24,lo8(8)
 2365 0b5a 8061      		st Z,r24
 2366 0b5c 8083      		rjmp .L118
 705:ir_heat.c     **** 			STATUS_LED2_OFF;
 2367               	.LFBB22
 2368               	.LM256:
 2369 0b5e 8081      		ld r24,Z
 2370 0b60 877F      		ori r24,lo8(8)
 2371 0b62 8083      		st Z,r24
 706:ir_heat.c     **** 			off_counter = 0;
 2372               	ndi r24,lo8(-17)
 2373               		st Z,r24
 2375 0b68 AA24      	.LM256:
 2376 0b6a BB24      		ld r24,Z
 2377 0b6c 00C0      		ori r24,lo8(8)
 2378               		st Z,r24
 707:ir_heat.c     **** 			on_counter = 0;
 708:ir_heat.c     **** 			beep_counter = 0;
 709:ir_heat.c     **** 			break;
 710:ir_heat.c     **** 		case MODE_ON:
 711:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 2379               	ndi r24,lo8(-17)
 2380               		st Z,r24
 2382 0b70 8081      	.LM256:
 2383 0b72 8061      		ld r24,Z
 2384 0b74 8083      		ori r24,lo8(8)
 2385               		st Z,r24
 712:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 713:ir_heat.c     **** 			set_relais(1);
 2386               	ndi r24,lo8(-17)
 2387               		st Z,r24
 2389 0b78 0E94 0000 	.LM256:
 714:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2390               	BB22
 2391               	.LM255:
 2392 0b7c F601      		movw r30,r12
 2393 0b7e 8081      		ld r24,Z
 2394 0b80 8860      		andi r24,lo8(-17)
 2395 0b82 8083      		st Z,r24
 2397               	.LM256:
 715:ir_heat.c     **** 			break;
 716:ir_heat.c     **** 		case MODE_TEMP_PROT:
 717:ir_heat.c     **** 			set_relais(0);
 2398               	BB22
 2399               	.LM255:
 2400 0b86 80E0      		movw r30,r12
 2401 0b88 0E94 0000 		ld r24,Z
 718:ir_heat.c     **** 			STATUS_LED1_OFF;
 2402               	BB22
 2403               	.LM254:
 2404 0b8c F601      		ldi r24,lo8(0)
 2405 0b8e 8081      		call set_relais
 2407 0b92 8083      	.LM255:
 719:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2409               	.LM254:
 2410 0b94 8081      		ldi r24,lo8(0)
 2411 0b96 8860      		call set_relais
 2413 0b9a 00C0      	.LM255:
 2414               		movw r30,r12
 720:ir_heat.c     **** 			slope = 0;
 721:ir_heat.c     **** 			integral = 0;
 722:ir_heat.c     **** 			break;
 723:ir_heat.c     **** 		default:
 724:ir_heat.c     **** 			mode = MODE_OFF;
 2415               	,.LM254-.LFBB22
 2416               	.LM254:
 2417 0b9c 1092 0000 		ldi r24,lo8(0)
 2418               		call set_relais
 2420               	.LM255:
 2421               		movw r30,r12
 2422               		ld r24,Z
 2423               		andi r24,lo8(-17)
 2424               		st Z,r24
 2426               	.LM256:
 2427 0ba0 C201      		ld r24,Z
 2428               		ori r24,lo8(8)
 2429               		st Z,r24
 2430 0ba2 0197      		rjmp .L118
 2431 0ba4 01F4      	.L121:
 2433               	.LM257:
 2434 0ba6 00C0      		sts mode,__zero_reg__
 2435               	.L118:
 2436               	.LBB65:
 2437               	.LBB64:
 2438               	.LBB63:
 2439               	.LBB62:
 2441               	.Ltext14:
 2443               	.LM258:
 2444               		movw r24,r4
 2445               	/* #APP */
 2446               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 2447               		1: sbiw r24,1
 2448               		brne 1b
 2449               	 ;  0 "" 2
 2450               	/* #NOAPP */
 2451               		rjmp .L119
 2452               	.LBE62:
 2453               	.LBE63:
 2454               	.LBE64:
 2455               	.LBE65:
 2470               	.Lscope22:
 2471               	.global	interval
 2472 0001 00        		.data
 2475               	interval:
 2476               		.byte	-12
 2477               	.global	off_counter
 2478 0002 00        	.global	off_counter
 2479               		.section .bss
 2482               	off_counter:
 2483               		.skip 1,0
 2484               	.global	flash_button
 2485               	.global	flash_button
 2488               	flash_button:
 2489               		.skip 1,0
 2490               	.global	flash_LED
 2491               	.global	flash_LED
 2494               	flash_LED:
 2495               		.skip 1,0
 2496               		.lcomm last.2012,1
 2497               		.lcomm last_slope.1898,2
 2498               		.lcomm running.1766,1
 2499               		.lcomm c2.1740,1
 2500               		.lcomm c1.1739,1
 2501               		.comm tbuf,32,1
 2502               		.comm rbuf,32,1
 2503               		.comm t_in,1,1
 2504               		.comm t_out,1,1
 2505               		.comm r_in,1,1
 2506               		.comm r_out,1,1
 2507               		.comm t_array,12,1
 2508               		.comm mode,1,1
 2509               		.comm slope2,2,1
DEFINED SYMBOLS
                            *ABS*:00000000 ir_heat.c
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:2      *ABS*:0000003f __SREG__
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:3      *ABS*:0000003e __SP_H__
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:4      *ABS*:0000003d __SP_L__
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:5      *ABS*:00000034 __CCP__
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:93     .text:00000000 __vector_9
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:2458   .data:000000c3 interval
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:124    .text:00000022 __vector_13
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:157    .text:00000042 __vector_16
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:2482   .bss:00000008 c1.1739
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:2481   .bss:00000007 c2.1740
                            *COM*:00000001 mode
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:278    .text:000000de __vector_18
                            *COM*:00000001 r_in
                            *COM*:00000020 rbuf
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:328    .text:0000011c __vector_19
                            *COM*:00000001 t_in
                            *COM*:00000001 t_out
                            *COM*:00000020 tbuf
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:391    .text:00000176 tbuflen
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:413    .text:00000182 UART_putchar
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:470    .text:000001ce rbuflen
                            *COM*:00000001 r_out
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:491    .text:000001da UART_getchar
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:531    .text:00000200 exp_slope
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:580    .text:00000240 get_slope2
                            *COM*:0000000c t_array
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:2479   .bss:00000004 last_slope.1898
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:625    .text:00000286 add_value
                            *COM*:00000002 slope2
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:740    .text:0000034c get_slope
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:817    .text:000003cc get_last_slope
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:843    .text:000003e6 _beep
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:925    .text:00000424 set_relais
                             .bss:00000003 last.2012
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:993    .text:0000046a beep
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:1163   .text:000004f2 __vector_1
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:2480   .bss:00000006 running.1766
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:1429   .text:00000624 get_temperature
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:1526   .text:00000694 print_array
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:1664   .text:00000790 UART_first_init
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:1723   .text:000007b8 main
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:2465   .bss:00000000 off_counter
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:2471   .bss:00000001 flash_button
C:\Users\Thorsten\AppData\Local\Temp/ccMH4PAA.s:2477   .bss:00000002 flash_LED

UNDEFINED SYMBOLS
__divmodhi4
__udivmodhi4
puts
i2c_start
i2c_write
i2c_rep_start
i2c_readAck
i2c_stop
printf
putchar
fdevopen
i2c_init
__udivmodqi4
__do_copy_data
__do_clear_bss
