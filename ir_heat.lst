   1               		.file	"ir_heat.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  87               	.global	__vector_9
  89               	__vector_9:
   1:ir_heat.c     **** // ***********************************************************
   2:ir_heat.c     **** // Project:
   3:ir_heat.c     **** // Author:
   4:ir_heat.c     **** // Module description:
   5:ir_heat.c     **** // ***********************************************************
   6:ir_heat.c     **** 
   7:ir_heat.c     **** #ifndef F_CPU
   8:ir_heat.c     **** #define F_CPU 1000000UL
   9:ir_heat.c     **** #endif
  10:ir_heat.c     **** 
  11:ir_heat.c     **** #include <avr\io.h>              // Most basic include files
  12:ir_heat.c     **** #include <avr\interrupt.h>       // Add the necessary ones
  13:ir_heat.c     **** //#include <avr\signal.h>          // here
  14:ir_heat.c     **** #include <avr\wdt.h>
  15:ir_heat.c     **** 
  16:ir_heat.c     **** #include <stdio.h>
  17:ir_heat.c     **** #include <string.h>
  18:ir_heat.c     **** #include <stdlib.h>
  19:ir_heat.c     **** #include	<util/delay.h>
  20:ir_heat.c     **** 
  21:ir_heat.c     **** #include "i2c_mstr.h"
  22:ir_heat.c     **** #include "ir_heat.h"
  23:ir_heat.c     **** 
  24:ir_heat.c     **** #define 	MLX90614_WRITE	(0x5A<<1)
  25:ir_heat.c     **** #define 	MLX90614_READ	(MLX90614_WRITE+1)
  26:ir_heat.c     **** #define	ADR_T_A			0x06
  27:ir_heat.c     **** #define	ADR_T_OBJ1		0x07
  28:ir_heat.c     **** #define	ADR_T_OBJ2		0x08
  29:ir_heat.c     **** 
  30:ir_heat.c     **** 
  31:ir_heat.c     **** #define __STDIO_FDEVOPEN_COMPAT_12						
  32:ir_heat.c     **** // Buffer sizes must be 2^n
  33:ir_heat.c     **** //
  34:ir_heat.c     **** #define TBUFSIZE			32
  35:ir_heat.c     **** #define RBUFSIZE			32
  36:ir_heat.c     **** 
  37:ir_heat.c     **** #define TMASK				(TBUFSIZE-1)
  38:ir_heat.c     **** #define RMASK				(RBUFSIZE-1)
  39:ir_heat.c     **** 
  40:ir_heat.c     **** #define FLASH_LED			PC3
  41:ir_heat.c     **** #define STATUS_LED1		PD4
  42:ir_heat.c     **** #define STATUS_LED2		PD3
  43:ir_heat.c     **** #define RELAIS				PB6
  44:ir_heat.c     **** #define BUZZER				PB7
  45:ir_heat.c     **** #define SWITCH				PD2
  46:ir_heat.c     **** 
  47:ir_heat.c     **** #define RELAIS_ON			PORTB |= (1<<RELAIS)
  48:ir_heat.c     **** #define RELAIS_OFF		PORTB &=~(1<<RELAIS)
  49:ir_heat.c     **** 
  50:ir_heat.c     **** #define BUZZER_ON			PORTB |= (1<<BUZZER)
  51:ir_heat.c     **** #define BUZZER_OFF		PORTB &=~(1<<BUZZER)
  52:ir_heat.c     **** 
  53:ir_heat.c     **** #define STATUS_LED1_ON	PORTD |= (1<<STATUS_LED1)
  54:ir_heat.c     **** #define STATUS_LED1_OFF	PORTD &=~(1<<STATUS_LED1)
  55:ir_heat.c     **** 
  56:ir_heat.c     **** #define FLASH_LED_ON		PORTC |= (1<<FLASH_LED)
  57:ir_heat.c     **** #define FLASH_LED_OFF	PORTC &=~(1<<FLASH_LED)
  58:ir_heat.c     **** 
  59:ir_heat.c     **** #define STATUS_LED2_ON	PORTD |= (1<<STATUS_LED2)
  60:ir_heat.c     **** #define STATUS_LED2_OFF	PORTD &=~(1<<STATUS_LED2)
  61:ir_heat.c     **** 
  62:ir_heat.c     **** #define OFF_COUNTER		2
  63:ir_heat.c     **** 
  64:ir_heat.c     **** #define TIMER1_STOP		TCCR1B = 0
  65:ir_heat.c     **** #define TIMER1_RUN		TCCR1B = (0<<CS12) | (1<<CS11) | (0<<CS10)
  66:ir_heat.c     **** 
  67:ir_heat.c     **** #define	MODE_OFF				0
  68:ir_heat.c     **** #define	MODE_ON				1
  69:ir_heat.c     **** #define	MODE_ON_NO_PROT	2
  70:ir_heat.c     **** #define	MODE_TEMP_PROT		3
  71:ir_heat.c     **** 
  72:ir_heat.c     **** #define	BEEP_SHORT			1
  73:ir_heat.c     **** #define	BEEP_2SHORT			2
  74:ir_heat.c     **** #define	BEEP_LONG			3
  75:ir_heat.c     **** #define	BEEP_XLONG			4
  76:ir_heat.c     **** #define	BEEP_2LONG			5
  77:ir_heat.c     **** #define	BEEP_SHORT_LONG	6
  78:ir_heat.c     **** 
  79:ir_heat.c     **** // Define here the global static variables
  80:ir_heat.c     **** //
  81:ir_heat.c     **** volatile unsigned char tbuf[TBUFSIZE];  // TX buffer
  82:ir_heat.c     **** volatile unsigned char rbuf[RBUFSIZE];  // RX buffer
  83:ir_heat.c     **** 
  84:ir_heat.c     **** volatile unsigned char t_in;            // TX buffer in index
  85:ir_heat.c     **** volatile unsigned char t_out;           // TX buffer out index
  86:ir_heat.c     **** 
  87:ir_heat.c     **** volatile unsigned char r_in;            // RX buffer in index
  88:ir_heat.c     **** volatile unsigned char r_out;           // RX buffer out index
  89:ir_heat.c     **** 
  90:ir_heat.c     **** int8_t	interval = -12;
  91:ir_heat.c     **** int16_t 	t_array[6];
  92:ir_heat.c     **** uint8_t	off_counter = 0;
  93:ir_heat.c     **** uint8_t	mode;
  94:ir_heat.c     **** int16_t	slope2;
  95:ir_heat.c     **** uint8_t	flash_button = 0;
  96:ir_heat.c     **** uint8_t	flash_LED = 0;
  97:ir_heat.c     **** 
  98:ir_heat.c     **** /*
  99:ir_heat.c     **** uint16_t	t_la_threshold_up 	=  300;
 100:ir_heat.c     **** uint16_t	t_abs_threshold_up 	=  270;
 101:ir_heat.c     **** uint16_t	t_la_threshold_down 	=  250;
 102:ir_heat.c     **** uint16_t	t_abs_threshold_down	=  250;
 103:ir_heat.c     **** */
 104:ir_heat.c     **** 
 105:ir_heat.c     **** 
 106:ir_heat.c     **** // Clock Timer
 107:ir_heat.c     **** SIGNAL(SIG_OVERFLOW2) {
  90               	ush r0
  91               		clr __zero_reg__
  92               		push r24
  93 0000 1F92      	/* prologue: Signal */
  94 0002 0F92      	/* frame size = 0 */
  96 0006 0F92      	.LM1:
  97 0008 1124      		lds r24,interval
  98 000a 8F93      		subi r24,lo8(-(1))
  99               		sts interval,r24
 100               	/* epilogue start */
 108:ir_heat.c     **** 	interval++;
 101               	0,109,.LM2-.LFBB1
 102               	.LM2:
 103 000c 8091 0000 		pop r24
 104 0010 8F5F      		pop r0
 105 0012 8093 0000 		out __SREG__,r0
 106               		pop r0
 109:ir_heat.c     **** }
 107               	_zero_reg__
 108               		reti
 110 0018 0F90      	.Lscope1:
 112 001c 0F90      	.global	__vector_13
 114 0020 1895      	__vector_13:
 116               	.LM3:
 117               	.LFBB2:
 118               		push __zero_reg__
 119               		push r0
 120               		in r0,__SREG__
 110:ir_heat.c     **** 
 111:ir_heat.c     **** SIGNAL(SIG_OVERFLOW1) {
 121               	__zero_reg__
 122               	/* prologue: Signal */
 123               	/* frame size = 0 */
 125 0024 0F92      	.LM4:
 126 0026 0FB6      		sts 129,__zero_reg__
 128 002a 1124      	.LM5:
 129               		sts 133,__zero_reg__
 112:ir_heat.c     **** 	TIMER1_STOP;
 131               	 132,__zero_reg__
 132               	/* epilogue start */
 113:ir_heat.c     **** 	TCNT1H = 0;
 134               	7:
 135               		pop r0
 136 0030 1092 8500 		out __SREG__,r0
 114:ir_heat.c     **** 	TCNT1L = 0;
 137               	p r0
 138               		pop __zero_reg__
 139 0034 1092 8400 		reti
 115:ir_heat.c     **** }
 141               	ope2:
 143 0038 0F90      	.global	__vector_16
 145 003c 0F90      	__vector_16:
 147 0040 1895      	.LM8:
 148               	.LFBB3:
 149               		push __zero_reg__
 150               		push r0
 151               		in r0,__SREG__
 152               		push r0
 153               		clr __zero_reg__
 116:ir_heat.c     **** 
 117:ir_heat.c     **** 
 118:ir_heat.c     **** // LED Flasher
 119:ir_heat.c     **** SIGNAL(SIG_OVERFLOW0) {
 154               	sh r19
 155               		push r20
 156               		push r24
 157 0042 1F92      		push r25
 158 0044 0F92      		push r30
 159 0046 0FB6      		push r31
 160 0048 0F92      	/* prologue: Signal */
 161 004a 1124      	/* frame size = 0 */
 163 004e 3F93      	.LM9:
 164 0050 4F93      		lds r24,c1.1726
 165 0052 8F93      		mov r18,r24
 166 0054 9F93      		subi r18,lo8(-(1))
 167 0056 EF93      		sts c1.1726,r18
 169               	.LM10:
 170               		lds r24,c2.1727
 120:ir_heat.c     **** 	static uint8_t	c1 = 0;
 121:ir_heat.c     **** 	static uint8_t c2 = 0;
 122:ir_heat.c     **** 	uint8_t slow=0;
 123:ir_heat.c     **** 	c1++;
 171               	i r19,lo8(-(1))
 172               		sts c2.1727,r19
 174 005e 282F      	.LM11:
 175 0060 2F5F      		lds r20,mode
 176 0062 2093 0000 		cpi r20,lo8(3)
 124:ir_heat.c     **** 	c2++;
 177               	.L6
 179 0066 8091 0000 	.LM12:
 180 006a 382F      		mov r24,r18
 181 006c 3F5F      		ldi r25,lo8(0)
 182 006e 3093 0000 		sbiw r24,7
 125:ir_heat.c     **** 	
 126:ir_heat.c     **** 	// Tasten LED
 127:ir_heat.c     **** 	if (mode==MODE_TEMP_PROT) {
 183               	.L6
 185 0072 4091 0000 	.LM13:
 186 0076 4330      		ldi r30,lo8(40)
 187 0078 01F4      		ldi r31,hi8(40)
 128:ir_heat.c     **** 		if(c1 > (6<<slow)) {
 188               	24,Z
 189               		ori r24,lo8(8)
 190 007a 822F      		st Z,r24
 191 007c 90E0      	.L6:
 193 0080 04F0      	.LM14:
 129:ir_heat.c     **** 			FLASH_LED_ON;
 194               	24,r18
 195               		ldi r25,lo8(0)
 196 0082 E8E2      		sbiw r24,11
 197 0084 F0E0      		brlt .L7
 199 0088 8860      	.LM15:
 200 008a 8083      		sts c1.1726,__zero_reg__
 130:ir_heat.c     **** 		}
 131:ir_heat.c     **** 	}
 132:ir_heat.c     **** 	if(c1 > (10<<slow)) {
 202               	ldi r30,lo8(40)
 203               		ldi r31,hi8(40)
 204 008c 822F      		ld r24,Z
 205 008e 90E0      		andi r24,lo8(-9)
 206 0090 0B97      		st Z,r24
 207 0092 04F0      	.L7:
 133:ir_heat.c     **** 		c1 = 0;
 208               	n	68,0,138,.LM17-.LFBB3
 209               	.LM17:
 210 0094 1092 0000 		cpi r20,lo8(2)
 134:ir_heat.c     **** 		FLASH_LED_OFF;
 211               	ne .L8
 213 0098 E8E2      	.LM18:
 214 009a F0E0      		cpi r19,lo8(121)
 215 009c 8081      		brlo .L8
 217 00a0 8083      	.LM19:
 218               		ldi r30,lo8(43)
 135:ir_heat.c     **** 	}
 136:ir_heat.c     **** 	
 137:ir_heat.c     **** 	// Status LED
 138:ir_heat.c     **** 	if (mode==MODE_ON_NO_PROT) {
 219               	,hi8(43)
 220               		ld r24,Z
 221 00a2 4230      		andi r24,lo8(-17)
 222 00a4 01F4      		st Z,r24
 139:ir_heat.c     **** 		if(c2 > 120) {
 223               	
 225 00a6 3937      	.LM20:
 226 00a8 00F0      		cpi r19,lo8(-120)
 140:ir_heat.c     **** 			STATUS_LED1_OFF;	// rot
 227               	lo .L10
 229 00aa EBE2      	.LM21:
 230 00ac F0E0      		sts c2.1727,__zero_reg__
 232 00b0 8F7E      	.LM22:
 233 00b2 8083      		ldi r30,lo8(43)
 234               		ldi r31,hi8(43)
 141:ir_heat.c     **** 		}
 142:ir_heat.c     **** 	}
 143:ir_heat.c     **** 	if(c2 > 135) {
 235               	Z
 236               		ori r24,lo8(16)
 237 00b4 3838      		st Z,r24
 238 00b6 00F0      	.L10:
 144:ir_heat.c     **** 		c2 = 0;
 239               	pilogue start */
 241 00b8 1092 0000 	.LM23:
 145:ir_heat.c     **** 		STATUS_LED1_ON; 		// orange
 242               	p r31
 243               		pop r30
 244 00bc EBE2      		pop r25
 245 00be F0E0      		pop r24
 246 00c0 8081      		pop r20
 247 00c2 8061      		pop r19
 248 00c4 8083      		pop r18
 249               		pop r0
 250               		out __SREG__,r0
 146:ir_heat.c     **** 	}	
 147:ir_heat.c     **** }
 251               	pop __zero_reg__
 252               		reti
 258 00d0 3F91      	.Lscope3:
 260 00d4 0F90      	.global	__vector_18
 262 00d8 0F90      	__vector_18:
 264 00dc 1895      	.LM24:
 265               	.LFBB4:
 266               		push __zero_reg__
 267               		push r0
 268               		in r0,__SREG__
 269               		push r0
 270               		clr __zero_reg__
 271               		push r24
 272               		push r30
 273               		push r31
 274               	/* prologue: Signal */
 148:ir_heat.c     **** 
 149:ir_heat.c     **** 
 150:ir_heat.c     **** 
 151:ir_heat.c     **** //*******************************************
 152:ir_heat.c     **** //
 153:ir_heat.c     **** // Taster IQR und Entprellung
 154:ir_heat.c     **** //
 155:ir_heat.c     **** SIGNAL(SIG_INTERRUPT0) {
 156:ir_heat.c     **** 	static uint8_t running = 0;
 157:ir_heat.c     **** 	
 158:ir_heat.c     **** 	if(running | TCNT1H | TCNT1L){
 159:ir_heat.c     **** //		printf("X");
 160:ir_heat.c     **** 		return;
 161:ir_heat.c     **** 	}
 162:ir_heat.c     **** 	running = 1;
 163:ir_heat.c     **** 	wdt_reset();
 164:ir_heat.c     **** 	
 165:ir_heat.c     **** 	uint16_t i;
 166:ir_heat.c     **** 	uint16_t c = 0;
 167:ir_heat.c     **** 	EIMSK = 0;
 168:ir_heat.c     **** 	sei();
 169:ir_heat.c     **** 	//printf("In");
 170:ir_heat.c     **** 	for(i=0;i<1000;i++) if((PIND & (1<<SWITCH))) c++;
 171:ir_heat.c     **** 	//printf(" %i ", c);
 172:ir_heat.c     **** 
 173:ir_heat.c     **** 	if(c < 200) {
 174:ir_heat.c     **** 		TCNT1L = 1;
 175:ir_heat.c     **** 		TIMER1_RUN;
 176:ir_heat.c     **** 		switch(mode) {
 177:ir_heat.c     **** 		case MODE_OFF:
 178:ir_heat.c     **** 			mode = MODE_ON;
 179:ir_heat.c     **** 			set_relais(1);
 180:ir_heat.c     **** 			STATUS_LED1_ON;			// orange
 181:ir_heat.c     **** 			STATUS_LED2_ON;
 182:ir_heat.c     **** 			c = 0;
 183:ir_heat.c     **** 			while((!(PIND & (1<<SWITCH))) && (c < 300)) {
 184:ir_heat.c     **** 				c++;
 185:ir_heat.c     **** 				_delay_ms (10);
 186:ir_heat.c     **** 			}
 187:ir_heat.c     **** 			//printf("c: %i", c);
 188:ir_heat.c     **** 
 189:ir_heat.c     **** 			if(c < 300) {
 190:ir_heat.c     **** 				// normal einnschalten
 191:ir_heat.c     **** 				mode = MODE_ON;
 192:ir_heat.c     **** 			}
 193:ir_heat.c     **** 			else {
 194:ir_heat.c     **** 				// einschalten, aber ohne Hitzeschutz
 195:ir_heat.c     **** 				mode = MODE_ON_NO_PROT;
 196:ir_heat.c     **** 				printf("Temperature Protection Off!\n");
 197:ir_heat.c     **** 				STATUS_LED1_OFF;		// rot
 198:ir_heat.c     **** 				STATUS_LED2_ON;
 199:ir_heat.c     **** 				beep(BEEP_SHORT_LONG);
 200:ir_heat.c     **** 			}
 201:ir_heat.c     **** 			break;
 202:ir_heat.c     **** 		case MODE_ON:
 203:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 204:ir_heat.c     **** 		case MODE_TEMP_PROT:
 205:ir_heat.c     **** 		default:
 206:ir_heat.c     **** 			printf("\nxXx\n");
 207:ir_heat.c     **** 			mode = MODE_OFF;
 208:ir_heat.c     **** 		}
 209:ir_heat.c     **** 	}
 210:ir_heat.c     **** //	printf("Out\n");
 211:ir_heat.c     **** 	EIFR 		= (1<<INTF0);
 212:ir_heat.c     **** 	EIMSK 	= (1<<INT0);
 213:ir_heat.c     **** 	running 	= 0;
 214:ir_heat.c     **** 	//printf("Exit\n");
 215:ir_heat.c     **** }
 216:ir_heat.c     **** 
 217:ir_heat.c     **** 
 218:ir_heat.c     **** 
 219:ir_heat.c     **** SIGNAL(SIG_USART_RECV) {
 275               	tabn	68,0,224,.LM25-.LFBB4
 276               	.LM25:
 277               		lds r24,198
 279 00e0 0F92      	.LM26:
 280 00e2 0FB6      		lds r30,r_in
 281 00e4 0F92      		ldi r31,lo8(0)
 282 00e6 1124      		andi r30,lo8(31)
 283 00e8 8F93      		andi r31,hi8(31)
 284 00ea EF93      		subi r30,lo8(-(rbuf))
 285 00ec FF93      		sbci r31,hi8(-(rbuf))
 286               		st Z,r24
 220:ir_heat.c     **** //******************
 221:ir_heat.c     **** // RX interrupt handler
 222:ir_heat.c     **** //
 223:ir_heat.c     **** 	char c;	
 224:ir_heat.c     **** 	c = UDR0;							// Get received char
 288               	24,r_in
 289               		subi r24,lo8(-(1))
 290 00ee 8091 C600 		sts r_in,r24
 225:ir_heat.c     **** 	rbuf[r_in & RMASK] = c;
 291               	epilogue start */
 293 00f2 E091 0000 	.LM28:
 294 00f6 F0E0      		pop r31
 295 00f8 EF71      		pop r30
 296 00fa F070      		pop r24
 297 00fc E050      		pop r0
 298 00fe F040      		out __SREG__,r0
 299 0100 8083      		pop r0
 226:ir_heat.c     **** 	r_in++;
 300               	ro_reg__
 301               		reti
 227:ir_heat.c     **** }
 306               	e4:
 308 010c FF91      	.global	__vector_19
 310 0110 8F91      	__vector_19:
 312 0114 0FBE      	.LM29:
 313 0116 0F90      	.LFBB5:
 314 0118 1F90      		push __zero_reg__
 315 011a 1895      		push r0
 316               		in r0,__SREG__
 317               		push r0
 318               		clr __zero_reg__
 319               		push r24
 320               		push r25
 321               		push r30
 322               		push r31
 323               	/* prologue: Signal */
 324               	/* frame size = 0 */
 228:ir_heat.c     **** 
 229:ir_heat.c     **** SIGNAL(SIG_USART_DATA) {
 325               	M30-.LFBB5
 326               	.LM30:
 327               		lds r25,t_in
 328 011c 1F92      		lds r24,t_out
 329 011e 0F92      		cp r25,r24
 330 0120 0FB6      		breq .L14
 332 0124 1124      	.LM31:
 333 0126 8F93      		lds r30,t_out
 334 0128 9F93      		ldi r31,lo8(0)
 335 012a EF93      		andi r30,lo8(31)
 336 012c FF93      		andi r31,hi8(31)
 337               		subi r30,lo8(-(tbuf))
 338               		sbci r31,hi8(-(tbuf))
 230:ir_heat.c     **** //*******************
 231:ir_heat.c     **** // Data register empty interrupt handler.
 232:ir_heat.c     **** // Indicates that next char can be transmitted
 233:ir_heat.c     **** //
 234:ir_heat.c     **** 	if(t_in != t_out) {
 339               	 198,r24
 341 012e 9091 0000 	.LM32:
 342 0132 8091 0000 		lds r24,t_out
 343 0136 9817      		subi r24,lo8(-(1))
 344 0138 01F0      		sts t_out,r24
 235:ir_heat.c     **** 		UDR0 = tbuf[t_out & TMASK];
 345               	.L16
 346               	.L14:
 348 013e F0E0      	.LM33:
 349 0140 EF71      		ldi r30,lo8(193)
 350 0142 F070      		ldi r31,hi8(193)
 351 0144 E050      		ld r24,Z
 352 0146 F040      		andi r24,lo8(-33)
 353 0148 8081      		st Z,r24
 354 014a 8093 C600 	.L16:
 236:ir_heat.c     **** 		t_out++;	
 355               	e start */
 357 014e 8091 0000 	.LM34:
 358 0152 8F5F      		pop r31
 359 0154 8093 0000 		pop r30
 360 0158 00C0      		pop r25
 361               		pop r24
 237:ir_heat.c     **** 	}
 238:ir_heat.c     **** 	else {
 239:ir_heat.c     **** 		UCSR0B &= ~(1<<UDRIE0);
 362               	
 363               		out __SREG__,r0
 364 015a E1EC      		pop r0
 365 015c F0E0      		pop __zero_reg__
 366 015e 8081      		reti
 368 0162 8083      	.Lscope5:
 370               	.global	tbuflen
 240:ir_heat.c     **** 	}
 241:ir_heat.c     **** }
 371               	buflen, @function
 372               	tbuflen:
 374 0166 EF91      	.LM35:
 375 0168 9F91      	.LFBB6:
 376 016a 8F91      	/* prologue: function */
 377 016c 0F90      	/* frame size = 0 */
 379 0170 0F90      	.LM36:
 380 0172 1F90      		lds r24,t_in
 381 0174 1895      		lds r25,t_out
 383               	.LM37:
 384               		sub r24,r25
 385               	/* epilogue start */
 386               		ret
 242:ir_heat.c     **** 
 243:ir_heat.c     **** char tbuflen(void) {
 388               		"UART_putchar:F(0,1)",36,0,0,UART_putchar
 391               	.global	UART_putchar
 244:ir_heat.c     **** //****************
 245:ir_heat.c     **** // Retrieve pending chars in TX buffer
 246:ir_heat.c     **** //
 247:ir_heat.c     **** 	return(t_in - t_out);
 393               	putchar:
 395 0176 8091 0000 	.LM38:
 396 017a 9091 0000 	.LFBB7:
 248:ir_heat.c     **** }
 397               	h r17
 398               		push r28
 399 017e 891B      		push r29
 400               	/* prologue: function */
 401 0180 0895      	/* frame size = 0 */
 402               		mov r17,r24
 404               	.LM39:
 405               		ldi r28,lo8(32)
 406               		ldi r29,hi8(32)
 407               	.L20:
 408               		call tbuflen
 409               		movw r18,r28
 249:ir_heat.c     **** 
 250:ir_heat.c     **** int UART_putchar(char c, FILE *stream) {
 410               		sbc r19,__zero_reg__
 411               		cpi r18,3
 412               		cpc r19,__zero_reg__
 413 0182 1F93      		brlt .L20
 415 0186 DF93      	.LM40:
 416               		lds r30,t_in
 417               		ldi r31,lo8(0)
 418 0188 182F      		andi r30,lo8(31)
 251:ir_heat.c     **** //*********************
 252:ir_heat.c     **** // Fills the transmit buffer, if it is full wait
 253:ir_heat.c     **** //
 254:ir_heat.c     **** 	while((TBUFSIZE - tbuflen()) <= 2);  // Wait...
 419               	,hi8(31)
 420               		subi r30,lo8(-(tbuf))
 421 018a C0E2      		sbci r31,hi8(-(tbuf))
 422 018c D0E0      		st Z,r17
 424 018e 0E94 0000 	.LM41:
 425 0192 9E01      		lds r24,t_in
 426 0194 281B      		subi r24,lo8(-(1))
 427 0196 3109      		sts t_in,r24
 429 019a 3105      	.LM42:
 430 019c 04F0      		ldi r30,lo8(193)
 255:ir_heat.c     **** 	
 256:ir_heat.c     **** 	// Add data to the transmit buffer, enable TXCIE
 257:ir_heat.c     **** 	//
 258:ir_heat.c     **** 	tbuf[t_in & TMASK] = c;
 431               	(193)
 432               		ld r24,Z
 433 019e E091 0000 		ori r24,lo8(32)
 434 01a2 F0E0      		st Z,r24
 436 01a6 F070      	.LM43:
 437 01a8 E050      		ldi r24,lo8(0)
 438 01aa F040      		ldi r25,hi8(0)
 439 01ac 1083      	/* epilogue start */
 259:ir_heat.c     **** 	t_in++;	
 440               		pop r28
 441               		pop r17
 442 01ae 8091 0000 		ret
 444 01b4 8093 0000 	.Lscope7:
 260:ir_heat.c     **** 	UCSR0B |= (1<<UDRIE0);			// Enable UDR empty interrupt	
 445               	bs	"rbuflen:F(0,2)",36,0,0,rbuflen
 446               	.global	rbuflen
 448 01ba F0E0      	rbuflen:
 450 01be 8062      	.LM44:
 451 01c0 8083      	.LFBB8:
 261:ir_heat.c     **** 	return(0);
 262:ir_heat.c     **** }
 452               	ogue: function */
 453               	/* frame size = 0 */
 455 01c4 90E0      	.LM45:
 456               		lds r24,r_in
 457 01c6 DF91      		lds r25,r_out
 459 01ca 1F91      	.LM46:
 460 01cc 0895      		sub r24,r25
 461               	/* epilogue start */
 462               		ret
 464               	.Lscope8:
 263:ir_heat.c     **** 
 264:ir_heat.c     **** char rbuflen(void) {
 467               	tchar
 469               	UART_getchar:
 471               	.LM47:
 265:ir_heat.c     **** // ***************
 266:ir_heat.c     **** // Retrive pending chars in RX buffer
 267:ir_heat.c     **** //
 268:ir_heat.c     **** 	return(r_in - r_out);
 472               	9:
 473               	/* prologue: function */
 474 01ce 8091 0000 	/* frame size = 0 */
 475 01d2 9091 0000 	.L26:
 269:ir_heat.c     **** }
 476               	abn	68,0,277,.LM48-.LFBB9
 477               	.LM48:
 478 01d6 891B      		call rbuflen
 479               		tst r24
 480 01d8 0895      		breq .L26
 482               	.LM49:
 483               		lds r30,r_out
 484               		ldi r31,lo8(0)
 485               		andi r30,lo8(31)
 486               		andi r31,hi8(31)
 487               		subi r30,lo8(-(rbuf))
 270:ir_heat.c     **** 
 271:ir_heat.c     **** int UART_getchar(FILE *stream) {
 488               	8(-(rbuf))
 489               		ld r24,Z
 491               	.LM50:
 492               		lds r25,r_out
 493               		subi r25,lo8(-(1))
 272:ir_heat.c     **** //*******************
 273:ir_heat.c     **** // Retieves character from UART. This function is to be passed
 274:ir_heat.c     **** // to fdevopen
 275:ir_heat.c     **** //
 276:ir_heat.c     **** 	unsigned char c;
 277:ir_heat.c     **** 	while(rbuflen() == 0);	  // Wait...
 494               	_out,r25
 496 01da 0E94 0000 	.LM51:
 497 01de 8823      		ldi r25,lo8(0)
 498 01e0 01F0      	/* epilogue start */
 278:ir_heat.c     **** 	c = rbuf[r_out & RMASK];
 503 01e8 EF71      	.Lscope9:
 505 01ec E050      	.global	add_value
 507 01f0 8081      	add_value:
 279:ir_heat.c     **** 	r_out++;	
 508               	8,0,321,.LM52-.LFBB10
 509               	.LM52:
 510 01f2 9091 0000 	.LFBB10:
 511 01f6 9F5F      	/* prologue: function */
 512 01f8 9093 0000 	/* frame size = 0 */
 280:ir_heat.c     **** 	return(c);
 281:ir_heat.c     **** }
 513               	r20,r24
 514               		mov r21,r25
 516               	.LM53:
 517 01fe 0895      		lds r24,t_array
 518               		lds r25,(t_array)+1
 519               		or r24,r25
 520               		brne .L30
 522               	.LM54:
 523               		ldi r30,lo8(t_array+10)
 524               		ldi r31,hi8(t_array+10)
 525               		st Z,r20
 526               		std Z+1,r21
 282:ir_heat.c     **** 
 283:ir_heat.c     **** void UART_first_init(void) {
 284:ir_heat.c     **** //***********************
 285:ir_heat.c     **** // The function fdevopen(..) must contain as parameters the
 286:ir_heat.c     **** // corresponding  ..putchar() and  ..getchar() functions, defined before.
 287:ir_heat.c     **** //
 288:ir_heat.c     **** 	UBRR0 = 12;										 		// 4800 BPS
 289:ir_heat.c     **** 	
 290:ir_heat.c     **** 	UCSR0B = (1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0);	// 8 Databits, receive and transmit enabled, receive a
 291:ir_heat.c     **** 	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
 292:ir_heat.c     **** 	
 293:ir_heat.c     **** 	fdevopen(UART_putchar, UART_getchar);
 294:ir_heat.c     **** 	sei();											 		// Global interrupt enable
 295:ir_heat.c     **** }
 296:ir_heat.c     **** 
 297:ir_heat.c     **** 
 298:ir_heat.c     **** 
 299:ir_heat.c     **** //*********************************************
 300:ir_heat.c     **** //
 301:ir_heat.c     **** // Gibt den Temperatur Ringspeicher
 302:ir_heat.c     **** // über den UART aus
 303:ir_heat.c     **** //
 304:ir_heat.c     **** void print_array(){
 305:ir_heat.c     **** 	uint8_t i;
 306:ir_heat.c     ****   	printf("Array:");
 307:ir_heat.c     **** 	for(i=0;i<6;i++) {
 308:ir_heat.c     ****    	printf(" %i", t_array[i]);
 309:ir_heat.c     **** 	}
 310:ir_heat.c     ****   	printf("\n");
 311:ir_heat.c     **** }
 312:ir_heat.c     **** 
 313:ir_heat.c     **** 
 314:ir_heat.c     **** 
 315:ir_heat.c     **** //*********************************************
 316:ir_heat.c     **** //
 317:ir_heat.c     **** // Fügt einen Meßwert zum Ringspeicher hinzu
 318:ir_heat.c     **** // Der Ringspeicher enthält die letzten 6 Werte
 319:ir_heat.c     **** // t_array[5] ist der neuste Wert
 320:ir_heat.c     **** //
 321:ir_heat.c     **** void add_value(uint16_t value) {
 527               		sbiw r26,2
 528               		st X,r20
 529               		adiw r26,1
 530               		st X,r21
 531               		movw r26,r30
 532 0200 482F      		sbiw r26,4
 533 0202 592F      		st X,r20
 322:ir_heat.c     **** 	uint8_t i;
 323:ir_heat.c     **** 	if(t_array[0]==0) {
 534               	26,1
 535               		st X,r21
 536 0204 8091 0000 		movw r26,r30
 537 0208 9091 0000 		sbiw r26,6
 538 020c 892B      		st X,r20
 539 020e 01F4      		adiw r26,1
 324:ir_heat.c     **** 		t_array[0]=t_array[1]=t_array[2]=t_array[3]=t_array[4]=t_array[5]=value;
 540               	r21
 541               		movw r26,r30
 542 0210 E0E0      		sbiw r26,8
 543 0212 F0E0      		st X,r20
 544 0214 4083      		adiw r26,1
 545 0216 5183      		st X,r21
 546 0218 DF01      		sbiw r30,10
 547 021a 1297      		st Z,r20
 548 021c 4C93      		std Z+1,r21
 549 021e 1196      		ret
 550 0220 5C93      	.L30:
 551 0222 DF01      		ldi r30,lo8(t_array)
 552 0224 1497      		ldi r31,hi8(t_array)
 554 0228 1196      	.LM55:
 555 022a 5C93      		ldi r18,lo8(t_array+10)
 556 022c DF01      		ldi r19,hi8(t_array+10)
 557 022e 1697      	.L32:
 559 0232 1196      	.LM56:
 560 0234 5C93      		ldd r24,Z+2
 561 0236 DF01      		ldd r25,Z+3
 562 0238 1897      		st Z+,r24
 563 023a 4C93      		st Z+,r25
 565 023e 5C93      	.LM57:
 566 0240 3A97      		cp r30,r18
 567 0242 4083      		cpc r31,r19
 568 0244 5183      		brne .L32
 570               	.LM58:
 571 0248 E0E0      		mov r18,r20
 572 024a F0E0      		mov r19,r21
 325:ir_heat.c     **** 	}
 326:ir_heat.c     **** 	else {
 327:ir_heat.c     **** 		for(i=0;i<5;i++) {
 573               	ray+10,r18
 575 024c 20E0      	.LM59:
 576 024e 30E0      		lds r24,t_array+8
 577               		lds r25,(t_array+8)+1
 328:ir_heat.c     **** 			t_array[i]=t_array[i+1];
 578               	r18,r24
 579               		sbc r19,r25
 580 0250 8281      		movw r24,r18
 581 0252 9381      		lsl r24
 582 0254 8193      		rol r25
 583 0256 9193      		lsl r18
 584               		rol r19
 585               		lsl r18
 586 0258 E217      		rol r19
 587 025a F307      		lsl r18
 588 025c 01F4      		rol r19
 329:ir_heat.c     **** 		}
 330:ir_heat.c     **** 		t_array[5] = value;
 589               	8
 590               		adc r25,r19
 591 025e 242F      		lds r22,slope2
 592 0260 352F      		lds r23,(slope2)+1
 593 0262 3093 0000 		movw r18,r22
 594 0266 2093 0000 		lsl r18
 331:ir_heat.c     **** 		slope2 = (10*(t_array[5]-t_array[4]) + 19*slope2) / 20;
 595               	19
 596               		movw r20,r18
 597 026a 8091 0000 		lsl r20
 598 026e 9091 0000 		rol r21
 599 0272 281B      		lsl r20
 600 0274 390B      		rol r21
 601 0276 C901      		lsl r20
 602 0278 880F      		rol r21
 603 027a 991F      		add r18,r20
 604 027c 220F      		adc r19,r21
 605 027e 331F      		add r18,r22
 606 0280 220F      		adc r19,r23
 607 0282 331F      		add r24,r18
 608 0284 220F      		adc r25,r19
 609 0286 331F      		ldi r22,lo8(20)
 610 0288 820F      		ldi r23,hi8(20)
 611 028a 931F      		call __divmodhi4
 612 028c 6091 0000 		sts (slope2)+1,r23
 613 0290 7091 0000 		sts slope2,r22
 614 0294 9B01      		ret
 616 0298 331F      	.Lscope10:
 618 029c 440F      	.global	get_slope
 620 02a0 440F      	get_slope:
 622 02a4 440F      	.LM60:
 623 02a6 551F      	.LFBB11:
 624 02a8 240F      	/* prologue: function */
 625 02aa 351F      	/* frame size = 0 */
 627 02ae 371F      	.LM61:
 628 02b0 820F      		ldi r26,lo8(t_array+8)
 629 02b2 931F      		ldi r27,hi8(t_array+8)
 630 02b4 64E1      		movw r30,r26
 631 02b6 70E0      		ld r18,Z+
 632 02b8 0E94 0000 		ld r19,Z+
 633 02bc 7093 0000 		lds r24,t_array+2
 634 02c0 6093 0000 		lds r25,(t_array+2)+1
 635 02c4 0895      		sub r18,r24
 636               		sbc r19,r25
 637               		movw r24,r18
 638               		lsl r24
 639               		rol r25
 640               		lsl r24
 641               		rol r25
 332:ir_heat.c     **** 	}
 333:ir_heat.c     **** }
 334:ir_heat.c     **** 
 335:ir_heat.c     **** 
 336:ir_heat.c     **** 
 337:ir_heat.c     **** //********************************************
 338:ir_heat.c     **** //
 339:ir_heat.c     **** // Gibt die gemittelte Steigung
 340:ir_heat.c     **** // über die letzten 4 Sekunden zurück
 341:ir_heat.c     **** //
 342:ir_heat.c     **** int16_t get_slope() {
 642               	
 643               		ldd r21,Z+1
 644               		ld r18,X+
 645               		ld r19,X
 646               		sbiw r26,1
 647               		sub r20,r18
 648               		sbc r21,r19
 649 02c6 A0E0      		movw r18,r20
 650 02c8 B0E0      		lsl r18
 651 02ca FD01      		rol r19
 652 02cc 2191      		add r18,r20
 653 02ce 3191      		adc r19,r21
 654 02d0 8091 0000 		add r24,r18
 655 02d4 9091 0000 		adc r25,r19
 656 02d8 281B      		adiw r26,6
 657 02da 390B      		ld r20,X+
 658 02dc C901      		ld r21,X
 659 02de 880F      		sbiw r26,6+1
 660 02e0 991F      		adiw r26,4
 661 02e2 880F      		ld r18,X+
 662 02e4 991F      		ld r19,X
 663 02e6 820F      		sbiw r26,4+1
 664 02e8 931F      		sub r20,r18
 665 02ea 1897      		sbc r21,r19
 666 02ec 4081      		movw r18,r20
 667 02ee 5181      		lsl r18
 668 02f0 2D91      		rol r19
 669 02f2 3C91      		add r18,r20
 670 02f4 1197      		adc r19,r21
 671 02f6 421B      		movw r20,r18
 672 02f8 530B      		lsl r20
 673 02fa 9A01      		rol r21
 674 02fc 220F      		lsl r20
 675 02fe 331F      		rol r21
 676 0300 240F      		add r18,r20
 677 0302 351F      		adc r19,r21
 678 0304 820F      		add r24,r18
 679 0306 931F      		adc r25,r19
 680 0308 1696      		ldi r22,lo8(9)
 681 030a 4D91      		ldi r23,hi8(9)
 682 030c 5C91      		call __divmodhi4
 683 030e 1797      		mov r24,r22
 684 0310 1496      		mov r25,r23
 685 0312 2D91      	/* epilogue start */
 687 0316 1597      	.LM62:
 688 0318 421B      		ret
 690 031c 9A01      	.Lscope11:
 692 0320 331F      	.global	get_last_slope
 694 0324 351F      	get_last_slope:
 696 0328 440F      	.LM63:
 697 032a 551F      	.LFBB12:
 698 032c 440F      	/* prologue: function */
 699 032e 551F      	/* frame size = 0 */
 701 0332 351F      	.LM64:
 702 0334 820F      		lds r18,t_array+10
 703 0336 931F      		lds r19,(t_array+10)+1
 704 0338 69E0      		lds r24,t_array+8
 705 033a 70E0      		lds r25,(t_array+8)+1
 706 033c 0E94 0000 		sub r18,r24
 707 0340 862F      		sbc r19,r25
 709               	.LM65:
 343:ir_heat.c     **** 	int16_t s1, s2, s3;
 344:ir_heat.c     **** 
 345:ir_heat.c     **** 	s1 = t_array[5] - t_array[0];
 346:ir_heat.c     **** 	s2 = t_array[4] - t_array[1];
 347:ir_heat.c     **** 	s3 = t_array[3] - t_array[2];
 348:ir_heat.c     **** 	
 349:ir_heat.c     **** 	return ((3*s1+5*s2+15*s3)/9);
 350:ir_heat.c     **** }
 710               	_slope, .-get_last_slope
 711               	.Lscope12:
 714               	.global	_beep
 716               	_beep:
 718               	.LM66:
 351:ir_heat.c     **** 
 352:ir_heat.c     **** 
 353:ir_heat.c     **** 
 354:ir_heat.c     **** //********************************************
 355:ir_heat.c     **** //
 356:ir_heat.c     **** // Gibt die aktuelle Steigung der Temperatur zurück
 357:ir_heat.c     **** // in 0.1°C in 4s
 358:ir_heat.c     **** //
 359:ir_heat.c     **** int16_t	get_last_slope() {
 719               	/* prologue: function */
 720               	/* frame size = 0 */
 722               	.LM67:
 723               		ldi r30,lo8(37)
 724               		ldi r31,hi8(37)
 725               		ld r18,Z
 726 0346 2091 0000 		ori r18,lo8(-128)
 727 034a 3091 0000 		st Z,r18
 729 0352 9091 0000 	.LM68:
 730 0356 281B      		ldi r22,lo8(20)
 731 0358 390B      		ldi r23,hi8(20)
 360:ir_heat.c     ****     return (t_array[5] - t_array[4]);
 361:ir_heat.c     **** }
 732               	odhi4
 733               		mov r24,r22
 734 035a 822F      		mov r25,r23
 735 035c 932F      		sbiw r24,0
 736               		breq .L40
 737 035e 0895      		ldi r18,lo8(0)
 738               		ldi r19,hi8(0)
 739               	.LBB36:
 740               	.LBB37:
 741               	.LBB38:
 742               	.LBB39:
 744               	.Ltext1:
 362:ir_heat.c     **** 
 363:ir_heat.c     **** 
 364:ir_heat.c     **** 
 365:ir_heat.c     **** //********************************************
 366:ir_heat.c     **** //
 367:ir_heat.c     **** // Liest die vom MLX90614 gemessene Temperatur aus
 368:ir_heat.c     **** // Rückgabe in 0.1°C, also 215 = 21.5°C
 369:ir_heat.c     **** //
 370:ir_heat.c     **** uint16_t get_temperature(uint8_t adr) {
 371:ir_heat.c     **** 	uint16_t raw;
 372:ir_heat.c     **** 	uint8_t 	ret;
 373:ir_heat.c     **** 	uint8_t 	lo, hi, pec;
 374:ir_heat.c     **** 	uint8_t	pec_read[6];
 375:ir_heat.c     **** 
 376:ir_heat.c     **** 	i2c_start(MLX90614_WRITE);
 377:ir_heat.c     **** 	i2c_write(adr);
 378:ir_heat.c     **** 	
 379:ir_heat.c     **** 	ret = i2c_rep_start(MLX90614_READ);
 380:ir_heat.c     **** 	if(ret) {
 381:ir_heat.c     **** 		i2c_rep_start(MLX90614_READ);
 382:ir_heat.c     ****    }
 383:ir_heat.c     **** 
 384:ir_heat.c     **** 	lo = i2c_read_ack();
 385:ir_heat.c     **** 	hi = i2c_read_ack();
 386:ir_heat.c     **** 	raw = (uint16_t)(hi<<8)+lo;
 387:ir_heat.c     **** 	pec = i2c_read_ack();
 388:ir_heat.c     **** 	
 389:ir_heat.c     **** 	i2c_stop();
 390:ir_heat.c     **** 	
 391:ir_heat.c     **** 	if(raw & 0x8000) return 0;
 392:ir_heat.c     **** 	
 393:ir_heat.c     **** 	return (raw / 5 - 2731); 					// 1 = 0.1°C
 394:ir_heat.c     **** }
 395:ir_heat.c     **** 
 396:ir_heat.c     **** 
 397:ir_heat.c     **** 
 398:ir_heat.c     **** void _beep(uint16_t duration_ms){
 745               	105,.LM69-.LFBB13
 746               	.LM69:
 747               		ldi r20,lo8(5000)
 748               		ldi r21,hi8(5000)
 749               	.L41:
 399:ir_heat.c     **** 	uint16_t i;
 400:ir_heat.c     **** 	BUZZER_ON;
 750               	 r30,r20
 751               	/* #APP */
 752 0360 E5E2      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 753 0362 F0E0      		1: sbiw r30,1
 754 0364 2081      		brne 1b
 755 0366 2068      	 ;  0 "" 2
 756 0368 2083      	/* #NOAPP */
 401:ir_heat.c     **** 	for(i=0;i<(duration_ms/20);i++) _delay_ms(20);
 757               	
 758               	.LBE38:
 759 036a 64E1      	.LBE37:
 760 036c 70E0      	.LBE36:
 762 0372 862F      	.Ltext2:
 764 0376 0097      	.LM70:
 765 0378 01F0      		subi r18,lo8(-(1))
 766 037a 20E0      		sbci r19,hi8(-(1))
 767 037c 30E0      		cp r18,r24
 768               		cpc r19,r25
 769               		brlo .L41
 770               	.L40:
 772               	.LM71:
 773               		ldi r30,lo8(37)
   1:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   5:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   8:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  11:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      distribution.
  15:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  16:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  20:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  32:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  34:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  37:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  39:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \file */
  40:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \code
  42:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \endcode
  44:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  45:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  53:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  60:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  62:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  63:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  64:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #endif
  68:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  69:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  71:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     register.
  76:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  77:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     can be achieved.
  79:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  80:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
  81:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
  83:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	);
  89:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** }
  90:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  91:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  93:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     counter register pair.
  98:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  99:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****  */
 102:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
 103:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
 105:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 774               	
 775               		ld r24,Z
 776 037e 48E8      		andi r24,lo8(127)
 777 0380 53E1      		st Z,r24
 778               	/* epilogue start */
 780               	.LM72:
 781               		ret
 786               	.Lscope13:
 789               	.global	beep
 791               	beep:
 793               	.LM73:
 794 0388 2F5F      	.LFBB14:
 795 038a 3F4F      	/* prologue: function */
 796 038c 2817      	/* frame size = 0 */
 798 0390 00F0      	.LM74:
 799               	/* #APP */
 402:ir_heat.c     **** 	BUZZER_OFF;
 800               	i
 801               	 ;  0 "" 2
 803 0394 F0E0      	.LM75:
 804 0396 8081      	 ;  408 "ir_heat.c" 1
 805 0398 8F77      		wdr
 806 039a 8083      	 ;  0 "" 2
 403:ir_heat.c     **** }
 808               	* #NOAPP */
 809               		cpi r24,lo8(3)
 810 039c 0895      		breq .L48
 811               		cpi r24,lo8(4)
 812               		brsh .L51
 813               		cpi r24,lo8(1)
 814               		breq .L46
 815               		cpi r24,lo8(2)
 816               		brne .L45
 817               		rjmp .L53
 818               	.L51:
 819               		cpi r24,lo8(4)
 820               		breq .L49
 404:ir_heat.c     **** 
 405:ir_heat.c     **** 
 406:ir_heat.c     **** void	beep(uint8_t type){
 821               	6)
 822               		brne .L45
 823               		rjmp .L54
 824               	.L46:
 407:ir_heat.c     **** 	cli();
 826               	:
 827               		ldi r24,lo8(120)
 828               		ldi r25,hi8(120)
 829               		call _beep
 830 039e F894      		rjmp .L45
 831               	.L48:
 408:ir_heat.c     **** 	wdt_reset();
 832               	n	68,0,414,.LM78-.LFBB14
 833               	.LM78:
 834               		ldi r24,lo8(350)
 835 03a0 A895      		ldi r25,hi8(350)
 836               		call _beep
 409:ir_heat.c     **** 	switch(type){
 837               	 .L45
 838               	.L49:
 840 03a2 8330      	.LM79:
 841 03a4 01F0      		ldi r24,lo8(850)
 842 03a6 8430      		ldi r25,hi8(850)
 843 03a8 00F4      		call _beep
 844 03aa 8130      		rjmp .L45
 845 03ac 01F0      	.L53:
 847 03b0 01F4      	.LM80:
 848 03b2 00C0      		ldi r24,lo8(80)
 849               		ldi r25,hi8(80)
 850 03b4 8430      		call _beep
 851 03b6 01F0      	.LBB40:
 852 03b8 8630      	.LBB41:
 853 03ba 01F4      	.LBB42:
 854 03bc 00C0      	.LBB43:
 410:ir_heat.c     **** 	case BEEP_SHORT:
 411:ir_heat.c     **** 		_beep(120);
 856               	,0,105,.LM81-.LFBB14
 857               	.LM81:
 858 03be 88E7      		ldi r24,lo8(20000)
 859 03c0 90E0      		ldi r25,hi8(20000)
 860 03c2 0E94 0000 	/* #APP */
 861 03c6 00C0      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 862               		1: sbiw r24,1
 412:ir_heat.c     **** 		break;
 413:ir_heat.c     **** 	case BEEP_LONG:
 414:ir_heat.c     **** 		_beep(350);
 863               	b
 864               	 ;  0 "" 2
 865 03c8 8EE5      	/* #NOAPP */
 866 03ca 91E0      	.LBE43:
 867 03cc 0E94 0000 	.LBE42:
 868 03d0 00C0      	.LBE41:
 869               	.LBE40:
 415:ir_heat.c     **** 		break;
 416:ir_heat.c     **** 	case BEEP_XLONG:
 417:ir_heat.c     **** 		_beep(850);
 870               		"ir_heat.c",132,0,0,.Ltext4
 871               	.Ltext4:
 873 03d4 93E0      	.LM82:
 874 03d6 0E94 0000 		ldi r24,lo8(80)
 875 03da 00C0      		ldi r25,hi8(80)
 876               		call _beep
 418:ir_heat.c     **** 		break;
 419:ir_heat.c     **** 	case BEEP_2SHORT:
 420:ir_heat.c     **** 		_beep(80);
 877               	L45
 878               	.L54:
 880 03de 90E0      	.LM83:
 881 03e0 0E94 0000 		ldi r24,lo8(100)
 882               		ldi r25,hi8(100)
 883               		call _beep
 884               	.LBB44:
 885               	.LBB45:
 886               	.LBB46:
 887               	.LBB47:
 889               	.Ltext5:
 891 03e6 9EE4      	.LM84:
 892               		ldi r24,lo8(-20536)
 893               		ldi r25,hi8(-20536)
 894 03e8 0197      	/* #APP */
 895 03ea 01F4      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 896               		1: sbiw r24,1
 897               		brne 1b
 898               	 ;  0 "" 2
 899               	/* #NOAPP */
 900               	.LBE47:
 901               	.LBE46:
 902               	.LBE45:
 903               	.LBE44:
 421:ir_heat.c     **** 		_delay_ms(80);
 422:ir_heat.c     **** 		_beep(80);
 904               	,.Ltext6
 905               	.Ltext6:
 907 03ee 90E0      	.LM85:
 908 03f0 0E94 0000 		ldi r24,lo8(350)
 909 03f4 00C0      		ldi r25,hi8(350)
 910               		call _beep
 423:ir_heat.c     **** 		break;
 424:ir_heat.c     **** 	case BEEP_SHORT_LONG:
 425:ir_heat.c     **** 		_beep(100);
 912               	.LM86:
 913 03f6 84E6      	/* #APP */
 914 03f8 90E0      	 ;  429 "ir_heat.c" 1
 915 03fa 0E94 0000 		sei
 916               	 ;  0 "" 2
 917               	/* epilogue start */
 919               	.LM87:
 920               	/* #NOAPP */
 921               		ret
 923               	.Lscope14:
 924 03fe 88EC      		.data
 925 0400 9FEA      	.LC0:
 926               		.string	">>> Relais ON"
 927               	.LC1:
 928 0402 0197      		.string	">>> Relais OFF"
 929 0404 01F4      		.text
 932               	.global	set_relais
 934               	set_relais:
 936               	.LM88:
 937               	.LFBB15:
 426:ir_heat.c     **** 		_delay_ms(180);
 427:ir_heat.c     **** 		_beep(350);		
 938               	tion */
 939               	/* frame size = 0 */
 940 0406 8EE5      		mov r17,r24
 942 040a 0E94 0000 	.LM89:
 943               		tst r24
 428:ir_heat.c     **** 	}
 429:ir_heat.c     **** 	sei();	
 944               	.L56
 946               	.LM90:
 947               		lds r24,last.1976
 948 040e 7894      		cp r17,r24
 949               		breq .L57
 950               		ldi r24,lo8(.LC0)
 430:ir_heat.c     **** }
 951               	5,hi8(.LC0)
 952               		call puts
 953               	.L57:
 955               	.LM91:
 956               		ldi r30,lo8(37)
 957               		ldi r31,hi8(37)
 958               		ld r24,Z
 959 0000 3E3E 3E20 		ori r24,lo8(64)
 959      5265 6C61 
 959      6973 204F 
 959      4E00 
 960               		st Z,r24
 961 000e 3E3E 3E20 		rjmp .L58
 961      5265 6C61 
 961      6973 204F 
 961      4646 00
 962               	.L56:
 964               	.LM92:
 965               		lds r24,last.1976
 966               		tst r24
 967               		breq .L59
 431:ir_heat.c     **** 
 432:ir_heat.c     **** 
 433:ir_heat.c     **** 
 434:ir_heat.c     **** //***************************************************
 435:ir_heat.c     **** //
 436:ir_heat.c     **** // Relais Ein- und Ausschalen
 437:ir_heat.c     **** //
 438:ir_heat.c     **** void set_relais(uint8_t on) {
 968               	)
 969               		ldi r25,hi8(.LC1)
 970               		call puts
 971 0412 1F93      	.L59:
 973               	.LM93:
 974 0414 182F      		ldi r30,lo8(37)
 439:ir_heat.c     **** 	static uint8_t last = 0;
 440:ir_heat.c     **** 	if(on) {
 975               	1,hi8(37)
 976               		ld r24,Z
 977 0416 8823      		andi r24,lo8(-65)
 978 0418 01F0      		st Z,r24
 441:ir_heat.c     **** 		if(on != last) printf(">>> Relais ON\n");
 979               	:
 981 041a 8091 0000 	.LM94:
 982 041e 1817      		sts last.1976,r17
 983 0420 01F0      	/* epilogue start */
 985 0424 90E0      	.LM95:
 986 0426 0E94 0000 		pop r17
 987               		ret
 442:ir_heat.c     **** 		RELAIS_ON;
 988               	t_relais, .-set_relais
 992 042e 8081      	.Lscope15:
 993 0430 8064      		.data
 994 0432 8083      	.LC2:
 995 0434 00C0      		.string	"Temperature Protection Off!"
 996               	.LC3:
 443:ir_heat.c     **** 	}
 444:ir_heat.c     **** 	else {
 445:ir_heat.c     **** 		if(on != last) printf(">>> Relais OFF\n");
 997               	"\nxXx"
 998               		.text
 1000 043a 8823      	.global	__vector_1
 1002 043e 80E0      	__vector_1:
 1004 0442 0E94 0000 	.LM96:
 1005               	.LFBB16:
 446:ir_heat.c     **** 		RELAIS_OFF;
 1006               	ero_reg__
 1007               		push r0
 1008 0446 E5E2      		in r0,__SREG__
 1009 0448 F0E0      		push r0
 1010 044a 8081      		clr __zero_reg__
 1011 044c 8F7B      		push r18
 1012 044e 8083      		push r19
 1013               		push r20
 447:ir_heat.c     **** 	}
 448:ir_heat.c     **** 	last = on;
 1014               	1
 1015               		push r22
 1016 0450 1093 0000 		push r23
 1017               		push r24
 449:ir_heat.c     **** }
 1018               	h r25
 1019               		push r26
 1020 0454 1F91      		push r27
 1021 0456 0895      		push r30
 1022               		push r31
 1023               	/* prologue: Signal */
 1024               	/* frame size = 0 */
 1026               	.LM97:
 1027               		lds r24,133
 1028               		lds r18,132
 1029 001d 5465 6D70 		lds r25,running.1753
 1029      6572 6174 
 1029      7572 6520 
 1029      5072 6F74 
 1029      6563 7469 
 1030               		or r24,r25
 1031 0039 0A78 5878 		or r24,r18
 1031      00
 1032               		breq .+2
 1033               		rjmp .L72
 1035               	.LM98:
 1036               		ldi r24,lo8(1)
 1037               		sts running.1753,r24
 1039               	.LM99:
 1040 0458 1F92      	/* #APP */
 1041 045a 0F92      	 ;  163 "ir_heat.c" 1
 1042 045c 0FB6      		wdr
 1043 045e 0F92      	 ;  0 "" 2
 1045 0462 2F93      	.LM100:
 1046 0464 3F93      	/* #NOAPP */
 1047 0466 4F93      		out 61-32,__zero_reg__
 1049 046a 6F93      	.LM101:
 1050 046c 7F93      	/* #APP */
 1051 046e 8F93      	 ;  168 "ir_heat.c" 1
 1052 0470 9F93      		sei
 1053 0472 AF93      	 ;  0 "" 2
 1054 0474 BF93      	/* #NOAPP */
 1055 0476 EF93      		ldi r18,lo8(0)
 1056 0478 FF93      		ldi r19,hi8(0)
 1057               		ldi r20,lo8(0)
 1058               		ldi r21,hi8(0)
 1060               	.LM102:
 1061 047a 8091 8500 		ldi r30,lo8(41)
 1062 047e 2091 8400 		ldi r31,hi8(41)
 1063 0482 9091 0000 	.L64:
 1064 0486 892B      		ld r24,Z
 1065 0488 822B      		sbrs r24,2
 1066 048a 01F0      		rjmp .L63
 1067 048c 00C0      		subi r20,lo8(-(1))
 1068               		sbci r21,hi8(-(1))
 1069               	.L63:
 1070 048e 81E0      		subi r18,lo8(-(1))
 1071 0490 8093 0000 		sbci r19,hi8(-(1))
 1072               		ldi r24,hi8(1000)
 1073               		cpi r18,lo8(1000)
 1074               		cpc r19,r24
 1075               		brne .L64
 1077               	.LM103:
 1078               		cpi r20,200
 1079               		cpc r21,__zero_reg__
 1080               		brlo .+2
 1081 0496 1DBA      		rjmp .L65
 1083               	.LM104:
 1084               		ldi r24,lo8(1)
 1085               		sts 132,r24
 1087               	.LM105:
 1088               		ldi r24,lo8(2)
 1089 049a 20E0      		sts 129,r24
 1091 049e 40E0      	.LM106:
 1092 04a0 50E0      		lds r24,mode
 1093               		tst r24
 1094               		breq .+2
 1095 04a2 E9E2      		rjmp .L75
 1097               	.LM107:
 1098 04a6 8081      		ldi r24,lo8(1)
 1099 04a8 82FF      		sts mode,r24
 1101 04ac 4F5F      	.LM108:
 1102 04ae 5F4F      		call set_relais
 1104 04b0 2F5F      	.LM109:
 1105 04b2 3F4F      		ldi r30,lo8(43)
 1106 04b4 83E0      		ldi r31,hi8(43)
 1107 04b6 283E      		ld r24,Z
 1108 04b8 3807      		ori r24,lo8(16)
 1109 04ba 01F4      		st Z,r24
 1111               	.LM110:
 1112 04bc 483C      		ld r24,Z
 1113 04be 5105      		ori r24,lo8(8)
 1114 04c0 00F0      		st Z,r24
 1116               	.LM111:
 1117               		sbic 41-32,2
 1118 04c4 81E0      		rjmp .L68
 1119 04c6 8093 8400 		ldi r18,lo8(0)
 1120               		ldi r19,hi8(0)
 1121               	.LBB48:
 1122 04ca 82E0      	.LBB49:
 1123 04cc 8093 8100 	.LBB50:
 1124               	.LBB51:
 1126 04d0 8091 0000 	.Ltext7:
 1128 04d6 01F0      	.LM112:
 1129 04d8 00C0      		ldi r20,lo8(2500)
 1130               		ldi r21,hi8(2500)
 1131               	.LBE51:
 1132 04da 81E0      	.LBE50:
 1133 04dc 8093 0000 	.LBE49:
 1134               	.LBE48:
 1136 04e0 0E94 0000 	.Ltext8:
 1138               	.LM113:
 1139 04e4 EBE2      		ldi r30,lo8(41)
 1140 04e6 F0E0      		ldi r31,hi8(41)
 1141 04e8 8081      	.L70:
 1143 04ec 8083      	.LM114:
 1144               		subi r18,lo8(-(1))
 1145               		sbci r19,hi8(-(1))
 1146 04ee 8081      	.LBB55:
 1147 04f0 8860      	.LBB54:
 1148 04f2 8083      	.LBB53:
 1149               	.LBB52:
 1151 04f4 4A99      	.Ltext9:
 1153 04f8 20E0      	.LM115:
 1154 04fa 30E0      		movw r24,r20
 1155               	/* #APP */
 1156               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1157               		1: sbiw r24,1
 1158               		brne 1b
 1159               	 ;  0 "" 2
 1160               	/* #NOAPP */
 1161               	.LBE52:
 1162               	.LBE53:
 1163 04fc 44EC      	.LBE54:
 1164 04fe 59E0      	.LBE55:
 1166               	.Ltext10:
 1168               	.LM116:
 1169               		ld r24,Z
 1170               		sbrc r24,2
 1171               		rjmp .L69
 1172               		ldi r24,hi8(300)
 1173 0500 E9E2      		cpi r18,lo8(300)
 1174 0502 F0E0      		cpc r19,r24
 1175               		brne .L70
 1176               		rjmp .L71
 1177               	.L69:
 1179 0506 3F4F      	.LM117:
 1180               		subi r18,lo8(300)
 1181               		sbci r19,hi8(300)
 1182               		brsh .L71
 1183               	.L68:
 1185               	.LM118:
 1186               		ldi r24,lo8(1)
 1187               		sts mode,r24
 1188 0508 CA01      		rjmp .L65
 1189               	.L71:
 1191 050a 0197      	.LM119:
 1192 050c 01F4      		ldi r24,lo8(2)
 1193               		sts mode,r24
 1195               	.LM120:
 1196               		ldi r24,lo8(.LC2)
 1197               		ldi r25,hi8(.LC2)
 1198               		call puts
 1200               	.LM121:
 1201               		ldi r30,lo8(43)
 1202               		ldi r31,hi8(43)
 1203 050e 8081      		ld r24,Z
 1204 0510 82FD      		andi r24,lo8(-17)
 1205 0512 00C0      		st Z,r24
 1207 0516 2C32      	.LM122:
 1208 0518 3807      		ld r24,Z
 1209 051a 01F4      		ori r24,lo8(8)
 1210 051c 00C0      		st Z,r24
 1212               	.LM123:
 1213               		ldi r24,lo8(6)
 1214 051e 2C52      		call beep
 1215 0520 3140      		rjmp .L65
 1216 0522 00F4      	.L75:
 1218               	.LM124:
 1219               		ldi r24,lo8(.LC3)
 1220 0524 81E0      		ldi r25,hi8(.LC3)
 1221 0526 8093 0000 		call puts
 1223               	.LM125:
 1224               		sts mode,__zero_reg__
 1225               	.L65:
 1227 052e 8093 0000 	.LM126:
 1228               		ldi r24,lo8(1)
 1229               		out 60-32,r24
 1231 0534 90E0      	.LM127:
 1232 0536 0E94 0000 		out 61-32,r24
 1234               	.LM128:
 1235 053a EBE2      		sts running.1753,__zero_reg__
 1236 053c F0E0      	.L72:
 1237 053e 8081      	/* epilogue start */
 1239 0542 8083      	.LM129:
 1240               		pop r31
 1241               		pop r30
 1242 0544 8081      		pop r27
 1243 0546 8860      		pop r26
 1244 0548 8083      		pop r25
 1245               		pop r24
 1246               		pop r23
 1247 054a 86E0      		pop r22
 1248 054c 0E94 0000 		pop r21
 1249 0550 00C0      		pop r20
 1250               		pop r19
 1251               		pop r18
 1252               		pop r0
 1253 0552 80E0      		out __SREG__,r0
 1254 0554 90E0      		pop r0
 1255 0556 0E94 0000 		pop __zero_reg__
 1256               		reti
 1263 0560 8CBB      	.Lscope16:
 1266 0562 8DBB      	.global	get_temperature
 1268               	get_temperature:
 1270               	.LM130:
 1271               	.LFBB17:
 1272               		push r17
 1273               		push r28
 1274 0568 FF91      		push r29
 1275 056a EF91      	/* prologue: function */
 1276 056c BF91      	/* frame size = 0 */
 1277 056e AF91      		mov r17,r24
 1279 0572 8F91      	.LM131:
 1280 0574 7F91      		ldi r24,lo8(-76)
 1281 0576 6F91      		call i2c_start
 1283 057a 4F91      	.LM132:
 1284 057c 3F91      		mov r24,r17
 1285 057e 2F91      		call i2c_write
 1287 0582 0FBE      	.LM133:
 1288 0584 0F90      		ldi r24,lo8(-75)
 1289 0586 1F90      		call i2c_rep_start
 1291               	.LM134:
 1292               		tst r24
 1293               		breq .L77
 1295               	.LM135:
 1296               		ldi r24,lo8(-75)
 1297               		call i2c_rep_start
 1298               	.L77:
 1300               	.LM136:
 1301               		call i2c_read_ack
 1302               		mov r17,r24
 1304               	.LM137:
 1305               		call i2c_read_ack
 1307 058c CF93      	.LM138:
 1308 058e DF93      		mov r19,r24
 1309               		ldi r18,lo8(0)
 1310               		movw r28,r18
 1311 0590 182F      		add r28,r17
 1312               		adc r29,__zero_reg__
 1314 0592 84EB      	.LM139:
 1315 0594 0E94 0000 		call i2c_read_ack
 1317               	.LM140:
 1318 0598 812F      		call i2c_stop
 1320               	.LM141:
 1321               		tst r29
 1322 059e 85EB      		brge .L78
 1323 05a0 0E94 0000 		ldi r22,lo8(0)
 1324               		ldi r23,hi8(0)
 1325               		rjmp .L79
 1326 05a4 8823      	.L78:
 1328               	.LM142:
 1329               		movw r24,r28
 1330 05a8 85EB      		ldi r22,lo8(5)
 1331 05aa 0E94 0000 		ldi r23,hi8(5)
 1332               		call __udivmodhi4
 1333               		subi r22,lo8(-(-2731))
 1334               		sbci r23,hi8(-(-2731))
 1335 05ae 0E94 0000 	.L79:
 1337               	.LM143:
 1338               		mov r24,r22
 1339 05b4 0E94 0000 		mov r25,r23
 1340               	/* epilogue start */
 1341               		pop r29
 1342 05b8 382F      		pop r28
 1343 05ba 20E0      		pop r17
 1344 05bc E901      		ret
 1350               	.Lscope17:
 1351               		.data
 1352 05c6 0E94 0000 	.LC4:
 1353               		.string	"Array:"
 1354               	.LC5:
 1355 05ca DD23      		.string	" %i"
 1356 05cc 04F4      		.text
 1358 05d0 70E0      	.global	print_array
 1360               	print_array:
 1362               	.LM144:
 1363 05d4 CE01      	.LFBB18:
 1364 05d6 65E0      		push r12
 1365 05d8 70E0      		push r13
 1366 05da 0E94 0000 		push r14
 1367 05de 6B5A      		push r15
 1368 05e0 7A40      		push r16
 1369               		push r17
 1370               	/* prologue: function */
 1371               	/* frame size = 0 */
 1373 05e4 972F      	.LM145:
 1374               		rcall .
 1375 05e6 DF91      		ldi r24,lo8(.LC4)
 1376 05e8 CF91      		ldi r25,hi8(.LC4)
 1377 05ea 1F91      		in r26,__SP_L__
 1378 05ec 0895      		in r27,__SP_H__
 1379               		adiw r26,1+1
 1380               		st X,r25
 1381               		st -X,r24
 1382               		sbiw r26,1
 1383               		call printf
 1385               	.LM146:
 1386               		rcall .
 1387 003e 4172 7261 		in r30,__SP_L__
 1387      793A 00
 1388               		in r31,__SP_H__
 1389 0045 2025 6900 		adiw r30,1
 1390               		mov __tmp_reg__,r31
 1391               		ldi r31,lo8(.LC5)
 1392               		mov r14,r31
 1393               		ldi r31,hi8(.LC5)
 1394               		mov r15,r31
 1395               		mov r31,__tmp_reg__
 1396               		std Z+1,r15
 1397               		st Z,r14
 1398 05ee CF92      		mov __tmp_reg__,r31
 1399 05f0 DF92      		ldi r31,lo8(t_array)
 1400 05f2 EF92      		mov r12,r31
 1401 05f4 FF92      		ldi r31,hi8(t_array)
 1402 05f6 0F93      		mov r13,r31
 1403 05f8 1F93      		mov r31,__tmp_reg__
 1404               		movw r26,r12
 1405               		ld r24,X+
 1406               		ld r25,X+
 1407               		movw r16,r26
 1408 05fa 00D0      		std Z+3,r25
 1409 05fc 80E0      		std Z+2,r24
 1410 05fe 90E0      		call printf
 1411 0600 ADB7      		in r30,__SP_L__
 1412 0602 BEB7      		in r31,__SP_H__
 1413 0604 1296      		adiw r30,1
 1414 0606 9C93      		std Z+1,r15
 1415 0608 8E93      		st Z,r14
 1416 060a 1197      		movw r26,r16
 1417 060c 0E94 0000 		ld r24,X+
 1418               		ld r25,X
 1419               		std Z+3,r25
 1420 0610 00D0      		std Z+2,r24
 1421 0612 EDB7      		call printf
 1422 0614 FEB7      		in r30,__SP_L__
 1423 0616 3196      		in r31,__SP_H__
 1424 0618 0F2E      		adiw r30,1
 1425 061a F0E0      		std Z+1,r15
 1426 061c EF2E      		st Z,r14
 1427 061e F0E0      		movw r26,r12
 1428 0620 FF2E      		adiw r26,4
 1429 0622 F02D      		ld r24,X+
 1430 0624 F182      		ld r25,X
 1431 0626 E082      		sbiw r26,4+1
 1432 0628 0F2E      		std Z+3,r25
 1433 062a F0E0      		std Z+2,r24
 1434 062c CF2E      		call printf
 1435 062e F0E0      		in r30,__SP_L__
 1436 0630 DF2E      		in r31,__SP_H__
 1437 0632 F02D      		adiw r30,1
 1438 0634 D601      		std Z+1,r15
 1439 0636 8D91      		st Z,r14
 1440 0638 9D91      		movw r26,r12
 1441 063a 8D01      		adiw r26,6
 1442 063c 9383      		ld r24,X+
 1443 063e 8283      		ld r25,X
 1444 0640 0E94 0000 		sbiw r26,6+1
 1445 0644 EDB7      		std Z+3,r25
 1446 0646 FEB7      		std Z+2,r24
 1447 0648 3196      		call printf
 1448 064a F182      		in r30,__SP_L__
 1449 064c E082      		in r31,__SP_H__
 1450 064e D801      		adiw r30,1
 1451 0650 8D91      		std Z+1,r15
 1452 0652 9C91      		st Z,r14
 1453 0654 9383      		movw r26,r12
 1454 0656 8283      		adiw r26,8
 1455 0658 0E94 0000 		ld r24,X+
 1456 065c EDB7      		ld r25,X
 1457 065e FEB7      		sbiw r26,8+1
 1458 0660 3196      		std Z+3,r25
 1459 0662 F182      		std Z+2,r24
 1460 0664 E082      		call printf
 1461 0666 D601      		in r30,__SP_L__
 1462 0668 1496      		in r31,__SP_H__
 1463 066a 8D91      		adiw r30,1
 1464 066c 9C91      		std Z+1,r15
 1465 066e 1597      		st Z,r14
 1466 0670 9383      		movw r26,r12
 1467 0672 8283      		adiw r26,10
 1468 0674 0E94 0000 		ld r24,X+
 1469 0678 EDB7      		ld r25,X
 1470 067a FEB7      		sbiw r26,10+1
 1471 067c 3196      		std Z+3,r25
 1472 067e F182      		std Z+2,r24
 1473 0680 E082      		call printf
 1475 0684 1696      	.LM147:
 1476 0686 8D91      		pop __tmp_reg__
 1477 0688 9C91      		pop __tmp_reg__
 1478 068a 1797      		pop __tmp_reg__
 1479 068c 9383      		pop __tmp_reg__
 1480 068e 8283      		ldi r24,lo8(10)
 1481 0690 0E94 0000 		ldi r25,hi8(10)
 1482 0694 EDB7      		call putchar
 1483 0696 FEB7      	/* epilogue start */
 1485 069a F182      	.LM148:
 1486 069c E082      		pop r17
 1487 069e D601      		pop r16
 1488 06a0 1896      		pop r15
 1489 06a2 8D91      		pop r14
 1490 06a4 9C91      		pop r13
 1491 06a6 1997      		pop r12
 1492 06a8 9383      		ret
 1494 06ac 0E94 0000 	.Lscope18:
 1496 06b2 FEB7      	.global	UART_first_init
 1498 06b6 F182      	UART_first_init:
 1500 06ba D601      	.LM149:
 1501 06bc 1A96      	.LFBB19:
 1502 06be 8D91      	/* prologue: function */
 1503 06c0 9C91      	/* frame size = 0 */
 1505 06c4 9383      	.LM150:
 1506 06c6 8283      		ldi r24,lo8(12)
 1507 06c8 0E94 0000 		ldi r25,hi8(12)
 1508               		sts (196)+1,r25
 1509               		sts 196,r24
 1511 06ce 0F90      	.LM151:
 1512 06d0 0F90      		ldi r24,lo8(-104)
 1513 06d2 0F90      		sts 193,r24
 1515 06d6 90E0      	.LM152:
 1516 06d8 0E94 0000 		ldi r24,lo8(6)
 1517               		sts 194,r24
 1519               	.LM153:
 1520 06dc 1F91      		ldi r24,lo8(gs(UART_putchar))
 1521 06de 0F91      		ldi r25,hi8(gs(UART_putchar))
 1522 06e0 FF90      		ldi r22,lo8(gs(UART_getchar))
 1523 06e2 EF90      		ldi r23,hi8(gs(UART_getchar))
 1524 06e4 DF90      		call fdevopen
 1526 06e8 0895      	.LM154:
 1527               	/* #APP */
 1528               	 ;  294 "ir_heat.c" 1
 1529               		sei
 1530               	 ;  0 "" 2
 1531               	/* epilogue start */
 1533               	.LM155:
 1534               	/* #NOAPP */
 1535               		ret
 1537               	.Lscope19:
 1538               		.data
 1539               	.LC6:
 1540 06ea 8CE0      		.string	"\n\nStart\n"
 1541 06ec 90E0      	.LC7:
 1542 06ee 9093 C500 		.string	"Error Temp=0"
 1543 06f2 8093 C400 	.LC8:
 1544               		.string	"Startup %i "
 1545               	.LC9:
 1546 06f6 88E9      		.string	"Temp: %i, "
 1547 06f8 8093 C100 	.LC10:
 1548               		.string	"sl_raw: %i, sl: %i, s_max: %i, f: %i, int: %i\n"
 1549               	.LC11:
 1550 06fc 86E0      		.string	"On-Counter: %i; \n"
 1551 06fe 8093 C200 	.LC12:
 1552               		.string	"Off-Counter: %i; \n"
 1553               		.text
 1555 0704 90E0      	.global	main
 1557 0708 70E0      	main:
 1559               	.LM156:
 1560               	.LFBB20:
 1561               		push r2
 1562               		push r3
 1563 070e 7894      		push r4
 1564               		push r5
 1565               		push r6
 1566               		push r7
 1567               		push r8
 1568               		push r9
 1569 0710 0895      		push r10
 1570               		push r11
 1571               		push r12
 1572               		push r13
 1573               		push r14
 1574 0049 0A0A 5374 		push r15
 1574      6172 740A 
 1574      00
 1575               		push r16
 1576 0052 4572 726F 		push r17
 1576      7220 5465 
 1576      6D70 3D30 
 1576      00
 1577               		push r29
 1578 005f 5374 6172 		push r28
 1578      7475 7020 
 1578      2569 2000 
 1579               		rcall .
 1580 006b 5465 6D70 		rcall .
 1580      3A20 2569 
 1580      2C20 00
 1581               		in r28,__SP_L__
 1582 0076 736C 5F72 		in r29,__SP_H__
 1582      6177 3A20 
 1582      2569 2C20 
 1582      736C 3A20 
 1582      2569 2C20 
 1583               	/* prologue: function */
 1584 00a5 4F6E 2D43 	/* frame size = 4 */
 1584      6F75 6E74 
 1584      6572 3A20 
 1584      2569 3B20 
 1584      0A00 
 1586 00b7 4F66 662D 	.LM157:
 1586      436F 756E 
 1586      7465 723A 
 1586      2025 693B 
 1586      200A 00
 1587               		ldi r24,lo8(-64)
 1588               		out 36-32,r24
 1590               	.LM158:
 1591               		ldi r24,lo8(8)
 450:ir_heat.c     **** 
 451:ir_heat.c     **** 
 452:ir_heat.c     **** 
 453:ir_heat.c     **** 
 454:ir_heat.c     **** // ***********************************************************
 455:ir_heat.c     **** // Main program
 456:ir_heat.c     **** //
 457:ir_heat.c     **** int main(void) {
 1592               		out 42-32,r24
 1594               	.LM160:
 1595 0712 2F92      		ldi r24,lo8(63)
 1596 0714 3F92      		out 37-32,r24
 1598 0718 5F92      	.LM161:
 1599 071a 6F92      		ldi r24,lo8(-9)
 1600 071c 7F92      		out 40-32,r24
 1602 0720 9F92      	.LM162:
 1603 0722 AF92      		mov __tmp_reg__,r31
 1604 0724 BF92      		ldi r31,lo8(43)
 1605 0726 CF92      		mov r14,r31
 1606 0728 DF92      		clr r15
 1607 072a EF92      		mov r31,__tmp_reg__
 1608 072c FF92      		ldi r24,lo8(-25)
 1609 072e 0F93      		movw r30,r14
 1610 0730 1F93      		st Z,r24
 1612 0734 CF93      	.LM163:
 1613 0736 00D0      		lds r24,100
 1615 073a CDB7      	.LM164:
 1616 073c DEB7      	/* #APP */
 1617               	 ;  472 "ir_heat.c" 1
 1618               		wdr
 458:ir_heat.c     ****    // Ausgänge definieren
 459:ir_heat.c     **** 	DDRB = 0x00 | (1<<RELAIS) | (1<<BUZZER);
 1619               	,.LM165-.LFBB20
 1620               	.LM165:
 1621 073e 80EC      	/* #NOAPP */
 1622 0740 84B9      		ldi r18,lo8(41)
 460:ir_heat.c     **** 	DDRC = 0x00 | (1<<FLASH_LED);
 1623               	 r24,lo8(24)
 1624               		ldi r25,hi8(24)
 1625 0742 88E0      	/* #APP */
 1626 0744 87B9      	 ;  473 "ir_heat.c" 1
 461:ir_heat.c     **** 	DDRD = 0x00 | (1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED);
 1627               	__tmp_reg__,__SREG__
 1628               		cli
 1629 0746 88E1      		wdr
 1630 0748 8AB9      		sts 96,r24
 462:ir_heat.c     **** 
 463:ir_heat.c     **** 	// Ausgänge ausschalten
 464:ir_heat.c     **** 	PORTB = ~((1<<RELAIS) | (1<<BUZZER));
 1631               	 __SREG__,__tmp_reg__
 1632               		sts 96,r18
 1633 074a 8FE3      		
 1634 074c 85B9      	 ;  0 "" 2
 465:ir_heat.c     **** 	PORTC = ~(1<<FLASH_LED);
 1635               	abn	68,0,476,.LM166-.LFBB20
 1636               	.LM166:
 1637 074e 87EF      	/* #NOAPP */
 1638 0750 88B9      		call UART_first_init
 466:ir_heat.c     **** 	PORTD = ~((1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED));
 1639               	abn	68,0,477,.LM167-.LFBB20
 1640               	.LM167:
 1641 0752 0F2E      		call i2c_init
 1643 0756 EF2E      	.LM168:
 1644 0758 FF24      		sts interval,__zero_reg__
 1646 075c 87EE      	.LM169:
 1647 075e F701      		ldi r24,lo8(7)
 1648 0760 8083      		sts 177,r24
 467:ir_heat.c     **** 
 468:ir_heat.c     **** 	// TWI aus Energiesparmode rausnehmen
 469:ir_heat.c     **** 	PRR != ~(1<<PRTWI);
 1649               	,0,483,.LM170-.LFBB20
 1650               	.LM170:
 1651 0762 8091 6400 		ldi r25,lo8(1)
 470:ir_heat.c     **** 
 471:ir_heat.c     **** 	// Whatchdog initialisieren
 472:ir_heat.c     **** 	wdt_reset();
 1652               	s 112,r25
 1654               	.LM171:
 1655               		out 68-32,__zero_reg__
 1657               	.LM172:
 473:ir_heat.c     **** 	wdt_enable(WDTO_8S);
 1658               	24,lo8(3)
 1659               		out 69-32,r24
 1661 0768 29E2      	.LM173:
 1662 076a 88E1      		sts 110,r25
 1664               	.LM174:
 1665               		sts 128,__zero_reg__
 1667 0770 F894      	.LM175:
 1668 0772 A895      		sts 129,__zero_reg__
 1670 0778 0FBE      	.LM176:
 1671 077a 2093 6000 		sts 130,__zero_reg__
 1673               	.LM177:
 474:ir_heat.c     **** 	
 475:ir_heat.c     **** 	// UART initialisieren
 476:ir_heat.c     **** 	UART_first_init();
 1674               	tabn	68,0,497,.LM178-.LFBB20
 1675               	.LM178:
 1676               		ldi r24,lo8(2)
 1677 077e 0E94 0000 		sts 105,r24
 477:ir_heat.c     **** 	i2c_init();
 1678               	abn	68,0,498,.LM179-.LFBB20
 1679               	.LM179:
 1680 0782 0E94 0000 		out 61-32,r25
 478:ir_heat.c     **** 	
 479:ir_heat.c     **** 	interval=0;
 1681               	tabn	68,0,501,.LM180-.LFBB20
 1682               	.LM180:
 1683 0786 1092 0000 		ldi r24,lo8(.LC6)
 480:ir_heat.c     **** 	
 481:ir_heat.c     **** 	// Timer 2 initialisieren (RTC)
 482:ir_heat.c     ****    TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);	// clk/256
 1684               	i r25,hi8(.LC6)
 1685               		call puts
 1687 078c 8093 B100 	.LM181:
 483:ir_heat.c     ****    TIMSK2 = (1<<TOIE2);
 1688               	w r30,r14
 1689               		ld r24,Z
 1690 0790 91E0      		ori r24,lo8(16)
 1691 0792 9093 7000 		st Z,r24
 484:ir_heat.c     **** 
 485:ir_heat.c     ****  	// Timer 0 initialisieren (Blinken)
 486:ir_heat.c     **** 	TCCR0A = 0;
 1692               	abn	68,0,503,.LM182-.LFBB20
 1693               	.LM182:
 1694 0796 14BC      		ld r24,Z
 487:ir_heat.c     **** 	TCCR0B = (0<<CS02) | (1<<CS01) | (1<<CS00);
 1695               	di r24,lo8(-9)
 1696               		st Z,r24
 1698 079a 85BD      	.LM183:
 488:ir_heat.c     **** 	TIMSK0 = (1<<TOIE0);
 1699               	 r24,lo8(0)
 1700               		call set_relais
 489:ir_heat.c     **** 	
 490:ir_heat.c     **** 	// Timer 1 initialisieren (Entprellen?)
 491:ir_heat.c     **** 	TCCR1A = 0;
 1702               	184:
 1703               		sts mode,__zero_reg__
 492:ir_heat.c     **** 	TIMER1_STOP;
 1705               	185:
 1706               	/* #APP */
 1707 07a4 1092 8100 	 ;  521 "ir_heat.c" 1
 493:ir_heat.c     **** 	TCCR1C = 0;
 1708               	i
 1709               	 ;  0 "" 2
 1710 07a8 1092 8200 	/* #NOAPP */
 494:ir_heat.c     **** 	TIMSK1 = (1<<TOIE1);
 1711               	r r14
 1712               		clr r15
 1713 07ac 9093 6F00 		clr r12
 495:ir_heat.c     **** 	
 496:ir_heat.c     **** 	// Interrupt für Taster initialisieren
 497:ir_heat.c     **** 	EICRA = (1<<ISC01);
 1714               	r r13
 1715               		ldi r16,lo8(0)
 1716 07b0 82E0      		clr r4
 1717 07b2 8093 6900 		dec r4
 498:ir_heat.c     **** 	EIMSK = (1<<INT0);
 1718               	 __tmp_reg__,r31
 1719               		ldi r31,lo8(3)
 1720 07b6 9DBB      		mov r5,r31
 499:ir_heat.c     **** 	
 500:ir_heat.c     **** 
 501:ir_heat.c     **** 	printf("\n\nStart\n\n");
 1721               	v r31,__tmp_reg__
 1722               		ldi r17,lo8(0)
 1723 07b8 80E0      		clr r10
 1724 07ba 90E0      		clr r11
 502:ir_heat.c     **** 	STATUS_LED1_ON;		// grüne LED ein
 1726               	6:
 1727               		mov __tmp_reg__,r31
 1728 07c0 F701      		ldi r31,lo8(43)
 1729 07c2 8081      		mov r8,r31
 1730 07c4 8061      		clr r9
 1731 07c6 8083      		mov r31,__tmp_reg__
 503:ir_heat.c     **** 	STATUS_LED2_OFF;		// rote LED aus
 1732               	n	68,0,654,.LM187-.LFBB20
 1733               	.LM187:
 1734 07c8 8081      		clr r6
 1735 07ca 877F      		clr r7
 1736 07cc 8083      	.LBB56:
 504:ir_heat.c     **** 	set_relais(0);			// Relais aus
 1737               	7:
 1738               	.LBB58:
 1739 07ce 80E0      	.LBB59:
 505:ir_heat.c     **** 	mode = MODE_OFF;
 1741               	xt11:
 1743 07d4 1092 0000 	.LM188:
 506:ir_heat.c     **** 	
 507:ir_heat.c     **** //	int16_t temp, temp_sum, temp_a;
 508:ir_heat.c     **** //	int16_t	lookahead;
 509:ir_heat.c     **** //	int16_t 	slope, max_slope;
 510:ir_heat.c     **** //	int16_t	slope_raw;
 511:ir_heat.c     **** 	int16_t 	temp, temp_sum = 0;
 512:ir_heat.c     **** 	int16_t	slope_raw, slope = 0, temp_a, max_slope;
 513:ir_heat.c     **** 	uint8_t	count=0;
 514:ir_heat.c     **** 	uint8_t  last_interval = 0xff;
 515:ir_heat.c     **** 	uint8_t	startup = 3;
 516:ir_heat.c     **** 	uint8_t	on_counter = 0;
 517:ir_heat.c     **** 	int16_t	factor;
 518:ir_heat.c     **** 	int16_t	integral = 0;
 519:ir_heat.c     **** 		
 520:ir_heat.c     **** 	// Interrupts aktivieren
 521:ir_heat.c     **** 	sei();
 1744               	v __tmp_reg__,r31
 1745               		ldi r31,lo8(25000)
 1746               		mov r2,r31
 1747               		ldi r31,hi8(25000)
 1748 07d8 7894      		mov r3,r31
 1749               		mov r31,__tmp_reg__
 1750               	.L113:
 1751 07da EE24      	.LBE59:
 1752 07dc FF24      	.LBE58:
 1753 07de CC24      	.LBE57:
 1754 07e0 DD24      	.LBE56:
 1756 07e4 4424      	.Ltext12:
 1758 07e8 0F2E      	.LM189:
 1759 07ea F3E0      		lds r20,interval
 1760 07ec 5F2E      		cpi r20,lo8(16)
 1761 07ee F02D      		brge .+2
 1762 07f0 10E0      		rjmp .L86
 1764 07f4 BB24      	.LM190:
 522:ir_heat.c     **** 
 523:ir_heat.c     ****    while(1) {
 524:ir_heat.c     ****    	if(!(interval < 16)) { 					// Alle 16x (alle 4 Sekunden) Temperatur checken
 525:ir_heat.c     ****    		wdt_reset();                  	// Whatchdog zurücksetzen
 526:ir_heat.c     **** 
 527:ir_heat.c     **** 			temp = temp_sum / count;				// Mittelwert der 16 Messungen ermitteln
 528:ir_heat.c     **** 
 529:ir_heat.c     ****    		interval=0;
 530:ir_heat.c     ****    		count=0;
 531:ir_heat.c     **** 			temp_sum = 0;
 532:ir_heat.c     **** 	      //printf("Temp: %i\n", temp);
 533:ir_heat.c     **** 	      if(temp==0) {
 534:ir_heat.c     **** 	      	// error!
 535:ir_heat.c     **** 	      	printf("Error Temp=0");
 536:ir_heat.c     **** 	      }
 537:ir_heat.c     **** 	      else {
 538:ir_heat.c     **** 				if (startup>0) {
 539:ir_heat.c     **** 					// wird nur beim ersten Durchlauf, direkt nach Startup ausgeführt
 540:ir_heat.c     **** 					printf("Startup %i ", startup);
 541:ir_heat.c     **** 					startup--;
 542:ir_heat.c     **** 					temp = get_temperature(ADR_T_OBJ1);
 543:ir_heat.c     **** 					slope = 0;
 544:ir_heat.c     **** 				}
 545:ir_heat.c     ****    	   	printf("Temp: %i, ", temp);
 546:ir_heat.c     ****    	   	add_value(temp);									// Neue Temperatur zu Array hinzufügen
 547:ir_heat.c     ****    	   	slope_raw = get_slope();						// Aktuelle Steigung ermitteln
 548:ir_heat.c     ****    	   	
 549:ir_heat.c     ****    	   	//factor = (temp - 620) / -25;					// Fakort ermitteln
 550:ir_heat.c     ****    	   	temp_a = get_temperature(ADR_T_A);
 551:ir_heat.c     ****    	   	factor = (temp - 900 + 2*temp_a ) / -25;					// Fakort ermitteln
 552:ir_heat.c     ****    	   	if(factor < 0) factor = 0;
 553:ir_heat.c     ****    	   	   	   	
 554:ir_heat.c     **** 				if(slope_raw > factor) { 						// "Steigungsintegral"
 555:ir_heat.c     **** 					integral = 8*(integral + slope_raw) / factor;
 556:ir_heat.c     **** 				}
 557:ir_heat.c     **** 				else {
 558:ir_heat.c     **** 					integral = integral / 4;
 559:ir_heat.c     **** 				}
 560:ir_heat.c     **** 				
 561:ir_heat.c     **** //				slope = (31*slope + 10*slope_raw)/32; 		// Steigung dämpfen
 562:ir_heat.c     **** 
 563:ir_heat.c     **** 				
 564:ir_heat.c     **** 				if(slope_raw < -10) slope_raw = -10;
 565:ir_heat.c     **** 				if(slope_raw<0) {									// Fallende Temperaturen werden stärker gewichtet
 566:ir_heat.c     **** 	   	   	slope = (7*slope + 10*slope_raw)/8;		// Negative Steigung wird mit einer Dämpfung von 8 ge
 567:ir_heat.c     **** 				}
 568:ir_heat.c     **** 				else {
 569:ir_heat.c     **** 	   	   	slope = (31*slope + 10*slope_raw)/32;	// Positive Steigung wird mit einer Dämpfung von 16 
 570:ir_heat.c     **** 	   	   }
 571:ir_heat.c     **** /*
 572:ir_heat.c     ****    	   	printf("slope_raw: %i, slope: %i ", slope_raw, slope);
 573:ir_heat.c     ****      	   	printf("Ambient: %i\n", get_temperature(ADR_T_A));
 574:ir_heat.c     **** */				
 575:ir_heat.c     **** 
 576:ir_heat.c     **** 				// temp_a 150 -> 45
 577:ir_heat.c     **** 				// temp_a 100 -> 60
 578:ir_heat.c     ****    	   	max_slope = temp_a * -0.3 + 90;
 579:ir_heat.c     **** 
 580:ir_heat.c     ****    	   	printf("sl_raw: %i, sl: %i, s_max: %i, f: %i, int: %i\n", slope_raw, slope, max_slope, fact
 581:ir_heat.c     **** 
 582:ir_heat.c     **** 				if((slope > max_slope) || (integral > 500)) {
 583:ir_heat.c     **** 					on_counter++;
 584:ir_heat.c     **** 		   		printf("On-Counter: %i; \n", on_counter);
 585:ir_heat.c     **** 	   			if(mode == MODE_ON_NO_PROT){
 586:ir_heat.c     **** 						on_counter++;
 587:ir_heat.c     **** 	   				if(on_counter==3){
 588:ir_heat.c     **** 	   					beep(BEEP_SHORT);
 589:ir_heat.c     **** 	   					on_counter = 0;
 590:ir_heat.c     **** 	   				}
 591:ir_heat.c     ****   					}
 592:ir_heat.c     ****    				else {
 593:ir_heat.c     ****    					if(get_last_slope() >= 0) {
 594:ir_heat.c     **** 							on_counter++;
 595:ir_heat.c     **** 			   			if(on_counter > 2) {
 596:ir_heat.c     ****    							off_counter = OFF_COUNTER+1;
 597:ir_heat.c     ****    							on_counter = 2;
 598:ir_heat.c     ****    							beep(BEEP_XLONG);
 599:ir_heat.c     **** 		   				}
 600:ir_heat.c     **** 		   				else {
 601:ir_heat.c     **** 	   						beep(BEEP_LONG);
 602:ir_heat.c     ****    						}
 603:ir_heat.c     ****    					}
 604:ir_heat.c     ****    				}
 605:ir_heat.c     **** 				}			
 606:ir_heat.c     **** 				else {
 607:ir_heat.c     **** 					on_counter = 0;
 608:ir_heat.c     **** 				}					
 609:ir_heat.c     ****    	   }
 610:ir_heat.c     **** 
 611:ir_heat.c     ****    		if(off_counter) {
 612:ir_heat.c     ****    			// Protection Counter läuft
 613:ir_heat.c     ****   				off_counter--;
 614:ir_heat.c     ****   				if(mode == MODE_ON) mode = MODE_TEMP_PROT;
 615:ir_heat.c     **** 				printf("Off-Counter: %i; \n", off_counter);
 616:ir_heat.c     ****    		}
 617:ir_heat.c     ****    		else {
 618:ir_heat.c     ****    			if(mode == MODE_TEMP_PROT) {
 619:ir_heat.c     ****    				slope = 0;
 620:ir_heat.c     ****    				integral = 0;
 621:ir_heat.c     ****    				mode = MODE_OFF;
 622:ir_heat.c     ****    			}
 623:ir_heat.c     ****    		}
 624:ir_heat.c     **** 		}
 625:ir_heat.c     **** 		else if(interval != last_interval) {
 626:ir_heat.c     **** 			// In jedem Interval 1x die Temperatur abrufen
 627:ir_heat.c     **** 			// und für den Mittelwert aufsummieren
 628:ir_heat.c     ****    		last_interval = interval;
 629:ir_heat.c     ****     		if(count<16) {
 630:ir_heat.c     **** 	   		count++;
 631:ir_heat.c     ****    			// Messwerte für den Mittelwert aufsummieren
 632:ir_heat.c     ****    			temp_sum += get_temperature(ADR_T_OBJ1);
 633:ir_heat.c     ****    		}
 634:ir_heat.c     ****    	}
 635:ir_heat.c     **** 
 636:ir_heat.c     **** 		// Je nach Mode Relais und LEDs setzen
 637:ir_heat.c     **** 		switch(mode) {
 638:ir_heat.c     **** 		case MODE_OFF:
 639:ir_heat.c     **** 			set_relais(0);
 640:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 1765               	r_heat.c" 1
 1766               		wdr
 1767 07f6 0F2E      	 ;  0 "" 2
 1769 07fa 8F2E      	.LM191:
 1770 07fc 9924      	/* #NOAPP */
 1771 07fe F02D      		movw r24,r14
 641:ir_heat.c     **** 			STATUS_LED2_OFF;
 642:ir_heat.c     **** 			off_counter = 0;
 643:ir_heat.c     **** 			on_counter = 0;
 644:ir_heat.c     **** 			break;
 645:ir_heat.c     **** 		case MODE_ON:
 646:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 647:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 648:ir_heat.c     **** 			set_relais(1);
 649:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 650:ir_heat.c     **** 			break;
 651:ir_heat.c     **** 		case MODE_TEMP_PROT:
 652:ir_heat.c     **** 			set_relais(0);
 653:ir_heat.c     **** 			STATUS_LED1_OFF;
 654:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 1772               	2,r16
 1773               		ldi r23,lo8(0)
 1774 0800 6624      		call __divmodhi4
 1775 0802 7724      		mov r24,r22
 1776               		mov r25,r23
 1777               		std Y+4,r25
 1778               		std Y+3,r24
 1780               	.LM192:
 1781               		sts interval,__zero_reg__
 1783               	.LM193:
 1784 0804 0F2E      		or r24,r25
 1785 0806 F8EA      		brne .L87
 1787 080a F1E6      	.LM194:
 1788 080c 3F2E      		rcall .
 1789 080e F02D      		ldi r18,lo8(.LC7)
 1790               		ldi r19,hi8(.LC7)
 1791               		in r30,__SP_L__
 1792               		in r31,__SP_H__
 1793               		std Z+2,r19
 1794               		std Z+1,r18
 1795               		call printf
 1796               		pop __tmp_reg__
 1797               		pop __tmp_reg__
 1798               		rjmp .L88
 1799 0810 4091 0000 	.L87:
 1801 0816 04F4      	.LM195:
 1802 0818 00C0      		tst r5
 1803               		breq .L89
 1805               	.LM196:
 1806               		rcall .
 1807 081a A895      		rcall .
 1808               		in r30,__SP_L__
 1809               		in r31,__SP_H__
 1810               		adiw r30,1
 1811               		ldi r24,lo8(.LC8)
 1812 081c C701      		ldi r25,hi8(.LC8)
 1813 081e 602F      		std Z+1,r25
 1814 0820 70E0      		st Z,r24
 1815 0822 0E94 0000 		std Z+2,r5
 1816 0826 862F      		std Z+3,__zero_reg__
 1817 0828 972F      		call printf
 1819 082c 8B83      	.LM197:
 1820               		dec r5
 1822 082e 1092 0000 	.LM198:
 1823               		pop __tmp_reg__
 1824               		pop __tmp_reg__
 1825 0832 892B      		pop __tmp_reg__
 1826 0834 01F4      		pop __tmp_reg__
 1827               		ldi r24,lo8(7)
 1828               		call get_temperature
 1829 0836 00D0      		std Y+4,r25
 1830 0838 20E0      		std Y+3,r24
 1831 083a 30E0      		movw r12,r6
 1832 083c EDB7      	.L89:
 1834 0840 3283      	.LM199:
 1835 0842 2183      		rcall .
 1836 0844 0E94 0000 		rcall .
 1837 0848 0F90      		in r30,__SP_L__
 1838 084a 0F90      		in r31,__SP_H__
 1839 084c 00C0      		adiw r30,1
 1840               		ldi r18,lo8(.LC9)
 1841               		ldi r19,hi8(.LC9)
 1842               		std Z+1,r19
 1843 084e 5520      		st Z,r18
 1844 0850 01F0      		ldd r24,Y+3
 1845               		ldd r25,Y+4
 1846               		std Z+3,r25
 1847 0852 00D0      		std Z+2,r24
 1848 0854 00D0      		call printf
 1850 0858 FEB7      	.LM200:
 1851 085a 3196      		pop __tmp_reg__
 1852 085c 80E0      		pop __tmp_reg__
 1853 085e 90E0      		pop __tmp_reg__
 1854 0860 9183      		pop __tmp_reg__
 1855 0862 8083      		ldd r24,Y+3
 1856 0864 5282      		ldd r25,Y+4
 1857 0866 1382      		call add_value
 1859               	.LM201:
 1860               		call get_slope
 1861 086c 5A94      		movw r14,r24
 1863               	.LM202:
 1864 086e 0F90      		ldi r24,lo8(6)
 1865 0870 0F90      		call get_temperature
 1866 0872 0F90      		movw r30,r24
 1868 0876 87E0      	.LM203:
 1869 0878 0E94 0000 		ldd r24,Y+3
 1870 087c 9C83      		ldd r25,Y+4
 1871 087e 8B83      		subi r24,lo8(-(-900))
 1872 0880 6301      		sbci r25,hi8(-(-900))
 1873               		movw r18,r30
 1874               		lsl r18
 1875               		rol r19
 1876 0882 00D0      		add r24,r18
 1877 0884 00D0      		adc r25,r19
 1878 0886 EDB7      		ldi r22,lo8(-25)
 1879 0888 FEB7      		ldi r23,hi8(-25)
 1880 088a 3196      		call __divmodhi4
 1881 088c 20E0      		mov r24,r22
 1882 088e 30E0      		mov r25,r23
 1883 0890 3183      		std Y+4,r25
 1884 0892 2083      		std Y+3,r24
 1885 0894 8B81      		tst r25
 1886 0896 9C81      		brge .L90
 1887 0898 9383      		std Y+4,r7
 1888 089a 8283      		std Y+3,r6
 1889 089c 0E94 0000 	.L90:
 1891               	.LM204:
 1892 08a0 0F90      		ldd r18,Y+3
 1893 08a2 0F90      		ldd r19,Y+4
 1894 08a4 0F90      		cp r18,r14
 1895 08a6 0F90      		cpc r19,r15
 1896 08a8 8B81      		brge .L91
 1898 08ac 0E94 0000 	.LM205:
 1899               		movw r24,r10
 1900               		add r24,r14
 1901 08b0 0E94 0000 		adc r25,r15
 1902 08b4 7C01      		lsl r24
 1903               		rol r25
 1904               		lsl r24
 1905 08b6 86E0      		rol r25
 1906 08b8 0E94 0000 		lsl r24
 1907 08bc FC01      		rol r25
 1908               		movw r22,r18
 1909               		call __divmodhi4
 1910 08be 8B81      		mov r24,r22
 1911 08c0 9C81      		mov r25,r23
 1912 08c2 8458      		movw r10,r24
 1913 08c4 9340      		rjmp .L92
 1914 08c6 9F01      	.L91:
 1916 08ca 331F      	.LM206:
 1917 08cc 820F      		movw r24,r10
 1918 08ce 931F      		tst r11
 1919 08d0 67EE      		brge .L93
 1920 08d2 7FEF      		adiw r24,3
 1921 08d4 0E94 0000 	.L93:
 1922 08d8 862F      		movw r10,r24
 1923 08da 972F      		asr r11
 1924 08dc 9C83      		ror r10
 1925 08de 8B83      		asr r11
 1926 08e0 9923      		ror r10
 1927 08e2 04F4      	.L92:
 1929 08e6 6B82      	.LM207:
 1930               		ldi r19,lo8(-10)
 1931               		cp r14,r19
 1932               		ldi r19,hi8(-10)
 1933 08e8 2B81      		cpc r15,r19
 1934 08ea 3C81      		brge .L94
 1935 08ec 2E15      		mov __tmp_reg__,r31
 1936 08ee 3F05      		ldi r31,lo8(-10)
 1937 08f0 04F4      		mov r14,r31
 1938               		ldi r31,hi8(-10)
 1939               		mov r15,r31
 1940 08f2 C501      		mov r31,__tmp_reg__
 1941 08f4 8E0D      		rjmp .L95
 1942 08f6 9F1D      	.L94:
 1944 08fa 991F      	.LM208:
 1945 08fc 880F      		tst r15
 1946 08fe 991F      		brge .L96
 1947 0900 880F      	.L95:
 1949 0904 B901      	.LM209:
 1950 0906 0E94 0000 		movw r18,r14
 1951 090a 862F      		lsl r18
 1952 090c 972F      		rol r19
 1953 090e 5C01      		movw r24,r14
 1954 0910 00C0      		lsl r24
 1955               		rol r25
 1956               		lsl r24
 1957               		rol r25
 1958 0912 C501      		lsl r24
 1959 0914 BB20      		rol r25
 1960 0916 04F4      		add r18,r24
 1961 0918 0396      		adc r19,r25
 1962               		movw r24,r12
 1963 091a 5C01      		lsl r24
 1964 091c B594      		rol r25
 1965 091e A794      		lsl r24
 1966 0920 B594      		rol r25
 1967 0922 A794      		lsl r24
 1968               		rol r25
 1969               		sub r24,r12
 1970               		sbc r25,r13
 1971 0924 36EF      		add r18,r24
 1972 0926 E316      		adc r19,r25
 1973 0928 3FEF      		tst r19
 1974 092a F306      		brge .L97
 1975 092c 04F4      		subi r18,lo8(-(7))
 1976 092e 0F2E      		sbci r19,hi8(-(7))
 1977 0930 F6EF      	.L97:
 1978 0932 EF2E      		movw r12,r18
 1979 0934 FFEF      		asr r13
 1980 0936 FF2E      		ror r12
 1981 0938 F02D      		asr r13
 1982 093a 00C0      		ror r12
 1983               		asr r13
 1984               		ror r12
 1985               		rjmp .L98
 1986 093c FF20      	.L96:
 1988               	.LM210:
 1989               		ldi r18,lo8(31)
 1990               		ldi r19,hi8(31)
 1991 0940 9701      		mul r12,r18
 1992 0942 220F      		movw r24,r0
 1993 0944 331F      		mul r12,r19
 1994 0946 C701      		add r25,r0
 1995 0948 880F      		mul r13,r18
 1996 094a 991F      		add r25,r0
 1997 094c 880F      		clr r1
 1998 094e 991F      		movw r18,r14
 1999 0950 880F      		lsl r18
 2000 0952 991F      		rol r19
 2001 0954 280F      		movw r20,r14
 2002 0956 391F      		lsl r20
 2003 0958 C601      		rol r21
 2004 095a 880F      		lsl r20
 2005 095c 991F      		rol r21
 2006 095e 880F      		lsl r20
 2007 0960 991F      		rol r21
 2008 0962 880F      		add r18,r20
 2009 0964 991F      		adc r19,r21
 2010 0966 8C19      		add r18,r24
 2011 0968 9D09      		adc r19,r25
 2012 096a 280F      		tst r19
 2013 096c 391F      		brge .L99
 2014 096e 3323      		subi r18,lo8(-(31))
 2015 0970 04F4      		sbci r19,hi8(-(31))
 2016 0972 295F      	.L99:
 2017 0974 3F4F      		movw r12,r18
 2018               		asr r13
 2019 0976 6901      		ror r12
 2020 0978 D594      		asr r13
 2021 097a C794      		ror r12
 2022 097c D594      		asr r13
 2023 097e C794      		ror r12
 2024 0980 D594      		asr r13
 2025 0982 C794      		ror r12
 2026 0984 00C0      		asr r13
 2027               		ror r12
 2028               	.L98:
 2030 0986 2FE1      	.LM211:
 2031 0988 30E0      		movw r22,r30
 2032 098a C29E      		clr r24
 2033 098c C001      		sbrc r23,7
 2034 098e C39E      		com r24
 2035 0990 900D      		mov r25,r24
 2036 0992 D29E      		call __floatsisf
 2037 0994 900D      		ldi r18,lo8(0xbe99999a)
 2038 0996 1124      		ldi r19,hi8(0xbe99999a)
 2039 0998 9701      		ldi r20,hlo8(0xbe99999a)
 2040 099a 220F      		ldi r21,hhi8(0xbe99999a)
 2041 099c 331F      		call __mulsf3
 2042 099e A701      		ldi r18,lo8(0x42b40000)
 2043 09a0 440F      		ldi r19,hi8(0x42b40000)
 2044 09a2 551F      		ldi r20,hlo8(0x42b40000)
 2045 09a4 440F      		ldi r21,hhi8(0x42b40000)
 2046 09a6 551F      		call __addsf3
 2047 09a8 440F      		call __fixsfsi
 2048 09aa 551F      		std Y+2,r23
 2049 09ac 240F      		std Y+1,r22
 2051 09b0 280F      	.LM212:
 2052 09b2 391F      		in r30,__SP_L__
 2053 09b4 3323      		in r31,__SP_H__
 2054 09b6 04F4      		sbiw r30,12
 2055 09b8 215E      		in __tmp_reg__,__SREG__
 2056 09ba 3F4F      		cli
 2057               		out __SP_H__,r31
 2058 09bc 6901      		out __SREG__,__tmp_reg__
 2059 09be D594      		out __SP_L__,r30
 2060 09c0 C794      		adiw r30,1
 2061 09c2 D594      		ldi r18,lo8(.LC10)
 2062 09c4 C794      		ldi r19,hi8(.LC10)
 2063 09c6 D594      		std Z+1,r19
 2064 09c8 C794      		st Z,r18
 2065 09ca D594      		std Z+3,r15
 2066 09cc C794      		std Z+2,r14
 2067 09ce D594      		std Z+5,r13
 2068 09d0 C794      		std Z+4,r12
 2069               		std Z+7,r23
 2070               		std Z+6,r22
 2071               		ldd r24,Y+3
 2072 09d2 BF01      		ldd r25,Y+4
 2073 09d4 8827      		std Z+9,r25
 2074 09d6 77FD      		std Z+8,r24
 2075 09d8 8095      		std Z+11,r11
 2076 09da 982F      		std Z+10,r10
 2077 09dc 0E94 0000 		call printf
 2079 09e2 39E9      	.LM213:
 2080 09e4 49E9      		in r30,__SP_L__
 2081 09e6 5EEB      		in r31,__SP_H__
 2082 09e8 0E94 0000 		adiw r30,12
 2083 09ec 20E0      		in __tmp_reg__,__SREG__
 2084 09ee 30E0      		cli
 2085 09f0 44EB      		out __SP_H__,r31
 2086 09f2 52E4      		out __SREG__,__tmp_reg__
 2087 09f4 0E94 0000 		out __SP_L__,r30
 2088 09f8 0E94 0000 		ldd r18,Y+1
 2089 09fc 7A83      		ldd r19,Y+2
 2090 09fe 6983      		cp r18,r12
 2091               		cpc r19,r13
 2092               		brlt .L100
 2093 0a00 EDB7      		ldi r19,lo8(501)
 2094 0a02 FEB7      		cp r10,r19
 2095 0a04 3C97      		ldi r19,hi8(501)
 2096 0a06 0FB6      		cpc r11,r19
 2097 0a08 F894      		brge .L100
 2098 0a0a FEBF      		ldi r17,lo8(0)
 2099 0a0c 0FBE      		rjmp .L88
 2100 0a0e EDBF      	.L100:
 2102 0a12 20E0      	.LM214:
 2103 0a14 30E0      		subi r17,lo8(-(1))
 2105 0a18 2083      	.LM215:
 2106 0a1a F382      		rcall .
 2107 0a1c E282      		rcall .
 2108 0a1e D582      		in r30,__SP_L__
 2109 0a20 C482      		in r31,__SP_H__
 2110 0a22 7783      		adiw r30,1
 2111 0a24 6683      		ldi r24,lo8(.LC11)
 2112 0a26 8B81      		ldi r25,hi8(.LC11)
 2113 0a28 9C81      		std Z+1,r25
 2114 0a2a 9187      		st Z,r24
 2115 0a2c 8087      		std Z+2,r17
 2116 0a2e B386      		std Z+3,__zero_reg__
 2117 0a30 A286      		call printf
 2119               	.LM216:
 2120               		pop __tmp_reg__
 2121 0a36 EDB7      		pop __tmp_reg__
 2122 0a38 FEB7      		pop __tmp_reg__
 2123 0a3a 3C96      		pop __tmp_reg__
 2124 0a3c 0FB6      		lds r24,mode
 2125 0a3e F894      		cpi r24,lo8(2)
 2126 0a40 FEBF      		brne .L101
 2128 0a44 EDBF      	.LM217:
 2129 0a46 2981      		subi r17,lo8(-(1))
 2131 0a4a 2C15      	.LM218:
 2132 0a4c 3D05      		cpi r17,lo8(3)
 2133 0a4e 04F0      		brne .L88
 2135 0a52 A316      	.LM219:
 2136 0a54 31E0      		ldi r24,lo8(1)
 2137 0a56 B306      		call beep
 2138 0a58 04F4      		ldi r17,lo8(0)
 2139 0a5a 10E0      		rjmp .L88
 2140 0a5c 00C0      	.L101:
 2142               	.LM220:
 2143               		call get_last_slope
 2144 0a5e 1F5F      		tst r25
 2145               		brlt .L88
 2147 0a60 00D0      	.LM221:
 2148 0a62 00D0      		subi r17,lo8(-(1))
 2150 0a66 FEB7      	.LM222:
 2151 0a68 3196      		cpi r17,lo8(3)
 2152 0a6a 80E0      		brlo .L102
 2154 0a6e 9183      	.LM223:
 2155 0a70 8083      		ldi r25,lo8(3)
 2156 0a72 1283      		sts off_counter,r25
 2158 0a76 0E94 0000 	.LM224:
 2159               		ldi r24,lo8(4)
 2160               		call beep
 2161 0a7a 0F90      		ldi r17,lo8(2)
 2162 0a7c 0F90      		rjmp .L88
 2163 0a7e 0F90      	.L102:
 2165 0a82 8091 0000 	.LM225:
 2166 0a86 8230      		ldi r24,lo8(3)
 2167 0a88 01F4      		call beep
 2168               	.L88:
 2170 0a8a 1F5F      	.LM226:
 2171               		lds r24,off_counter
 2172               		tst r24
 2173 0a8c 1330      		breq .L103
 2175               	.LM227:
 2176               		mov r25,r24
 2177 0a90 81E0      		subi r25,lo8(-(-1))
 2178 0a92 0E94 0000 		sts off_counter,r25
 2180 0a98 00C0      	.LM228:
 2181               		lds r24,mode
 2182               		cpi r24,lo8(1)
 2183               		brne .L104
 2184 0a9a 0E94 0000 		ldi r30,lo8(3)
 2185 0a9e 9923      		sts mode,r30
 2186 0aa0 04F0      	.L104:
 2188               	.LM229:
 2189 0aa2 1F5F      		rcall .
 2190               		rcall .
 2191               		in r30,__SP_L__
 2192 0aa4 1330      		in r31,__SP_H__
 2193 0aa6 00F0      		adiw r30,1
 2194               		ldi r18,lo8(.LC12)
 2195               		ldi r19,hi8(.LC12)
 2196 0aa8 93E0      		std Z+1,r19
 2197 0aaa 9093 0000 		st Z,r18
 2198               		std Z+2,r25
 2199               		std Z+3,__zero_reg__
 2200 0aae 84E0      		call printf
 2201 0ab0 0E94 0000 		movw r14,r6
 2202 0ab4 12E0      		ldi r16,lo8(0)
 2203 0ab6 00C0      		pop __tmp_reg__
 2204               		pop __tmp_reg__
 2205               		pop __tmp_reg__
 2206               		pop __tmp_reg__
 2207 0ab8 83E0      		rjmp .L105
 2208 0aba 0E94 0000 	.L103:
 2210               	.LM230:
 2211               		lds r24,mode
 2212 0abe 8091 0000 		cpi r24,lo8(3)
 2213 0ac2 8823      		breq .L106
 2214 0ac4 01F0      		movw r14,r6
 2215               		ldi r16,lo8(0)
 2216               		rjmp .L105
 2217 0ac6 982F      	.L106:
 2219 0aca 9093 0000 	.LM231:
 2220               		sts mode,__zero_reg__
 2221               		movw r14,r6
 2222 0ace 8091 0000 		movw r12,r6
 2223 0ad2 8130      		ldi r16,lo8(0)
 2224 0ad4 01F4      		movw r10,r6
 2225 0ad6 E3E0      		rjmp .L107
 2226 0ad8 E093 0000 	.L86:
 2228               	.LM232:
 2229               		mov r18,r20
 2230 0adc 00D0      		clr r19
 2231 0ade 00D0      		sbrc r18,7
 2232 0ae0 EDB7      		com r19
 2233 0ae2 FEB7      		mov r24,r4
 2234 0ae4 3196      		ldi r25,lo8(0)
 2235 0ae6 20E0      		cp r18,r24
 2236 0ae8 30E0      		cpc r19,r25
 2237 0aea 3183      		breq .L105
 2239 0aee 9283      	.LM233:
 2240 0af0 1382      		mov r4,r20
 2242 0af6 7301      	.LM234:
 2243 0af8 00E0      		cpi r16,lo8(16)
 2244 0afa 0F90      		brsh .L105
 2246 0afe 0F90      	.LM235:
 2247 0b00 0F90      		subi r16,lo8(-(1))
 2249               	.LM236:
 2250               		ldi r24,lo8(7)
 2251               		call get_temperature
 2252 0b04 8091 0000 		add r14,r24
 2253 0b08 8330      		adc r15,r25
 2254 0b0a 01F0      	.L105:
 2256 0b0e 00E0      	.LM237:
 2257 0b10 00C0      		lds r24,mode
 2258               		cpi r24,lo8(1)
 2259               		breq .L109
 2260               		cpi r24,lo8(1)
 2261 0b12 1092 0000 		brlo .L107
 2262 0b16 7301      		cpi r24,lo8(2)
 2263 0b18 6301      		breq .L110
 2264 0b1a 00E0      		cpi r24,lo8(3)
 2265 0b1c 5301      		brne .L115
 2266 0b1e 00C0      		rjmp .L116
 2267               	.L107:
 2269               	.LM238:
 2270 0b20 242F      		ldi r24,lo8(0)
 2271 0b22 3327      		call set_relais
 2273 0b26 3095      	.LM239:
 2274 0b28 842D      		movw r30,r8
 2275 0b2a 90E0      		ld r24,Z
 2276 0b2c 2817      		ori r24,lo8(16)
 2277 0b2e 3907      		st Z,r24
 2279               	.LM240:
 2280               		ld r24,Z
 2281 0b32 442E      		andi r24,lo8(-9)
 2282               		st Z,r24
 2284 0b34 0031      	.LM241:
 2285 0b36 00F4      		sts off_counter,__zero_reg__
 2286               		ldi r17,lo8(0)
 2287               		rjmp .L112
 2288 0b38 0F5F      	.L109:
 2290               	.LM242:
 2291 0b3a 87E0      		movw r30,r8
 2292 0b3c 0E94 0000 		ld r24,Z
 2293 0b40 E80E      		ori r24,lo8(16)
 2294 0b42 F91E      		st Z,r24
 2295               	.L110:
 2297               	.LM243:
 2298 0b44 8091 0000 		ldi r24,lo8(1)
 2299 0b48 8130      		call set_relais
 2301 0b4c 8130      	.LM244:
 2302 0b4e 00F0      		movw r30,r8
 2303 0b50 8230      		ld r24,Z
 2304 0b52 01F0      		ori r24,lo8(8)
 2305 0b54 8330      		st Z,r24
 2306 0b56 01F4      		rjmp .L112
 2307 0b58 00C0      	.L116:
 2309               	.LM245:
 2310               		ldi r24,lo8(0)
 2311 0b5a 80E0      		call set_relais
 2313               	.LM246:
 2314               		movw r30,r8
 2315 0b60 F401      		ld r24,Z
 2316 0b62 8081      		andi r24,lo8(-17)
 2317 0b64 8061      		st Z,r24
 2319               	.LM247:
 2320               		ld r24,Z
 2321 0b68 8081      		ori r24,lo8(8)
 2322 0b6a 877F      		st Z,r24
 2323 0b6c 8083      		movw r12,r6
 2324               		movw r10,r6
 2325               		rjmp .L112
 2326 0b6e 1092 0000 	.L115:
 2328 0b74 00C0      	.LM248:
 2329               		sts mode,__zero_reg__
 2330               	.L112:
 2331               	.LBB63:
 2332 0b76 F401      	.LBB62:
 2333 0b78 8081      	.LBB61:
 2334 0b7a 8061      	.LBB60:
 2336               	.Ltext13:
 2338               	.LM249:
 2339 0b7e 81E0      		movw r24,r2
 2340 0b80 0E94 0000 	/* #APP */
 2341               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 2342               		1: sbiw r24,1
 2343 0b84 F401      		brne 1b
 2344 0b86 8081      	 ;  0 "" 2
 2345 0b88 8860      	/* #NOAPP */
 2346 0b8a 8083      		rjmp .L113
 2347 0b8c 00C0      	.LBE60:
 2348               	.LBE61:
 2349               	.LBE62:
 2350               	.LBE63:
 2366 0ba6 00C0      	.Lscope20:
 2367               	.global	interval
 655:ir_heat.c     **** 			slope = 0;
 656:ir_heat.c     **** 			integral = 0;
 657:ir_heat.c     **** 			break;
 658:ir_heat.c     **** 		default:
 659:ir_heat.c     **** 			mode = MODE_OFF;
 2368               	tabn	224,0,0,.Lscope20-.LFBB20
 2369               	.Lscope20:
 2370 0ba8 1092 0000 	.global	interval
 2371               		.data
 2374               	interval:
 2375               		.byte	-12
 2376               	.global	off_counter
 2377               	.global	off_counter
 2378               		.section .bss
 2381               	off_counter:
 2382               		.skip 1,0
 2383 0bae 0197      	.global	flash_button
 2384 0bb0 01F4      	.global	flash_button
 2387 0bb2 00C0      	flash_button:
 2388               		.skip 1,0
 2389               	.global	flash_LED
 2390               	.global	flash_LED
 2393               	flash_LED:
 2394               		.skip 1,0
 2395               		.lcomm last.1976,1
 2396               		.lcomm running.1753,1
 2397               		.lcomm c2.1727,1
 2398               		.lcomm c1.1726,1
 2399               		.comm tbuf,32,1
 2400               		.comm rbuf,32,1
 2401               		.comm t_in,1,1
 2402               		.comm t_out,1,1
 2403               		.comm r_in,1,1
 2404               		.comm r_out,1,1
 2405               		.comm t_array,12,1
 2406               		.comm mode,1,1
 2407               		.comm slope2,2,1
 2425               		.text
 2427               	.Letext0:
 2428               	.global __do_copy_data
 2429               	.global __do_clear_bss
 2430               	...
DEFINED SYMBOLS
                            *ABS*:00000000 ir_heat.c
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:2      *ABS*:0000003f __SREG__
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:3      *ABS*:0000003e __SP_H__
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:4      *ABS*:0000003d __SP_L__
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:5      *ABS*:00000034 __CCP__
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:89     .text:00000000 __vector_9
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:2412   .data:000000ca interval
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:120    .text:00000022 __vector_13
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:153    .text:00000042 __vector_16
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:2435   .bss:00000006 c1.1726
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:2434   .bss:00000005 c2.1727
                            *COM*:00000001 mode
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:274    .text:000000de __vector_18
                            *COM*:00000001 r_in
                            *COM*:00000020 rbuf
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:324    .text:0000011c __vector_19
                            *COM*:00000001 t_in
                            *COM*:00000001 t_out
                            *COM*:00000020 tbuf
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:387    .text:00000176 tbuflen
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:409    .text:00000182 UART_putchar
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:466    .text:000001ce rbuflen
                            *COM*:00000001 r_out
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:487    .text:000001da UART_getchar
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:526    .text:00000200 add_value
                            *COM*:0000000c t_array
                            *COM*:00000002 slope2
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:641    .text:000002c6 get_slope
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:718    .text:00000346 get_last_slope
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:744    .text:00000360 _beep
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:820    .text:0000039e beep
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:967    .text:00000412 set_relais
                             .bss:00000003 last.1976
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:1036   .text:00000458 __vector_1
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:2433   .bss:00000004 running.1753
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:1302   .text:0000058a get_temperature
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:1394   .text:000005ee print_array
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:1532   .text:000006ea UART_first_init
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:1591   .text:00000712 main
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:2419   .bss:00000000 off_counter
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:2425   .bss:00000001 flash_button
C:\Users\Thorsten\AppData\Local\Temp/ccC0QgJb.s:2431   .bss:00000002 flash_LED

UNDEFINED SYMBOLS
__divmodhi4
__udivmodhi4
puts
i2c_start
i2c_write
i2c_rep_start
i2c_read_ack
i2c_stop
printf
putchar
fdevopen
i2c_init
__floatsisf
__mulsf3
__addsf3
__fixsfsi
__do_copy_data
__do_clear_bss
