   1               		.file	"ir_heat.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  99               	.global	millis
 101               	millis:
   1:ir_heat.c     **** // ***********************************************************
   2:ir_heat.c     **** // Project:
   3:ir_heat.c     **** // Author:
   4:ir_heat.c     **** // Module description:
   5:ir_heat.c     **** // ***********************************************************
   6:ir_heat.c     **** 
   7:ir_heat.c     **** #ifndef F_CPU
   8:ir_heat.c     **** #define F_CPU 2000000UL
   9:ir_heat.c     **** #endif
  10:ir_heat.c     **** 
  11:ir_heat.c     **** #include <avr\io.h>              // Most basic include files
  12:ir_heat.c     **** #include <avr\interrupt.h>       // Add the necessary ones
  13:ir_heat.c     **** //#include <avr\signal.h>          // here
  14:ir_heat.c     **** #include <avr\wdt.h>
  15:ir_heat.c     **** 
  16:ir_heat.c     **** #include <stdio.h>
  17:ir_heat.c     **** #include <string.h>
  18:ir_heat.c     **** #include <stdlib.h>
  19:ir_heat.c     **** #include <avr/power.h>
  20:ir_heat.c     **** #include	<util/delay.h>
  21:ir_heat.c     **** 
  22:ir_heat.c     **** #include "i2c_mast.h"
  23:ir_heat.c     **** #include "ir_heat.h"
  24:ir_heat.c     **** #include "VL53L0X.h"
  25:ir_heat.c     **** 
  26:ir_heat.c     **** #define 	MLX90614_WRITE	(0x5A<<1)
  27:ir_heat.c     **** #define 	MLX90614_READ	(MLX90614_WRITE+1)
  28:ir_heat.c     **** #define	ADR_T_A			0x06
  29:ir_heat.c     **** #define	ADR_T_OBJ1		0x07
  30:ir_heat.c     **** #define	ADR_T_OBJ2		0x08
  31:ir_heat.c     **** #define	DEFAULT_TEMP	150
  32:ir_heat.c     **** 
  33:ir_heat.c     **** 
  34:ir_heat.c     **** #define __STDIO_FDEVOPEN_COMPAT_12						
  35:ir_heat.c     **** // Buffer sizes must be 2^n
  36:ir_heat.c     **** //
  37:ir_heat.c     **** #define TBUFSIZE			32
  38:ir_heat.c     **** #define RBUFSIZE			32
  39:ir_heat.c     **** 
  40:ir_heat.c     **** #define TMASK				(TBUFSIZE-1)
  41:ir_heat.c     **** #define RMASK				(RBUFSIZE-1)
  42:ir_heat.c     **** 
  43:ir_heat.c     **** #define FLASH_LED			PC3
  44:ir_heat.c     **** #define STATUS_LED1		PD4
  45:ir_heat.c     **** #define STATUS_LED2		PD3
  46:ir_heat.c     **** #define RELAIS				PB6
  47:ir_heat.c     **** #define BUZZER				PB7
  48:ir_heat.c     **** #define SWITCH				PD2
  49:ir_heat.c     **** 
  50:ir_heat.c     **** #define RELAIS_ON			PORTB |= (1<<RELAIS)
  51:ir_heat.c     **** #define RELAIS_OFF		PORTB &=~(1<<RELAIS)
  52:ir_heat.c     **** 
  53:ir_heat.c     **** #define BUZZER_ON			PORTB |= (1<<BUZZER)
  54:ir_heat.c     **** #define BUZZER_OFF		PORTB &=~(1<<BUZZER)
  55:ir_heat.c     **** 
  56:ir_heat.c     **** #define STATUS_LED1_ON	PORTD |= (1<<STATUS_LED1)
  57:ir_heat.c     **** #define STATUS_LED1_OFF	PORTD &=~(1<<STATUS_LED1)
  58:ir_heat.c     **** 
  59:ir_heat.c     **** #define FLASH_LED_ON		PORTC |= (1<<FLASH_LED)
  60:ir_heat.c     **** #define FLASH_LED_OFF	PORTC &=~(1<<FLASH_LED)
  61:ir_heat.c     **** 
  62:ir_heat.c     **** #define STATUS_LED2_ON	PORTD |= (1<<STATUS_LED2)
  63:ir_heat.c     **** #define STATUS_LED2_OFF	PORTD &=~(1<<STATUS_LED2)
  64:ir_heat.c     **** 
  65:ir_heat.c     **** #define OFF_COUNTER		2
  66:ir_heat.c     **** 
  67:ir_heat.c     **** #define TIMER1_STOP		TCCR1B = 0
  68:ir_heat.c     **** #define TIMER1_RUN		TCCR1B = (0<<CS12) | (1<<CS11) | (0<<CS10)
  69:ir_heat.c     **** 
  70:ir_heat.c     **** #define	MODE_OFF				0
  71:ir_heat.c     **** #define	MODE_ON				1
  72:ir_heat.c     **** #define	MODE_ON_NO_PROT	2
  73:ir_heat.c     **** #define	MODE_TEMP_PROT		3
  74:ir_heat.c     **** 
  75:ir_heat.c     **** #define	BEEP_SHORT			1
  76:ir_heat.c     **** #define	BEEP_2SHORT			2
  77:ir_heat.c     **** #define	BEEP_LONG			3
  78:ir_heat.c     **** #define	BEEP_XLONG			4
  79:ir_heat.c     **** #define	BEEP_2LONG			5
  80:ir_heat.c     **** #define	BEEP_SHORT_LONG	6
  81:ir_heat.c     **** 
  82:ir_heat.c     **** // Define here the global static variables
  83:ir_heat.c     **** //
  84:ir_heat.c     **** volatile unsigned char tbuf[TBUFSIZE];  // TX buffer
  85:ir_heat.c     **** volatile unsigned char rbuf[RBUFSIZE];  // RX buffer
  86:ir_heat.c     **** 
  87:ir_heat.c     **** volatile unsigned char t_in;            // TX buffer in index
  88:ir_heat.c     **** volatile unsigned char t_out;           // TX buffer out index
  89:ir_heat.c     **** 
  90:ir_heat.c     **** volatile unsigned char r_in;            // RX buffer in index
  91:ir_heat.c     **** volatile unsigned char r_out;           // RX buffer out index
  92:ir_heat.c     **** 
  93:ir_heat.c     **** int8_t	interval = -12;
  94:ir_heat.c     **** int16_t 	t_array[6];
  95:ir_heat.c     **** uint8_t	off_counter = 0;
  96:ir_heat.c     **** uint8_t	mode;
  97:ir_heat.c     **** int16_t	slope2;
  98:ir_heat.c     **** uint8_t	flash_button = 0;
  99:ir_heat.c     **** uint8_t	flash_LED = 0;
 100:ir_heat.c     **** 
 101:ir_heat.c     **** /*
 102:ir_heat.c     **** uint16_t	t_la_threshold_up 	=  300;
 103:ir_heat.c     **** uint16_t	t_abs_threshold_up 	=  270;
 104:ir_heat.c     **** uint16_t	t_la_threshold_down 	=  250;
 105:ir_heat.c     **** uint16_t	t_abs_threshold_down	=  250;
 106:ir_heat.c     **** */
 107:ir_heat.c     **** 
 108:ir_heat.c     **** volatile uint32_t g_Millis=0;
 109:ir_heat.c     **** 
 110:ir_heat.c     **** // Return ellapsed time since startup in [ms]
 111:ir_heat.c     **** uint32_t millis(){
 102               	1,.LM0-.LFBB1
 103               	.LM0:
 104               	.LFBB1:
 105               	/* prologue: function */
 106               	/* frame size = 0 */
 112:ir_heat.c     ****     uint32_t m;
 113:ir_heat.c     ****     uint8_t oldSREG = SREG;
 107               	bn	68,0,113,.LM1-.LFBB1
 108               	.LM1:
 109 0000 8FB7      		in r24,__SREG__
 114:ir_heat.c     ****      // disable interrupts while we read timer0_millis or we might get an
 115:ir_heat.c     ****     // inconsistent value (e.g. in the middle of a write to timer0_millis)
 116:ir_heat.c     ****     cli();
 110               	tabn	68,0,116,.LM2-.LFBB1
 111               	.LM2:
 112               	/* #APP */
 113               	 ;  116 "ir_heat.c" 1
 114 0002 F894      		cli
 115               	 ;  0 "" 2
 117:ir_heat.c     ****     m = g_Millis;
 116               	n	68,0,117,.LM3-.LFBB1
 117               	.LM3:
 118               	/* #NOAPP */
 119 0004 2091 0000 		lds r18,g_Millis
 120 0008 3091 0000 		lds r19,(g_Millis)+1
 121 000c 4091 0000 		lds r20,(g_Millis)+2
 122 0010 5091 0000 		lds r21,(g_Millis)+3
 118:ir_heat.c     ****     SREG = oldSREG;
 123               		68,0,118,.LM4-.LFBB1
 124               	.LM4:
 125 0014 8FBF      		out __SREG__,r24
 119:ir_heat.c     ****     return m;
 120:ir_heat.c     **** }
 126               	tabn	68,0,120,.LM5-.LFBB1
 127               	.LM5:
 128 0016 622F      		mov r22,r18
 129 0018 732F      		mov r23,r19
 130 001a 842F      		mov r24,r20
 131 001c 952F      		mov r25,r21
 132               	/* epilogue start */
 133 001e 0895      		ret
 139               	.Lscope1:
 141               	.global	__vector_9
 143               	__vector_9:
 121:ir_heat.c     **** 
 122:ir_heat.c     **** // Clock Timer
 123:ir_heat.c     **** SIGNAL(SIG_OVERFLOW2) {
 144               	LM6-.LFBB2
 145               	.LM6:
 146               	.LFBB2:
 147 0020 1F92      		push __zero_reg__
 148 0022 0F92      		push r0
 149 0024 0FB6      		in r0,__SREG__
 150 0026 0F92      		push r0
 151 0028 1124      		clr __zero_reg__
 152 002a 8F93      		push r24
 153 002c 9F93      		push r25
 154 002e AF93      		push r26
 155 0030 BF93      		push r27
 156               	/* prologue: Signal */
 157               	/* frame size = 0 */
 124:ir_heat.c     **** 	interval++;
 158               	24,.LM7-.LFBB2
 159               	.LM7:
 160 0032 8091 0000 		lds r24,interval
 161 0036 8F5F      		subi r24,lo8(-(1))
 162 0038 8093 0000 		sts interval,r24
 125:ir_heat.c     **** 	//*************************
 126:ir_heat.c     **** 	static uint8_t usFract=0;
 127:ir_heat.c     **** 	g_Millis += MILLIS_INC;
 163               	bn	68,0,127,.LM8-.LFBB2
 164               	.LM8:
 165 003c 8091 0000 		lds r24,g_Millis
 166 0040 9091 0000 		lds r25,(g_Millis)+1
 167 0044 A091 0000 		lds r26,(g_Millis)+2
 168 0048 B091 0000 		lds r27,(g_Millis)+3
 169 004c 8D57      		subi r24,lo8(-(131))
 170 004e 9F4F      		sbci r25,hi8(-(131))
 171 0050 AF4F      		sbci r26,hlo8(-(131))
 172 0052 BF4F      		sbci r27,hhi8(-(131))
 173 0054 8093 0000 		sts g_Millis,r24
 174 0058 9093 0000 		sts (g_Millis)+1,r25
 175 005c A093 0000 		sts (g_Millis)+2,r26
 176 0060 B093 0000 		sts (g_Millis)+3,r27
 177               	/* epilogue start */
 128:ir_heat.c     **** //	usFract  += MILLIS_INC_FRACT>>3;// 680 / 8 =  85.0
 129:ir_heat.c     **** //	if( usFract >= 1000>>3 ){		//1000 / 8 = 125.0
 130:ir_heat.c     **** //		usFract -= 1000>>3;			//Fractional part added up to 1 ms
 131:ir_heat.c     **** //		g_Millis++;
 132:ir_heat.c     **** //	}
 133:ir_heat.c     **** 	//**************************
 134:ir_heat.c     **** }
 178               	4,.LM9-.LFBB2
 179               	.LM9:
 180 0064 BF91      		pop r27
 181 0066 AF91      		pop r26
 182 0068 9F91      		pop r25
 183 006a 8F91      		pop r24
 184 006c 0F90      		pop r0
 185 006e 0FBE      		out __SREG__,r0
 186 0070 0F90      		pop r0
 187 0072 1F90      		pop __zero_reg__
 188 0074 1895      		reti
 190               	.Lscope2:
 192               	.global	__vector_13
 194               	__vector_13:
 135:ir_heat.c     **** 
 136:ir_heat.c     **** SIGNAL(SIG_OVERFLOW1) {
 195               	.LM10-.LFBB3
 196               	.LM10:
 197               	.LFBB3:
 198 0076 1F92      		push __zero_reg__
 199 0078 0F92      		push r0
 200 007a 0FB6      		in r0,__SREG__
 201 007c 0F92      		push r0
 202 007e 1124      		clr __zero_reg__
 203               	/* prologue: Signal */
 204               	/* frame size = 0 */
 137:ir_heat.c     **** 	TIMER1_STOP;
 205               	,0,137,.LM11-.LFBB3
 206               	.LM11:
 207 0080 1092 8100 		sts 129,__zero_reg__
 138:ir_heat.c     **** 	TCNT1H = 0;
 208               	tabn	68,0,138,.LM12-.LFBB3
 209               	.LM12:
 210 0084 1092 8500 		sts 133,__zero_reg__
 139:ir_heat.c     **** 	TCNT1L = 0;
 211               	tabn	68,0,139,.LM13-.LFBB3
 212               	.LM13:
 213 0088 1092 8400 		sts 132,__zero_reg__
 214               	/* epilogue start */
 140:ir_heat.c     **** }
 215               	abn	68,0,140,.LM14-.LFBB3
 216               	.LM14:
 217 008c 0F90      		pop r0
 218 008e 0FBE      		out __SREG__,r0
 219 0090 0F90      		pop r0
 220 0092 1F90      		pop __zero_reg__
 221 0094 1895      		reti
 223               	.Lscope3:
 225               	.global	__vector_16
 227               	__vector_16:
 141:ir_heat.c     **** 
 142:ir_heat.c     **** 
 143:ir_heat.c     **** // LED Flasher
 144:ir_heat.c     **** SIGNAL(SIG_OVERFLOW0) {
 228               	144,.LM15-.LFBB4
 229               	.LM15:
 230               	.LFBB4:
 231 0096 1F92      		push __zero_reg__
 232 0098 0F92      		push r0
 233 009a 0FB6      		in r0,__SREG__
 234 009c 0F92      		push r0
 235 009e 1124      		clr __zero_reg__
 236 00a0 2F93      		push r18
 237 00a2 3F93      		push r19
 238 00a4 4F93      		push r20
 239 00a6 8F93      		push r24
 240 00a8 9F93      		push r25
 241 00aa EF93      		push r30
 242 00ac FF93      		push r31
 243               	/* prologue: Signal */
 244               	/* frame size = 0 */
 145:ir_heat.c     **** 	static uint8_t	c1 = 0;
 146:ir_heat.c     **** 	static uint8_t c2 = 0;
 147:ir_heat.c     **** 	uint8_t slow=0;
 148:ir_heat.c     **** 	c1++;
 245               	.LM16-.LFBB4
 246               	.LM16:
 247 00ae 8091 0000 		lds r24,c1.1892
 248 00b2 282F      		mov r18,r24
 249 00b4 2F5F      		subi r18,lo8(-(1))
 250 00b6 2093 0000 		sts c1.1892,r18
 149:ir_heat.c     **** 	c2++;
 251               	n	68,0,149,.LM17-.LFBB4
 252               	.LM17:
 253 00ba 8091 0000 		lds r24,c2.1893
 254 00be 382F      		mov r19,r24
 255 00c0 3F5F      		subi r19,lo8(-(1))
 256 00c2 3093 0000 		sts c2.1893,r19
 150:ir_heat.c     **** 	
 151:ir_heat.c     **** 	// Tasten LED
 152:ir_heat.c     **** 	if (mode==MODE_TEMP_PROT) {
 257               	n	68,0,152,.LM18-.LFBB4
 258               	.LM18:
 259 00c6 4091 0000 		lds r20,mode
 260 00ca 4330      		cpi r20,lo8(3)
 261 00cc 01F4      		brne .L8
 153:ir_heat.c     **** 		if(c1 > (6<<slow)) {
 262               	bn	68,0,153,.LM19-.LFBB4
 263               	.LM19:
 264 00ce 822F      		mov r24,r18
 265 00d0 90E0      		ldi r25,lo8(0)
 266 00d2 0797      		sbiw r24,7
 267 00d4 04F0      		brlt .L8
 154:ir_heat.c     **** 			FLASH_LED_ON;
 268               	n	68,0,154,.LM20-.LFBB4
 269               	.LM20:
 270 00d6 E8E2      		ldi r30,lo8(40)
 271 00d8 F0E0      		ldi r31,hi8(40)
 272 00da 8081      		ld r24,Z
 273 00dc 8860      		ori r24,lo8(8)
 274 00de 8083      		st Z,r24
 275               	.L8:
 155:ir_heat.c     **** 		}
 156:ir_heat.c     **** 	}
 157:ir_heat.c     **** 	if(c1 > (10<<slow)) {
 276               	68,0,157,.LM21-.LFBB4
 277               	.LM21:
 278 00e0 822F      		mov r24,r18
 279 00e2 90E0      		ldi r25,lo8(0)
 280 00e4 0B97      		sbiw r24,11
 281 00e6 04F0      		brlt .L9
 158:ir_heat.c     **** 		c1 = 0;
 282               	n	68,0,158,.LM22-.LFBB4
 283               	.LM22:
 284 00e8 1092 0000 		sts c1.1892,__zero_reg__
 159:ir_heat.c     **** 		FLASH_LED_OFF;
 285               	tabn	68,0,159,.LM23-.LFBB4
 286               	.LM23:
 287 00ec E8E2      		ldi r30,lo8(40)
 288 00ee F0E0      		ldi r31,hi8(40)
 289 00f0 8081      		ld r24,Z
 290 00f2 877F      		andi r24,lo8(-9)
 291 00f4 8083      		st Z,r24
 292               	.L9:
 160:ir_heat.c     **** 	}
 161:ir_heat.c     **** 	
 162:ir_heat.c     **** 	// Status LED
 163:ir_heat.c     **** 	if (mode==MODE_ON_NO_PROT) {
 293               	68,0,163,.LM24-.LFBB4
 294               	.LM24:
 295 00f6 4230      		cpi r20,lo8(2)
 296 00f8 01F4      		brne .L10
 164:ir_heat.c     **** 		if(c2 > 120) {
 297               	abn	68,0,164,.LM25-.LFBB4
 298               	.LM25:
 299 00fa 3937      		cpi r19,lo8(121)
 300 00fc 00F0      		brlo .L10
 165:ir_heat.c     **** 			STATUS_LED1_OFF;	// rot
 301               	abn	68,0,165,.LM26-.LFBB4
 302               	.LM26:
 303 00fe EBE2      		ldi r30,lo8(43)
 304 0100 F0E0      		ldi r31,hi8(43)
 305 0102 8081      		ld r24,Z
 306 0104 8F7E      		andi r24,lo8(-17)
 307 0106 8083      		st Z,r24
 308               	.L10:
 166:ir_heat.c     **** 		}
 167:ir_heat.c     **** 	}
 168:ir_heat.c     **** 	if(c2 > 135) {
 309               	68,0,168,.LM27-.LFBB4
 310               	.LM27:
 311 0108 3838      		cpi r19,lo8(-120)
 312 010a 00F0      		brlo .L12
 169:ir_heat.c     **** 		c2 = 0;
 313               	abn	68,0,169,.LM28-.LFBB4
 314               	.LM28:
 315 010c 1092 0000 		sts c2.1893,__zero_reg__
 170:ir_heat.c     **** 		STATUS_LED1_ON; 		// orange
 316               	tabn	68,0,170,.LM29-.LFBB4
 317               	.LM29:
 318 0110 EBE2      		ldi r30,lo8(43)
 319 0112 F0E0      		ldi r31,hi8(43)
 320 0114 8081      		ld r24,Z
 321 0116 8061      		ori r24,lo8(16)
 322 0118 8083      		st Z,r24
 323               	.L12:
 324               	/* epilogue start */
 171:ir_heat.c     **** 	}	
 172:ir_heat.c     **** }
 325               	8,0,172,.LM30-.LFBB4
 326               	.LM30:
 327 011a FF91      		pop r31
 328 011c EF91      		pop r30
 329 011e 9F91      		pop r25
 330 0120 8F91      		pop r24
 331 0122 4F91      		pop r20
 332 0124 3F91      		pop r19
 333 0126 2F91      		pop r18
 334 0128 0F90      		pop r0
 335 012a 0FBE      		out __SREG__,r0
 336 012c 0F90      		pop r0
 337 012e 1F90      		pop __zero_reg__
 338 0130 1895      		reti
 344               	.Lscope4:
 346               	.global	__vector_18
 348               	__vector_18:
 173:ir_heat.c     **** 
 174:ir_heat.c     **** 
 175:ir_heat.c     **** 
 176:ir_heat.c     **** //*******************************************
 177:ir_heat.c     **** //
 178:ir_heat.c     **** // Taster IQR und Entprellung
 179:ir_heat.c     **** //
 180:ir_heat.c     **** SIGNAL(SIG_INTERRUPT0) {
 181:ir_heat.c     **** 	static uint8_t running = 0;
 182:ir_heat.c     **** 	
 183:ir_heat.c     **** 	if(running | TCNT1H | TCNT1L){
 184:ir_heat.c     **** //		printf("X");
 185:ir_heat.c     **** 		return;
 186:ir_heat.c     **** 	}
 187:ir_heat.c     **** 	running = 1;
 188:ir_heat.c     **** 	wdt_reset();
 189:ir_heat.c     **** 	
 190:ir_heat.c     **** 	uint16_t i;
 191:ir_heat.c     **** 	uint16_t c = 0;
 192:ir_heat.c     **** 	EIMSK = 0;
 193:ir_heat.c     **** 	sei();
 194:ir_heat.c     **** 	//printf("In");
 195:ir_heat.c     **** 	for(i=0;i<1000;i++) if((PIND & (1<<SWITCH))) c++;
 196:ir_heat.c     **** 	//printf(" %i ", c);
 197:ir_heat.c     **** 
 198:ir_heat.c     **** 	if(c < 200) {
 199:ir_heat.c     **** 		TCNT1L = 1;
 200:ir_heat.c     **** 		TIMER1_RUN;
 201:ir_heat.c     **** 		switch(mode) {
 202:ir_heat.c     **** 		case MODE_OFF:
 203:ir_heat.c     **** 			mode = MODE_ON;
 204:ir_heat.c     **** 			set_relais(1);
 205:ir_heat.c     **** 			STATUS_LED1_ON;			// orange
 206:ir_heat.c     **** 			STATUS_LED2_ON;
 207:ir_heat.c     **** 			c = 0;
 208:ir_heat.c     **** 			while((!(PIND & (1<<SWITCH))) && (c < 300)) {
 209:ir_heat.c     **** 				c++;
 210:ir_heat.c     **** 				_delay_ms (10);
 211:ir_heat.c     **** 			}
 212:ir_heat.c     **** 			//printf("c: %i", c);
 213:ir_heat.c     **** 
 214:ir_heat.c     **** 			if(c < 300) {
 215:ir_heat.c     **** 				// normal einnschalten
 216:ir_heat.c     **** 				mode = MODE_ON;
 217:ir_heat.c     **** 			}
 218:ir_heat.c     **** 			else {
 219:ir_heat.c     **** 				// einschalten, aber ohne Hitzeschutz
 220:ir_heat.c     **** 				mode = MODE_ON_NO_PROT;
 221:ir_heat.c     **** 				printf("Temperature Protection Off!\n");
 222:ir_heat.c     **** 				STATUS_LED1_OFF;		// rot
 223:ir_heat.c     **** 				STATUS_LED2_ON;
 224:ir_heat.c     **** 				beep(BEEP_SHORT_LONG);
 225:ir_heat.c     **** 			}
 226:ir_heat.c     **** 			break;
 227:ir_heat.c     **** 		case MODE_ON:
 228:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 229:ir_heat.c     **** 		case MODE_TEMP_PROT:
 230:ir_heat.c     **** 		default:
 231:ir_heat.c     **** 			printf("\nxXx\n");
 232:ir_heat.c     **** 			mode = MODE_OFF;
 233:ir_heat.c     **** 		}
 234:ir_heat.c     **** 	}
 235:ir_heat.c     **** //	printf("Out\n");
 236:ir_heat.c     **** 	EIFR 		= (1<<INTF0);
 237:ir_heat.c     **** 	EIMSK 	= (1<<INT0);
 238:ir_heat.c     **** 	running 	= 0;
 239:ir_heat.c     **** 	//printf("Exit\n");
 240:ir_heat.c     **** }
 241:ir_heat.c     **** 
 242:ir_heat.c     **** 
 243:ir_heat.c     **** 
 244:ir_heat.c     **** SIGNAL(SIG_USART_RECV) {
 349               	LFBB5
 350               	.LM31:
 351               	.LFBB5:
 352 0132 1F92      		push __zero_reg__
 353 0134 0F92      		push r0
 354 0136 0FB6      		in r0,__SREG__
 355 0138 0F92      		push r0
 356 013a 1124      		clr __zero_reg__
 357 013c 8F93      		push r24
 358 013e EF93      		push r30
 359 0140 FF93      		push r31
 360               	/* prologue: Signal */
 361               	/* frame size = 0 */
 245:ir_heat.c     **** //******************
 246:ir_heat.c     **** // RX interrupt handler
 247:ir_heat.c     **** //
 248:ir_heat.c     **** 	char c;	
 249:ir_heat.c     **** 	c = UDR0;							// Get received char
 362               	249,.LM32-.LFBB5
 363               	.LM32:
 364 0142 8091 C600 		lds r24,198
 250:ir_heat.c     **** 	rbuf[r_in & RMASK] = c;
 365               	tabn	68,0,250,.LM33-.LFBB5
 366               	.LM33:
 367 0146 E091 0000 		lds r30,r_in
 368 014a F0E0      		ldi r31,lo8(0)
 369 014c EF71      		andi r30,lo8(31)
 370 014e F070      		andi r31,hi8(31)
 371 0150 E050      		subi r30,lo8(-(rbuf))
 372 0152 F040      		sbci r31,hi8(-(rbuf))
 373 0154 8083      		st Z,r24
 251:ir_heat.c     **** 	r_in++;
 374               	8,0,251,.LM34-.LFBB5
 375               	.LM34:
 376 0156 8091 0000 		lds r24,r_in
 377 015a 8F5F      		subi r24,lo8(-(1))
 378 015c 8093 0000 		sts r_in,r24
 379               	/* epilogue start */
 252:ir_heat.c     **** }
 380               	n	68,0,252,.LM35-.LFBB5
 381               	.LM35:
 382 0160 FF91      		pop r31
 383 0162 EF91      		pop r30
 384 0164 8F91      		pop r24
 385 0166 0F90      		pop r0
 386 0168 0FBE      		out __SREG__,r0
 387 016a 0F90      		pop r0
 388 016c 1F90      		pop __zero_reg__
 389 016e 1895      		reti
 394               	.Lscope5:
 396               	.global	__vector_19
 398               	__vector_19:
 253:ir_heat.c     **** 
 254:ir_heat.c     **** SIGNAL(SIG_USART_DATA) {
 399               	M36-.LFBB6
 400               	.LM36:
 401               	.LFBB6:
 402 0170 1F92      		push __zero_reg__
 403 0172 0F92      		push r0
 404 0174 0FB6      		in r0,__SREG__
 405 0176 0F92      		push r0
 406 0178 1124      		clr __zero_reg__
 407 017a 8F93      		push r24
 408 017c 9F93      		push r25
 409 017e EF93      		push r30
 410 0180 FF93      		push r31
 411               	/* prologue: Signal */
 412               	/* frame size = 0 */
 255:ir_heat.c     **** //*******************
 256:ir_heat.c     **** // Data register empty interrupt handler.
 257:ir_heat.c     **** // Indicates that next char can be transmitted
 258:ir_heat.c     **** //
 259:ir_heat.c     **** 	if(t_in != t_out) {
 413               	59,.LM37-.LFBB6
 414               	.LM37:
 415 0182 9091 0000 		lds r25,t_in
 416 0186 8091 0000 		lds r24,t_out
 417 018a 9817      		cp r25,r24
 418 018c 01F0      		breq .L16
 260:ir_heat.c     **** 		UDR0 = tbuf[t_out & TMASK];
 419               	n	68,0,260,.LM38-.LFBB6
 420               	.LM38:
 421 018e E091 0000 		lds r30,t_out
 422 0192 F0E0      		ldi r31,lo8(0)
 423 0194 EF71      		andi r30,lo8(31)
 424 0196 F070      		andi r31,hi8(31)
 425 0198 E050      		subi r30,lo8(-(tbuf))
 426 019a F040      		sbci r31,hi8(-(tbuf))
 427 019c 8081      		ld r24,Z
 428 019e 8093 C600 		sts 198,r24
 261:ir_heat.c     **** 		t_out++;	
 429               	,0,261,.LM39-.LFBB6
 430               	.LM39:
 431 01a2 8091 0000 		lds r24,t_out
 432 01a6 8F5F      		subi r24,lo8(-(1))
 433 01a8 8093 0000 		sts t_out,r24
 434 01ac 00C0      		rjmp .L18
 435               	.L16:
 262:ir_heat.c     **** 	}
 263:ir_heat.c     **** 	else {
 264:ir_heat.c     **** 		UCSR0B &= ~(1<<UDRIE0);
 436               		68,0,264,.LM40-.LFBB6
 437               	.LM40:
 438 01ae E1EC      		ldi r30,lo8(193)
 439 01b0 F0E0      		ldi r31,hi8(193)
 440 01b2 8081      		ld r24,Z
 441 01b4 8F7D      		andi r24,lo8(-33)
 442 01b6 8083      		st Z,r24
 443               	.L18:
 444               	/* epilogue start */
 265:ir_heat.c     **** 	}
 266:ir_heat.c     **** }
 445               	8,0,266,.LM41-.LFBB6
 446               	.LM41:
 447 01b8 FF91      		pop r31
 448 01ba EF91      		pop r30
 449 01bc 9F91      		pop r25
 450 01be 8F91      		pop r24
 451 01c0 0F90      		pop r0
 452 01c2 0FBE      		out __SREG__,r0
 453 01c4 0F90      		pop r0
 454 01c6 1F90      		pop __zero_reg__
 455 01c8 1895      		reti
 457               	.Lscope6:
 459               	.global	tbuflen
 461               	tbuflen:
 267:ir_heat.c     **** 
 268:ir_heat.c     **** char tbuflen(void) {
 462               	.LM42-.LFBB7
 463               	.LM42:
 464               	.LFBB7:
 465               	/* prologue: function */
 466               	/* frame size = 0 */
 269:ir_heat.c     **** //****************
 270:ir_heat.c     **** // Retrieve pending chars in TX buffer
 271:ir_heat.c     **** //
 272:ir_heat.c     **** 	return(t_in - t_out);
 467               	bn	68,0,272,.LM43-.LFBB7
 468               	.LM43:
 469 01ca 8091 0000 		lds r24,t_in
 470 01ce 9091 0000 		lds r25,t_out
 273:ir_heat.c     **** }
 471               	abn	68,0,273,.LM44-.LFBB7
 472               	.LM44:
 473 01d2 891B      		sub r24,r25
 474               	/* epilogue start */
 475 01d4 0895      		ret
 477               	.Lscope7:
 481               	.global	UART_putchar
 483               	UART_putchar:
 274:ir_heat.c     **** 
 275:ir_heat.c     **** int UART_putchar(char c, FILE *stream) {
 484               	275,.LM45-.LFBB8
 485               	.LM45:
 486               	.LFBB8:
 487 01d6 1F93      		push r17
 488 01d8 CF93      		push r28
 489 01da DF93      		push r29
 490               	/* prologue: function */
 491               	/* frame size = 0 */
 492 01dc 182F      		mov r17,r24
 276:ir_heat.c     **** //*********************
 277:ir_heat.c     **** // Fills the transmit buffer, if it is full wait
 278:ir_heat.c     **** //
 279:ir_heat.c     **** 	while((TBUFSIZE - tbuflen()) <= 2);  // Wait...
 493               	8,0,279,.LM46-.LFBB8
 494               	.LM46:
 495 01de C0E2      		ldi r28,lo8(32)
 496 01e0 D0E0      		ldi r29,hi8(32)
 497               	.L22:
 498 01e2 0E94 0000 		call tbuflen
 499 01e6 9E01      		movw r18,r28
 500 01e8 281B      		sub r18,r24
 501 01ea 3109      		sbc r19,__zero_reg__
 502 01ec 2330      		cpi r18,3
 503 01ee 3105      		cpc r19,__zero_reg__
 504 01f0 04F0      		brlt .L22
 280:ir_heat.c     **** 	
 281:ir_heat.c     **** 	// Add data to the transmit buffer, enable TXCIE
 282:ir_heat.c     **** 	//
 283:ir_heat.c     **** 	tbuf[t_in & TMASK] = c;
 505               	,283,.LM47-.LFBB8
 506               	.LM47:
 507 01f2 E091 0000 		lds r30,t_in
 508 01f6 F0E0      		ldi r31,lo8(0)
 509 01f8 EF71      		andi r30,lo8(31)
 510 01fa F070      		andi r31,hi8(31)
 511 01fc E050      		subi r30,lo8(-(tbuf))
 512 01fe F040      		sbci r31,hi8(-(tbuf))
 513 0200 1083      		st Z,r17
 284:ir_heat.c     **** 	t_in++;	
 514               	8,0,284,.LM48-.LFBB8
 515               	.LM48:
 516 0202 8091 0000 		lds r24,t_in
 517 0206 8F5F      		subi r24,lo8(-(1))
 518 0208 8093 0000 		sts t_in,r24
 285:ir_heat.c     **** 	UCSR0B |= (1<<UDRIE0);			// Enable UDR empty interrupt	
 519               	bn	68,0,285,.LM49-.LFBB8
 520               	.LM49:
 521 020c E1EC      		ldi r30,lo8(193)
 522 020e F0E0      		ldi r31,hi8(193)
 523 0210 8081      		ld r24,Z
 524 0212 8062      		ori r24,lo8(32)
 525 0214 8083      		st Z,r24
 286:ir_heat.c     **** 	return(0);
 287:ir_heat.c     **** }
 526               		68,0,287,.LM50-.LFBB8
 527               	.LM50:
 528 0216 80E0      		ldi r24,lo8(0)
 529 0218 90E0      		ldi r25,hi8(0)
 530               	/* epilogue start */
 531 021a DF91      		pop r29
 532 021c CF91      		pop r28
 533 021e 1F91      		pop r17
 534 0220 0895      		ret
 536               	.Lscope8:
 538               	.global	rbuflen
 540               	rbuflen:
 288:ir_heat.c     **** 
 289:ir_heat.c     **** char rbuflen(void) {
 541               	9,.LM51-.LFBB9
 542               	.LM51:
 543               	.LFBB9:
 544               	/* prologue: function */
 545               	/* frame size = 0 */
 290:ir_heat.c     **** // ***************
 291:ir_heat.c     **** // Retrive pending chars in RX buffer
 292:ir_heat.c     **** //
 293:ir_heat.c     **** 	return(r_in - r_out);
 546               	bn	68,0,293,.LM52-.LFBB9
 547               	.LM52:
 548 0222 8091 0000 		lds r24,r_in
 549 0226 9091 0000 		lds r25,r_out
 294:ir_heat.c     **** }
 550               	abn	68,0,294,.LM53-.LFBB9
 551               	.LM53:
 552 022a 891B      		sub r24,r25
 553               	/* epilogue start */
 554 022c 0895      		ret
 556               	.Lscope9:
 559               	.global	UART_getchar
 561               	UART_getchar:
 295:ir_heat.c     **** 
 296:ir_heat.c     **** int UART_getchar(FILE *stream) {
 562               	,296,.LM54-.LFBB10
 563               	.LM54:
 564               	.LFBB10:
 565               	/* prologue: function */
 566               	/* frame size = 0 */
 567               	.L28:
 297:ir_heat.c     **** //*******************
 298:ir_heat.c     **** // Retieves character from UART. This function is to be passed
 299:ir_heat.c     **** // to fdevopen
 300:ir_heat.c     **** //
 301:ir_heat.c     **** 	unsigned char c;
 302:ir_heat.c     **** 	while(rbuflen() == 0);	  // Wait...
 568               	n	68,0,302,.LM55-.LFBB10
 569               	.LM55:
 570 022e 0E94 0000 		call rbuflen
 571 0232 8823      		tst r24
 572 0234 01F0      		breq .L28
 303:ir_heat.c     **** 	c = rbuf[r_out & RMASK];
 573               	bn	68,0,303,.LM56-.LFBB10
 574               	.LM56:
 575 0236 E091 0000 		lds r30,r_out
 576 023a F0E0      		ldi r31,lo8(0)
 577 023c EF71      		andi r30,lo8(31)
 578 023e F070      		andi r31,hi8(31)
 579 0240 E050      		subi r30,lo8(-(rbuf))
 580 0242 F040      		sbci r31,hi8(-(rbuf))
 581 0244 8081      		ld r24,Z
 304:ir_heat.c     **** 	r_out++;	
 582               	8,0,304,.LM57-.LFBB10
 583               	.LM57:
 584 0246 9091 0000 		lds r25,r_out
 585 024a 9F5F      		subi r25,lo8(-(1))
 586 024c 9093 0000 		sts r_out,r25
 305:ir_heat.c     **** 	return(c);
 306:ir_heat.c     **** }
 587               	bn	68,0,306,.LM58-.LFBB10
 588               	.LM58:
 589 0250 90E0      		ldi r25,lo8(0)
 590               	/* epilogue start */
 591 0252 0895      		ret
 596               	.Lscope10:
 599               	.global	exp_slope
 601               	exp_slope:
 307:ir_heat.c     **** 
 308:ir_heat.c     **** void UART_first_init(void) {
 309:ir_heat.c     **** //***********************
 310:ir_heat.c     **** // The function fdevopen(..) must contain as parameters the
 311:ir_heat.c     **** // corresponding  ..putchar() and  ..getchar() functions, defined before.
 312:ir_heat.c     **** //
 313:ir_heat.c     **** 	UBRR0 = 12;										 		// 4800 BPS
 314:ir_heat.c     **** 	
 315:ir_heat.c     **** 	//UCSR0A |= (1<<U2X0);
 316:ir_heat.c     **** 	UCSR0B = (1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0);	// 8 Databits, receive and transmit enabled, receive a
 317:ir_heat.c     **** 	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
 318:ir_heat.c     **** 	
 319:ir_heat.c     **** 	fdevopen(UART_putchar, UART_getchar);
 320:ir_heat.c     **** 	sei();											 		// Global interrupt enable
 321:ir_heat.c     **** }
 322:ir_heat.c     **** 
 323:ir_heat.c     **** 
 324:ir_heat.c     **** 
 325:ir_heat.c     **** 
 326:ir_heat.c     **** int16_t exp_slope(int16_t temp) {
 602               	6,.LM59-.LFBB11
 603               	.LM59:
 604               	.LFBB11:
 605               	/* prologue: function */
 606               	/* frame size = 0 */
 608               	.LM60:
 609 0254 2227      		clr r18
 610 0256 3327      		clr r19
 611 0258 281B      		sub r18,r24
 612 025a 390B      		sbc r19,r25
 613 025c 02F4      		brpl .L32
 614 025e 215F      		subi r18,lo8(-(15))
 615 0260 3F4F      		sbci r19,hi8(-(15))
 616               	.L32:
 617 0262 C901      		movw r24,r18
 618 0264 9595      		asr r25
 619 0266 8795      		ror r24
 620 0268 9595      		asr r25
 621 026a 8795      		ror r24
 622 026c 9595      		asr r25
 623 026e 8795      		ror r24
 624 0270 9595      		asr r25
 625 0272 8795      		ror r24
 626 0274 9C01      		movw r18,r24
 627 0276 220F      		lsl r18
 628 0278 331F      		rol r19
 629 027a 880F      		lsl r24
 630 027c 991F      		rol r25
 631 027e 880F      		lsl r24
 632 0280 991F      		rol r25
 633 0282 880F      		lsl r24
 634 0284 991F      		rol r25
 635 0286 280F      		add r18,r24
 636 0288 391F      		adc r19,r25
 637 028a 215B      		subi r18,lo8(-(335))
 638 028c 3E4F      		sbci r19,hi8(-(335))
 327:ir_heat.c     **** 	return 10 * (-temp/16 + 32) + 15;
 328:ir_heat.c     **** }
 639               	
 640               		mov r24,r18
 641 028e 822F      		mov r25,r19
 642 0290 932F      	/* epilogue start */
 643               		ret
 645               	.Lscope11:
 647               	.global	get_slope2
 649               	get_slope2:
 329:ir_heat.c     **** 
 330:ir_heat.c     **** 
 331:ir_heat.c     **** int16_t get_slope2() {
 651               	B12:
 652               	/* prologue: function */
 653               	/* frame size = 0 */
 655               	.LM63:
 332:ir_heat.c     **** 	static int16_t last_slope = 0;
 333:ir_heat.c     **** //	last_slope = (200*(t_array[5]-t_array[2]) / 16 +  2*last_slope) / 3;
 334:ir_heat.c     **** 	last_slope = (16*(t_array[5]-t_array[2]) +  2*last_slope) / 3;
 656               	r24,t_array+10
 657               		lds r25,(t_array+10)+1
 658 0294 8091 0000 		lds r18,t_array+4
 659 0298 9091 0000 		lds r19,(t_array+4)+1
 660 029c 2091 0000 		sub r24,r18
 661 02a0 3091 0000 		sbc r25,r19
 662 02a4 821B      		lsl r24
 663 02a6 930B      		rol r25
 664 02a8 880F      		lsl r24
 665 02aa 991F      		rol r25
 666 02ac 880F      		lsl r24
 667 02ae 991F      		rol r25
 668 02b0 880F      		lds r18,last_slope.2051
 669 02b2 991F      		lds r19,(last_slope.2051)+1
 670 02b4 2091 0000 		add r24,r18
 671 02b8 3091 0000 		adc r25,r19
 672 02bc 820F      		lsl r24
 673 02be 931F      		rol r25
 674 02c0 880F      		ldi r22,lo8(3)
 675 02c2 991F      		ldi r23,hi8(3)
 676 02c4 63E0      		call __divmodhi4
 677 02c6 70E0      		mov r24,r22
 678 02c8 0E94 0000 		mov r25,r23
 679 02cc 862F      		sts last_slope.2051,r22
 680 02ce 972F      		sts last_slope.2051+1,r23
 681 02d0 6093 0000 	/* epilogue start */
 683               	.LM64:
 335:ir_heat.c     **** 	return last_slope;
 336:ir_heat.c     **** }
 684               	t_slope2
 688               	.Lscope12:
 690               	.global	add_value
 692               	add_value:
 694               	.LM65:
 695               	.LFBB13:
 337:ir_heat.c     **** 
 338:ir_heat.c     **** 
 339:ir_heat.c     **** 
 340:ir_heat.c     **** 
 341:ir_heat.c     **** //*********************************************
 342:ir_heat.c     **** //
 343:ir_heat.c     **** // Gibt den Temperatur Ringspeicher
 344:ir_heat.c     **** // über den UART aus
 345:ir_heat.c     **** //
 346:ir_heat.c     **** void print_array(){
 347:ir_heat.c     **** 	uint8_t i;
 348:ir_heat.c     ****   	printf("Array:");
 349:ir_heat.c     **** 	for(i=0;i<6;i++) {
 350:ir_heat.c     ****    	printf(" %i", t_array[i]);
 351:ir_heat.c     **** 	}
 352:ir_heat.c     ****   	printf("\n");
 353:ir_heat.c     **** }
 354:ir_heat.c     **** 
 355:ir_heat.c     **** 
 356:ir_heat.c     **** 
 357:ir_heat.c     **** //*********************************************
 358:ir_heat.c     **** //
 359:ir_heat.c     **** // Fügt einen Meßwert zum Ringspeicher hinzu
 360:ir_heat.c     **** // Der Ringspeicher enthält die letzten 6 Werte
 361:ir_heat.c     **** // t_array[5] ist der neuste Wert
 362:ir_heat.c     **** //
 363:ir_heat.c     **** void add_value(uint16_t value) {
 696               	 function */
 697               	/* frame size = 0 */
 698               		mov r20,r24
 699               		mov r21,r25
 701 02da 482F      	.LM66:
 702 02dc 592F      		lds r24,t_array
 364:ir_heat.c     **** 	uint8_t i;
 365:ir_heat.c     **** 	if(t_array[0]==0) {
 703               	5,(t_array)+1
 704               		or r24,r25
 705 02de 8091 0000 		brne .L37
 707 02e6 892B      	.LM67:
 708 02e8 01F4      		ldi r30,lo8(t_array+10)
 366:ir_heat.c     **** 		t_array[0]=t_array[1]=t_array[2]=t_array[3]=t_array[4]=t_array[5]=value;
 709               	31,hi8(t_array+10)
 710               		st Z,r20
 711 02ea E0E0      		std Z+1,r21
 712 02ec F0E0      		movw r26,r30
 713 02ee 4083      		sbiw r26,2
 714 02f0 5183      		st X,r20
 715 02f2 DF01      		adiw r26,1
 716 02f4 1297      		st X,r21
 717 02f6 4C93      		movw r26,r30
 718 02f8 1196      		sbiw r26,4
 719 02fa 5C93      		st X,r20
 720 02fc DF01      		adiw r26,1
 721 02fe 1497      		st X,r21
 722 0300 4C93      		movw r26,r30
 723 0302 1196      		sbiw r26,6
 724 0304 5C93      		st X,r20
 725 0306 DF01      		adiw r26,1
 726 0308 1697      		st X,r21
 727 030a 4C93      		movw r26,r30
 728 030c 1196      		sbiw r26,8
 729 030e 5C93      		st X,r20
 730 0310 DF01      		adiw r26,1
 731 0312 1897      		st X,r21
 732 0314 4C93      		sbiw r30,10
 733 0316 1196      		st Z,r20
 734 0318 5C93      		std Z+1,r21
 735 031a 3A97      		ret
 736 031c 4083      	.L37:
 737 031e 5183      		ldi r30,lo8(t_array)
 738 0320 0895      		ldi r31,hi8(t_array)
 740 0322 E0E0      	.LM68:
 741 0324 F0E0      		ldi r18,lo8(t_array+10)
 367:ir_heat.c     **** 	}
 368:ir_heat.c     **** 	else {
 369:ir_heat.c     **** 		for(i=0;i<5;i++) {
 742               	stabn	68,0,370,.LM69-.LFBB13
 743               	.LM69:
 744 0326 20E0      		ldd r24,Z+2
 745 0328 30E0      		ldd r25,Z+3
 746               		st Z+,r24
 370:ir_heat.c     **** 			t_array[i]=t_array[i+1];
 747               	+,r25
 749 032a 8281      	.LM70:
 750 032c 9381      		cp r30,r18
 751 032e 8193      		cpc r31,r19
 752 0330 9193      		brne .L39
 754               	.LM71:
 755 0332 E217      		mov r18,r20
 756 0334 F307      		mov r19,r21
 757 0336 01F4      		sts (t_array+10)+1,r19
 371:ir_heat.c     **** 		}
 372:ir_heat.c     **** 		t_array[5] = value;
 758               	y+10,r18
 760 0338 242F      	.LM72:
 761 033a 352F      		lds r24,t_array+8
 762 033c 3093 0000 		lds r25,(t_array+8)+1
 763 0340 2093 0000 		sub r18,r24
 373:ir_heat.c     **** 		slope2 = (10*(t_array[5]-t_array[4]) + 19*slope2) / 20;
 764               	19,r25
 765               		movw r24,r18
 766 0344 8091 0000 		lsl r24
 767 0348 9091 0000 		rol r25
 768 034c 281B      		lsl r18
 769 034e 390B      		rol r19
 770 0350 C901      		lsl r18
 771 0352 880F      		rol r19
 772 0354 991F      		lsl r18
 773 0356 220F      		rol r19
 774 0358 331F      		add r24,r18
 775 035a 220F      		adc r25,r19
 776 035c 331F      		lds r22,slope2
 777 035e 220F      		lds r23,(slope2)+1
 778 0360 331F      		movw r18,r22
 779 0362 820F      		lsl r18
 780 0364 931F      		rol r19
 781 0366 6091 0000 		movw r20,r18
 782 036a 7091 0000 		lsl r20
 783 036e 9B01      		rol r21
 784 0370 220F      		lsl r20
 785 0372 331F      		rol r21
 786 0374 A901      		lsl r20
 787 0376 440F      		rol r21
 788 0378 551F      		add r18,r20
 789 037a 440F      		adc r19,r21
 790 037c 551F      		add r18,r22
 791 037e 440F      		adc r19,r23
 792 0380 551F      		add r24,r18
 793 0382 240F      		adc r25,r19
 794 0384 351F      		ldi r22,lo8(20)
 795 0386 260F      		ldi r23,hi8(20)
 796 0388 371F      		call __divmodhi4
 797 038a 820F      		sts (slope2)+1,r23
 798 038c 931F      		sts slope2,r22
 799 038e 64E1      		ret
 801 0392 0E94 0000 	.Lscope13:
 803 039a 6093 0000 	.global	get_slope
 805               	get_slope:
 807               	.LM73:
 808               	.LFBB14:
 809               	/* prologue: function */
 810               	/* frame size = 0 */
 374:ir_heat.c     **** 	}
 375:ir_heat.c     **** }
 376:ir_heat.c     **** 
 377:ir_heat.c     **** 
 378:ir_heat.c     **** 
 379:ir_heat.c     **** //********************************************
 380:ir_heat.c     **** //
 381:ir_heat.c     **** // Gibt die gemittelte Steigung
 382:ir_heat.c     **** // über die letzten 4 Sekunden zurück
 383:ir_heat.c     **** //
 384:ir_heat.c     **** int16_t get_slope() {
 811               	lo8(t_array+8)
 812               		ldi r27,hi8(t_array+8)
 813               		movw r30,r26
 814               		ld r18,Z+
 815               		ld r19,Z+
 816               		lds r24,t_array+2
 817               		lds r25,(t_array+2)+1
 818 03a0 A0E0      		sub r18,r24
 819 03a2 B0E0      		sbc r19,r25
 820 03a4 FD01      		movw r24,r18
 821 03a6 2191      		lsl r24
 822 03a8 3191      		rol r25
 823 03aa 8091 0000 		lsl r24
 824 03ae 9091 0000 		rol r25
 825 03b2 281B      		add r24,r18
 826 03b4 390B      		adc r25,r19
 827 03b6 C901      		sbiw r26,8
 828 03b8 880F      		ld r20,Z
 829 03ba 991F      		ldd r21,Z+1
 830 03bc 880F      		ld r18,X+
 831 03be 991F      		ld r19,X
 832 03c0 820F      		sbiw r26,1
 833 03c2 931F      		sub r20,r18
 834 03c4 1897      		sbc r21,r19
 835 03c6 4081      		movw r18,r20
 836 03c8 5181      		lsl r18
 837 03ca 2D91      		rol r19
 838 03cc 3C91      		add r18,r20
 839 03ce 1197      		adc r19,r21
 840 03d0 421B      		add r24,r18
 841 03d2 530B      		adc r25,r19
 842 03d4 9A01      		adiw r26,6
 843 03d6 220F      		ld r20,X+
 844 03d8 331F      		ld r21,X
 845 03da 240F      		sbiw r26,6+1
 846 03dc 351F      		adiw r26,4
 847 03de 820F      		ld r18,X+
 848 03e0 931F      		ld r19,X
 849 03e2 1696      		sbiw r26,4+1
 850 03e4 4D91      		sub r20,r18
 851 03e6 5C91      		sbc r21,r19
 852 03e8 1797      		movw r18,r20
 853 03ea 1496      		lsl r18
 854 03ec 2D91      		rol r19
 855 03ee 3C91      		add r18,r20
 856 03f0 1597      		adc r19,r21
 857 03f2 421B      		movw r20,r18
 858 03f4 530B      		lsl r20
 859 03f6 9A01      		rol r21
 860 03f8 220F      		lsl r20
 861 03fa 331F      		rol r21
 862 03fc 240F      		add r18,r20
 863 03fe 351F      		adc r19,r21
 864 0400 A901      		add r24,r18
 865 0402 440F      		adc r25,r19
 866 0404 551F      		ldi r22,lo8(9)
 867 0406 440F      		ldi r23,hi8(9)
 868 0408 551F      		call __divmodhi4
 869 040a 240F      		mov r24,r22
 870 040c 351F      		mov r25,r23
 871 040e 820F      	/* epilogue start */
 873 0412 69E0      	.LM75:
 874 0414 70E0      		ret
 876 041a 862F      	.Lscope14:
 878               	.global	get_last_slope
 385:ir_heat.c     **** 	int16_t s1, s2, s3;
 386:ir_heat.c     **** 
 387:ir_heat.c     **** 	s1 = t_array[5] - t_array[0];
 388:ir_heat.c     **** 	s2 = t_array[4] - t_array[1];
 389:ir_heat.c     **** 	s3 = t_array[3] - t_array[2];
 390:ir_heat.c     **** 	
 391:ir_heat.c     **** 	return ((3*s1+5*s2+15*s3)/9);
 392:ir_heat.c     **** }
 879               	M76-.LFBB15
 880               	.LM76:
 881 041e 0895      	.LFBB15:
 882               	/* prologue: function */
 883               	/* frame size = 0 */
 885               	.LM77:
 886               		lds r18,t_array+10
 887               		lds r19,(t_array+10)+1
 393:ir_heat.c     **** 
 394:ir_heat.c     **** 
 395:ir_heat.c     **** 
 396:ir_heat.c     **** //********************************************
 397:ir_heat.c     **** //
 398:ir_heat.c     **** // Gibt die aktuelle Steigung der Temperatur zurück
 399:ir_heat.c     **** // in 0.1°C in 4s
 400:ir_heat.c     **** //
 401:ir_heat.c     **** int16_t	get_last_slope() {
 888               	t_array+8
 889               		lds r25,(t_array+8)+1
 890               		sub r18,r24
 891               		sbc r19,r25
 893               	.LM78:
 894               		mov r24,r18
 895 0420 2091 0000 		mov r25,r19
 896 0424 3091 0000 	/* epilogue start */
 897 0428 8091 0000 		ret
 899 0430 281B      	.Lscope15:
 402:ir_heat.c     ****     return (t_array[5] - t_array[4]);
 403:ir_heat.c     **** }
 901               	tion_ms:P(4,4)",64,0,0,24
 902               	.global	_beep
 904 0436 932F      	_beep:
 906 0438 0895      	.LM79:
 907               	.LFBB16:
 908               	/* prologue: function */
 909               	/* frame size = 0 */
 911               	.LM80:
 912               		ldi r30,lo8(37)
 913               		ldi r31,hi8(37)
 404:ir_heat.c     **** 
 405:ir_heat.c     **** 
 406:ir_heat.c     **** 
 407:ir_heat.c     **** //********************************************
 408:ir_heat.c     **** //
 409:ir_heat.c     **** // Liest die vom MLX90614 gemessene Temperatur aus
 410:ir_heat.c     **** // Rückgabe in 0.1°C, also 215 = 21.5°C
 411:ir_heat.c     **** //
 412:ir_heat.c     **** uint16_t get_temperature(uint8_t adr) {
 413:ir_heat.c     **** 	uint16_t raw;
 414:ir_heat.c     **** 	uint8_t 	ret;
 415:ir_heat.c     **** 	uint8_t 	lo, hi, pec;
 416:ir_heat.c     **** 	uint8_t	pec_read[6];
 417:ir_heat.c     **** 
 418:ir_heat.c     **** 	if(i2c_start(MLX90614_WRITE)) return DEFAULT_TEMP;
 419:ir_heat.c     **** 	if(i2c_write(adr)) return DEFAULT_TEMP;
 420:ir_heat.c     **** 	
 421:ir_heat.c     **** 	ret = i2c_rep_start(MLX90614_READ);
 422:ir_heat.c     **** 	if(ret) {
 423:ir_heat.c     **** 		i2c_rep_start(MLX90614_READ);
 424:ir_heat.c     ****    }
 425:ir_heat.c     **** 
 426:ir_heat.c     **** 	lo = i2c_readAck();
 427:ir_heat.c     **** 	hi = i2c_readAck();
 428:ir_heat.c     **** 	raw = (uint16_t)(hi<<8)+lo;
 429:ir_heat.c     **** 	pec = i2c_readAck();
 430:ir_heat.c     **** 	
 431:ir_heat.c     **** 	i2c_stop();
 432:ir_heat.c     **** 	
 433:ir_heat.c     **** 	if(raw & 0x8000) return DEFAULT_TEMP;
 434:ir_heat.c     **** 	
 435:ir_heat.c     **** 	return (raw / 5 - 2731); 					// 1 = 0.1°C
 436:ir_heat.c     **** }
 437:ir_heat.c     **** 
 438:ir_heat.c     **** 
 439:ir_heat.c     **** 
 440:ir_heat.c     **** void _beep(uint16_t duration_ms){
 914               	i r18,lo8(-128)
 915               		st Z,r18
 917               	.LM81:
 918               		ldi r22,lo8(20)
 441:ir_heat.c     **** 	uint16_t i;
 442:ir_heat.c     **** 	BUZZER_ON;
 919               	r23,hi8(20)
 920               		call __udivmodhi4
 921 043a E5E2      		mov r24,r22
 922 043c F0E0      		mov r25,r23
 923 043e 2081      		sbiw r24,0
 924 0440 2068      		breq .L47
 925 0442 2083      		ldi r18,lo8(0)
 443:ir_heat.c     **** 	for(i=0;i<(duration_ms/20);i++) _delay_ms(20);
 926               	9,hi8(0)
 927               	.LBB37:
 928 0444 64E1      	.LBB38:
 929 0446 70E0      	.LBB39:
 930 0448 0E94 0000 	.LBB40:
 932 044e 972F      	.Ltext1:
 934 0452 01F0      	.LM82:
 935 0454 20E0      		ldi r20,lo8(10000)
 936 0456 30E0      		ldi r21,hi8(10000)
 937               	.L48:
 938               		movw r30,r20
 939               	/* #APP */
 940               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 941               		1: sbiw r30,1
 942               		brne 1b
   1:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   5:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   8:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  11:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      distribution.
  15:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  16:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  20:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  32:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  34:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  37:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  39:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \file */
  40:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \code
  42:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \endcode
  44:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  45:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  53:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  60:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  62:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  63:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  64:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #endif
  68:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  69:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  71:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     register.
  76:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  77:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     can be achieved.
  79:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  80:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
  81:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
  83:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	);
  89:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** }
  90:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  91:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  93:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     counter register pair.
  98:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  99:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****  */
 102:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
 103:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
 105:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 943               	APP */
 944               	.LBE40:
 945 0458 40E1      	.LBE39:
 946 045a 57E2      	.LBE38:
 947               	.LBE37:
 949               	.Ltext2:
 951 045e 3197      	.LM83:
 952 0460 01F4      		subi r18,lo8(-(1))
 953               		sbci r19,hi8(-(1))
 954               		cp r18,r24
 955               		cpc r19,r25
 956               		brlo .L48
 957               	.L47:
 959               	.LM84:
 960               		ldi r30,lo8(37)
 961               		ldi r31,hi8(37)
 962               		ld r24,Z
 963 0462 2F5F      		andi r24,lo8(127)
 964 0464 3F4F      		st Z,r24
 965 0466 2817      	/* epilogue start */
 967 046a 00F0      	.LM85:
 968               		ret
 444:ir_heat.c     **** 	BUZZER_OFF;
 969               	abs	"i:r(4,4)",64,0,0,18
 972 046e F0E0      	.Lscope16:
 973 0470 8081      		.data
 974 0472 8F77      	.LC0:
 975 0474 8083      		.string	">>> Relais ON"
 976               	.LC1:
 445:ir_heat.c     **** }
 977               		">>> Relais OFF"
 978               		.text
 981               	.global	set_relais
 983               	set_relais:
 985               	.LM86:
 986               	.LFBB17:
 987 0000 3E3E 3E20 		push r17
 987      5265 6C61 
 987      6973 204F 
 987      4E00 
 988               	/* prologue: function */
 989 000e 3E3E 3E20 	/* frame size = 0 */
 989      5265 6C61 
 989      6973 204F 
 989      4646 00
 990               		mov r17,r24
 992               	.LM87:
 993               		tst r24
 994               		breq .L52
 446:ir_heat.c     **** 
 447:ir_heat.c     **** 
 448:ir_heat.c     **** void	beep(uint8_t type){
 449:ir_heat.c     **** 	cli();
 450:ir_heat.c     **** 	wdt_reset();
 451:ir_heat.c     **** 	switch(type){
 452:ir_heat.c     **** 	case BEEP_SHORT:
 453:ir_heat.c     **** 		_beep(120);
 454:ir_heat.c     **** 		break;
 455:ir_heat.c     **** 	case BEEP_LONG:
 456:ir_heat.c     **** 		_beep(200);
 457:ir_heat.c     **** 		break;
 458:ir_heat.c     **** 	case BEEP_XLONG:
 459:ir_heat.c     **** 		_beep(850);
 460:ir_heat.c     **** 		break;
 461:ir_heat.c     **** 	case BEEP_2SHORT:
 462:ir_heat.c     **** 		_beep(80);
 463:ir_heat.c     **** 		_delay_ms(80);
 464:ir_heat.c     **** 		_beep(80);
 465:ir_heat.c     **** 		break;
 466:ir_heat.c     **** 	case BEEP_SHORT_LONG:
 467:ir_heat.c     **** 		_beep(100);
 468:ir_heat.c     **** 		_delay_ms(180);
 469:ir_heat.c     **** 		_beep(350);		
 470:ir_heat.c     **** 	}
 471:ir_heat.c     **** 	sei();	
 472:ir_heat.c     **** 	printf("Beep\n");
 473:ir_heat.c     **** }
 474:ir_heat.c     **** 
 475:ir_heat.c     **** 
 476:ir_heat.c     **** 
 477:ir_heat.c     **** //***************************************************
 478:ir_heat.c     **** //
 479:ir_heat.c     **** // Relais Ein- und Ausschalen
 480:ir_heat.c     **** //
 481:ir_heat.c     **** void set_relais(uint8_t on) {
 996               	t.2165
 997               		cp r17,r24
 998               		breq .L53
 999 0478 1F93      		ldi r24,lo8(.LC0)
 1000               		ldi r25,hi8(.LC0)
 1001               		call puts
 1002 047a 182F      	.L53:
 482:ir_heat.c     **** 	static uint8_t last = 0;
 483:ir_heat.c     **** 	if(on) {
 1003               		68,0,485,.LM89-.LFBB17
 1004               	.LM89:
 1005 047c 8823      		ldi r30,lo8(37)
 1006 047e 01F0      		ldi r31,hi8(37)
 484:ir_heat.c     **** 		if(on != last) printf(">>> Relais ON\n");
 1007               	r24,Z
 1008               		ori r24,lo8(64)
 1009 0480 8091 0000 		st Z,r24
 1010 0484 1817      		rjmp .L54
 1011 0486 01F0      	.L52:
 1013 048a 90E0      	.LM90:
 1014 048c 0E94 0000 		lds r24,last.2165
 1015               		tst r24
 485:ir_heat.c     **** 		RELAIS_ON;
 1016               	5
 1017               		ldi r24,lo8(.LC1)
 1018 0490 E5E2      		ldi r25,hi8(.LC1)
 1019 0492 F0E0      		call puts
 1020 0494 8081      	.L55:
 1022 0498 8083      	.LM91:
 1023 049a 00C0      		ldi r30,lo8(37)
 1024               		ldi r31,hi8(37)
 486:ir_heat.c     **** 	}
 487:ir_heat.c     **** 	else {
 488:ir_heat.c     **** 		if(on != last) printf(">>> Relais OFF\n");
 1025               	
 1026               		andi r24,lo8(-65)
 1027 049c 8091 0000 		st Z,r24
 1028 04a0 8823      	.L54:
 1030 04a4 80E0      	.LM92:
 1031 04a6 90E0      		sts last.2165,r17
 1032 04a8 0E94 0000 	/* epilogue start */
 489:ir_heat.c     **** 		RELAIS_OFF;
 1034               	pop r17
 1035               		ret
 1040 04b4 8083      	.Lscope17:
 1041               		.data
 490:ir_heat.c     **** 	}
 491:ir_heat.c     **** 	last = on;
 1042               	string	"Beep"
 1043               		.text
 492:ir_heat.c     **** }
 1046               	bal	beep
 1048 04ba 1F91      	beep:
 1050               	.LM94:
 1051               	.LFBB18:
 1052               	/* prologue: function */
 1053               	/* frame size = 0 */
 1055               	.LM95:
 1056               	/* #APP */
 1057 001d 4265 6570 	 ;  449 "ir_heat.c" 1
 1057      00
 1058               		cli
 1059               	 ;  0 "" 2
 1061               	.LM96:
 1062               	 ;  450 "ir_heat.c" 1
 1063               		wdr
 1064               	 ;  0 "" 2
 1066               	.LM97:
 1067               	/* #NOAPP */
 1068               		cpi r24,lo8(3)
 1069               		breq .L61
 1070               		cpi r24,lo8(4)
 1071               		brsh .L64
 1072               		cpi r24,lo8(1)
 1073 04be F894      		breq .L59
 1074               		cpi r24,lo8(2)
 1075               		brne .L58
 1076               		rjmp .L68
 1077               	.L64:
 1078 04c0 A895      		cpi r24,lo8(4)
 1079               		breq .L62
 1080               		cpi r24,lo8(6)
 1081               		brne .L58
 1082               		rjmp .L69
 1083 04c2 8330      	.L59:
 1085 04c6 8430      	.LM98:
 1086 04c8 00F4      		ldi r24,lo8(120)
 1087 04ca 8130      		ldi r25,hi8(120)
 1088 04cc 01F0      		call _beep
 1089 04ce 8230      		rjmp .L58
 1090 04d0 01F4      	.L61:
 1092               	.LM99:
 1093 04d4 8430      		ldi r24,lo8(200)
 1094 04d6 01F0      		ldi r25,hi8(200)
 1095 04d8 8630      		call _beep
 1096 04da 01F4      		rjmp .L58
 1097 04dc 00C0      	.L62:
 1099               	.LM100:
 1100               		ldi r24,lo8(850)
 1101 04de 88E7      		ldi r25,hi8(850)
 1102 04e0 90E0      		call _beep
 1103 04e2 0E94 0000 		rjmp .L58
 1104 04e6 00C0      	.L68:
 1106               	.LM101:
 1107               		ldi r24,lo8(80)
 1108 04e8 88EC      		ldi r25,hi8(80)
 1109 04ea 90E0      		call _beep
 1110 04ec 0E94 0000 	.LBB41:
 1111 04f0 00C0      	.LBB42:
 1112               	.LBB43:
 1113               	.LBB44:
 1115 04f2 82E5      	.Ltext3:
 1117 04f6 0E94 0000 	.LM102:
 1118 04fa 00C0      		ldi r24,lo8(-25536)
 1119               		ldi r25,hi8(-25536)
 1120               	/* #APP */
 1121               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1122 04fc 80E5      		1: sbiw r24,1
 1123 04fe 90E0      		brne 1b
 1124 0500 0E94 0000 	 ;  0 "" 2
 1125               	/* #NOAPP */
 1126               	.LBE44:
 1127               	.LBE43:
 1128               	.LBE42:
 1129               	.LBE41:
 1131               	.Ltext4:
 1133 0504 80E4      	.LM103:
 1134 0506 9CE9      		ldi r24,lo8(80)
 1135               		ldi r25,hi8(80)
 1136               		call _beep
 1137 0508 0197      		rjmp .L58
 1138 050a 01F4      	.L69:
 1140               	.LM104:
 1141               		ldi r24,lo8(100)
 1142               		ldi r25,hi8(100)
 1143               		call _beep
 1144               		ldi r18,lo8(1800)
 1145               		ldi r19,hi8(1800)
 1146               	.LBB45:
 1147               	.LBB46:
 1148               	.LBB47:
 1149 050c 80E5      	.LBB48:
 1151 0510 0E94 0000 	.Ltext5:
 1153               	.LM105:
 1154               		ldi r20,lo8(50)
 1155               		ldi r21,hi8(50)
 1156 0516 84E6      	.L65:
 1157 0518 90E0      		movw r24,r20
 1158 051a 0E94 0000 	/* #APP */
 1159 051e 28E0      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1160 0520 37E0      		1: sbiw r24,1
 1161               		brne 1b
 1162               	 ;  0 "" 2
 1163               	/* #NOAPP */
 1164               	.LBE48:
 1165               	.LBE47:
 1167               	.Ltext6:
 1169 0522 42E3      	.LM106:
 1170 0524 50E0      		subi r18,lo8(-(-1))
 1171               		sbci r19,hi8(-(-1))
 1173               	.LM107:
 1174               		brne .L65
 1175 0528 0197      	.LBE46:
 1176 052a 01F4      	.LBE45:
 1178               	.Ltext7:
 1180               	.LM108:
 1181               		ldi r24,lo8(350)
 1182               		ldi r25,hi8(350)
   1:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    All rights reserved.
   5:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
   6:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
   9:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  12:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      distribution.
  16:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  17:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  21:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  33:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /* $Id: delay.h,v 1.5.2.1 2009/02/25 10:14:03 joerg_wunsch Exp $ */
  34:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  35:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  38:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #include <inttypes.h>
  39:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  40:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  41:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /** \file */
  42:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  43:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \code
  44:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  45:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  46:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     #include <util/delay.h>
  47:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \endcode
  48:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  49:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  50:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  51:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  52:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     used.
  53:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  54:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  55:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  56:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  57:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  58:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  59:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  60:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  61:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  62:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  63:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  64:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  65:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  66:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  67:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  68:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  69:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  70:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     routines linked into the application.
  71:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  72:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  73:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  74:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  75:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  76:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** */
  77:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  78:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  79:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  80:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  81:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #endif
  82:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  83:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #ifndef F_CPU
  84:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  85:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  86:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  87:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #endif
  88:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  89:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  90:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  91:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** #endif
  92:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  93:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** /**
  94:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    \ingroup util_delay
  95:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  96:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
  97:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
  98:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
  99:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 100:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 101:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 102:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 
 103:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 104:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 105:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 106:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 107:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 108:c:/winavr/lib/gcc/../../avr/include/util/delay.h ****  */
 109:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** void
 110:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** _delay_ms(double __ms)
 111:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** {
 112:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	uint16_t __ticks;
 113:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 114:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 115:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = 1;
 116:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 117:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 	{
 118:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 119:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 120:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		while(__ticks)
 121:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 		{
 122:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 			// wait 1/10 ms
 123:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 124:c:/winavr/lib/gcc/../../avr/include/util/delay.h **** 			__ticks --;
 1183               	8
 1184               	.LM110:
 1185 052c 2150      	/* #NOAPP */
 1186 052e 3040      		ldi r24,lo8(.LC2)
 1187               		ldi r25,hi8(.LC2)
 1188               		call puts
 1189 0530 01F4      	/* epilogue start */
 1191               	.LM111:
 1192               		ret
 1200               	.Lscope18:
 1201               		.data
 1202               	.LC3:
 1203               		.string	"Temperature Protection Off!"
 1204 053a 7894      	.LC4:
 1205               		.string	"\nxXx"
 1206               		.text
 1208               	.global	__vector_1
 1210 053e 90E0      	__vector_1:
 1212               	.LM112:
 1213               	.LFBB19:
 1214               		push __zero_reg__
 1215 0544 0895      		push r0
 1216               		in r0,__SREG__
 1217               		push r0
 1218               		clr __zero_reg__
 1219               		push r18
 1220               		push r19
 1221               		push r20
 1222               		push r21
 1223               		push r22
 1224               		push r23
 1225               		push r24
 1226 0022 5465 6D70 		push r25
 1226      6572 6174 
 1226      7572 6520 
 1226      5072 6F74 
 1226      6563 7469 
 1227               		push r26
 1228 003e 0A78 5878 		push r27
 1228      00
 1229               		push r30
 1230               		push r31
 1231               	/* prologue: Signal */
 1232               	/* frame size = 0 */
 1234               	.LM113:
 1235               		lds r24,133
 1236               		lds r18,132
 1237 0546 1F92      		lds r25,running.1919
 1238 0548 0F92      		or r24,r25
 1239 054a 0FB6      		or r24,r18
 1240 054c 0F92      		breq .+2
 1241 054e 1124      		rjmp .L81
 1243 0552 3F93      	.LM114:
 1244 0554 4F93      		ldi r24,lo8(1)
 1245 0556 5F93      		sts running.1919,r24
 1247 055a 7F93      	.LM115:
 1248 055c 8F93      	/* #APP */
 1249 055e 9F93      	 ;  188 "ir_heat.c" 1
 1250 0560 AF93      		wdr
 1251 0562 BF93      	 ;  0 "" 2
 1253 0566 FF93      	.LM116:
 1254               	/* #NOAPP */
 1255               		out 61-32,__zero_reg__
 1257               	.LM117:
 1258 0568 8091 8500 	/* #APP */
 1259 056c 2091 8400 	 ;  193 "ir_heat.c" 1
 1260 0570 9091 0000 		sei
 1261 0574 892B      	 ;  0 "" 2
 1262 0576 822B      	/* #NOAPP */
 1263 0578 01F0      		ldi r18,lo8(0)
 1264 057a 00C0      		ldi r19,hi8(0)
 1265               		ldi r20,lo8(0)
 1266               		ldi r21,hi8(0)
 1268 057e 8093 0000 	.LM118:
 1269               		ldi r30,lo8(41)
 1270               		ldi r31,hi8(41)
 1271               	.L73:
 1272               		ld r24,Z
 1273 0582 A895      		sbrs r24,2
 1274               		rjmp .L72
 1275               		subi r20,lo8(-(1))
 1276               		sbci r21,hi8(-(1))
 1277               	.L72:
 1278 0584 1DBA      		subi r18,lo8(-(1))
 1279               		sbci r19,hi8(-(1))
 1280               		ldi r24,hi8(1000)
 1281               		cpi r18,lo8(1000)
 1282               		cpc r19,r24
 1283 0586 7894      		brne .L73
 1285               	.LM119:
 1286 0588 20E0      		cpi r20,200
 1287 058a 30E0      		cpc r21,__zero_reg__
 1288 058c 40E0      		brlo .+2
 1289 058e 50E0      		rjmp .L74
 1291               	.LM120:
 1292 0590 E9E2      		ldi r24,lo8(1)
 1293 0592 F0E0      		sts 132,r24
 1295 0594 8081      	.LM121:
 1296 0596 82FF      		ldi r24,lo8(2)
 1297 0598 00C0      		sts 129,r24
 1299 059c 5F4F      	.LM122:
 1300               		lds r24,mode
 1301 059e 2F5F      		tst r24
 1302 05a0 3F4F      		breq .+2
 1303 05a2 83E0      		rjmp .L84
 1305 05a6 3807      	.LM123:
 1306 05a8 01F4      		ldi r24,lo8(1)
 1307               		sts mode,r24
 1309 05aa 483C      	.LM124:
 1310 05ac 5105      		call set_relais
 1312 05b0 00C0      	.LM125:
 1313               		ldi r30,lo8(43)
 1314               		ldi r31,hi8(43)
 1315 05b2 81E0      		ld r24,Z
 1316 05b4 8093 8400 		ori r24,lo8(16)
 1317               		st Z,r24
 1319 05b8 82E0      	.LM126:
 1320 05ba 8093 8100 		ld r24,Z
 1321               		ori r24,lo8(8)
 1322               		st Z,r24
 1324 05c2 8823      	.LM127:
 1325 05c4 01F0      		sbic 41-32,2
 1326 05c6 00C0      		rjmp .L77
 1327               		ldi r18,lo8(0)
 1328               		ldi r19,hi8(0)
 1329 05c8 81E0      	.LBB49:
 1330 05ca 8093 0000 	.LBB50:
 1331               	.LBB51:
 1332               	.LBB52:
 1334               	.Ltext8:
 1336 05d2 EBE2      	.LM128:
 1337 05d4 F0E0      		ldi r20,lo8(5000)
 1338 05d6 8081      		ldi r21,hi8(5000)
 1339 05d8 8061      	.LBE52:
 1340 05da 8083      	.LBE51:
 1341               	.LBE50:
 1342               	.LBE49:
 1344 05de 8860      	.Ltext9:
 1346               	.LM129:
 1347               		ldi r30,lo8(41)
 1348 05e2 4A99      		ldi r31,hi8(41)
 1349 05e4 00C0      	.L79:
 1351 05e8 30E0      	.LM130:
 1352               		subi r18,lo8(-(1))
 1353               		sbci r19,hi8(-(1))
 1354               	.LBB56:
 1355               	.LBB55:
 1356               	.LBB54:
 1357               	.LBB53:
 1359               	.Ltext10:
 1361 05ec 53E1      	.LM131:
 1362               		movw r24,r20
 1363               	/* #APP */
 1364               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1365               		1: sbiw r24,1
 1366               		brne 1b
 1367               	 ;  0 "" 2
 1368               	/* #NOAPP */
 1369               	.LBE53:
 1370 05ee E9E2      	.LBE54:
 1371 05f0 F0E0      	.LBE55:
 1372               	.LBE56:
 1374               	.Ltext11:
 1376 05f4 3F4F      	.LM132:
 1377               		ld r24,Z
 1378               		sbrc r24,2
 1379               		rjmp .L78
 1380               		ldi r24,hi8(300)
 1381               		cpi r18,lo8(300)
 1382               		cpc r19,r24
 1383               		brne .L79
 1384               		rjmp .L80
 1385 05f6 CA01      	.L78:
 1387               	.LM133:
 1388 05f8 0197      		subi r18,lo8(300)
 1389 05fa 01F4      		sbci r19,hi8(300)
 1390               		brsh .L80
 1391               	.L77:
 1393               	.LM134:
 1394               		ldi r24,lo8(1)
 1395               		sts mode,r24
 1396               		rjmp .L74
 1397               	.L80:
 1399               	.LM135:
 1400 05fc 8081      		ldi r24,lo8(2)
 1401 05fe 82FD      		sts mode,r24
 1403 0602 81E0      	.LM136:
 1404 0604 2C32      		ldi r24,lo8(.LC3)
 1405 0606 3807      		ldi r25,hi8(.LC3)
 1406 0608 01F4      		call puts
 1408               	.LM137:
 1409               		ldi r30,lo8(43)
 1410               		ldi r31,hi8(43)
 1411 060c 2C52      		ld r24,Z
 1412 060e 3140      		andi r24,lo8(-17)
 1413 0610 00F4      		st Z,r24
 1415               	.LM138:
 1416               		ld r24,Z
 1417 0612 81E0      		ori r24,lo8(8)
 1418 0614 8093 0000 		st Z,r24
 1420               	.LM139:
 1421               		ldi r24,lo8(6)
 1422               		call beep
 1423 061a 82E0      		rjmp .L74
 1424 061c 8093 0000 	.L84:
 1426               	.LM140:
 1427 0620 80E0      		ldi r24,lo8(.LC4)
 1428 0622 90E0      		ldi r25,hi8(.LC4)
 1429 0624 0E94 0000 		call puts
 1431               	.LM141:
 1432 0628 EBE2      		sts mode,__zero_reg__
 1433 062a F0E0      	.L74:
 1435 062e 8F7E      	.LM142:
 1436 0630 8083      		ldi r24,lo8(1)
 1437               		out 60-32,r24
 1439 0632 8081      	.LM143:
 1440 0634 8860      		out 61-32,r24
 1442               	.LM144:
 1443               		sts running.1919,__zero_reg__
 1444 0638 86E0      	.L81:
 1445 063a 0E94 0000 	/* epilogue start */
 1447               	.LM145:
 1448               		pop r31
 1449               		pop r30
 1450 0640 80E0      		pop r27
 1451 0642 90E0      		pop r26
 1452 0644 0E94 0000 		pop r25
 1453               		pop r24
 1454               		pop r23
 1455 0648 1092 0000 		pop r22
 1456               		pop r21
 1457               		pop r20
 1458               		pop r19
 1459 064c 81E0      		pop r18
 1460 064e 8CBB      		pop r0
 1461               		out __SREG__,r0
 1462               		pop r0
 1463 0650 8DBB      		pop __zero_reg__
 1464               		reti
 1471 0656 FF91      	.Lscope19:
 1474 065c AF91      	.global	get_temperature
 1476 0660 8F91      	get_temperature:
 1478 0664 6F91      	.LM146:
 1479 0666 5F91      	.LFBB20:
 1480 0668 4F91      		push r17
 1481 066a 3F91      		push r28
 1482 066c 2F91      		push r29
 1483 066e 0F90      	/* prologue: function */
 1484 0670 0FBE      	/* frame size = 0 */
 1485 0672 0F90      		mov r17,r24
 1487 0676 1895      	.LM147:
 1488               		ldi r24,lo8(-76)
 1489               		call i2c_start
 1490               		tst r24
 1491               		brne .L86
 1493               	.LM148:
 1494               		mov r24,r17
 1495               		call i2c_write
 1496               		tst r24
 1497               		brne .L86
 1499               	.LM149:
 1500               		ldi r24,lo8(181)
 1501               		ldi r25,hi8(181)
 1502               		call i2c_rep_start
 1504 067a CF93      	.LM150:
 1505 067c DF93      		tst r24
 1506               		breq .L87
 1508 067e 182F      	.LM151:
 1509               		ldi r24,lo8(181)
 1510               		ldi r25,hi8(181)
 1511 0680 84EB      		call i2c_rep_start
 1512 0682 0E94 0000 	.L87:
 1514 0688 01F4      	.LM152:
 1515               		call i2c_readAck
 1516               		mov r17,r24
 1518 068c 0E94 0000 	.LM153:
 1519 0690 8823      		call i2c_readAck
 1521               	.LM154:
 1522               		mov r19,r24
 1523 0694 85EB      		ldi r18,lo8(0)
 1524 0696 90E0      		movw r28,r18
 1525 0698 0E94 0000 		add r28,r17
 1526               		adc r29,__zero_reg__
 1528 069c 8823      	.LM155:
 1529 069e 01F0      		call i2c_readAck
 1531               	.LM156:
 1532 06a0 85EB      		call i2c_stop
 1534 06a4 0E94 0000 	.LM157:
 1535               		tst r29
 1536               		brlt .L86
 1538 06a8 0E94 0000 	.LM158:
 1539 06ac 182F      		movw r24,r28
 1540               		ldi r22,lo8(5)
 1541               		ldi r23,hi8(5)
 1542 06ae 0E94 0000 		call __udivmodhi4
 1543               		subi r22,lo8(-(-2731))
 1544               		sbci r23,hi8(-(-2731))
 1545 06b2 382F      		rjmp .L88
 1546 06b4 20E0      	.L86:
 1547 06b6 E901      		ldi r22,lo8(150)
 1548 06b8 C10F      		ldi r23,hi8(150)
 1549 06ba D11D      	.L88:
 1551               	.LM159:
 1552 06bc 0E94 0000 		mov r24,r22
 1553               		mov r25,r23
 1554               	/* epilogue start */
 1555 06c0 0E94 0000 		pop r29
 1556               		pop r28
 1557               		pop r17
 1558 06c4 DD23      		ret
 1563 06ca 65E0      	.Lscope20:
 1564 06cc 70E0      		.data
 1565 06ce 0E94 0000 	.LC5:
 1566 06d2 6B5A      		.string	"Array:"
 1567 06d4 7A40      	.LC6:
 1568 06d6 00C0      		.string	" %i"
 1569               		.text
 1571 06da 70E0      	.global	print_array
 1573               	print_array:
 1575 06dc 862F      	.LM160:
 1576 06de 972F      	.LFBB21:
 1577               		push r12
 1578 06e0 DF91      		push r13
 1579 06e2 CF91      		push r14
 1580 06e4 1F91      		push r15
 1581 06e6 0895      		push r16
 1582               		push r17
 1583               	/* prologue: function */
 1584               	/* frame size = 0 */
 1586               	.LM161:
 1587               		rcall .
 1588               		ldi r24,lo8(.LC5)
 1589 0043 4172 7261 		ldi r25,hi8(.LC5)
 1589      793A 00
 1590               		in r26,__SP_L__
 1591 004a 2025 6900 		in r27,__SP_H__
 1592               		adiw r26,1+1
 1593               		st X,r25
 1594               		st -X,r24
 1595               		sbiw r26,1
 1596               		call printf
 1598               	.LM162:
 1599               		rcall .
 1600 06e8 CF92      		in r30,__SP_L__
 1601 06ea DF92      		in r31,__SP_H__
 1602 06ec EF92      		adiw r30,1
 1603 06ee FF92      		mov __tmp_reg__,r31
 1604 06f0 0F93      		ldi r31,lo8(.LC6)
 1605 06f2 1F93      		mov r14,r31
 1606               		ldi r31,hi8(.LC6)
 1607               		mov r15,r31
 1608               		mov r31,__tmp_reg__
 1609               		std Z+1,r15
 1610 06f4 00D0      		st Z,r14
 1611 06f6 80E0      		mov __tmp_reg__,r31
 1612 06f8 90E0      		ldi r31,lo8(t_array)
 1613 06fa ADB7      		mov r12,r31
 1614 06fc BEB7      		ldi r31,hi8(t_array)
 1615 06fe 1296      		mov r13,r31
 1616 0700 9C93      		mov r31,__tmp_reg__
 1617 0702 8E93      		movw r26,r12
 1618 0704 1197      		ld r24,X+
 1619 0706 0E94 0000 		ld r25,X+
 1620               		movw r16,r26
 1621               		std Z+3,r25
 1622 070a 00D0      		std Z+2,r24
 1623 070c EDB7      		call printf
 1624 070e FEB7      		in r30,__SP_L__
 1625 0710 3196      		in r31,__SP_H__
 1626 0712 0F2E      		adiw r30,1
 1627 0714 F0E0      		std Z+1,r15
 1628 0716 EF2E      		st Z,r14
 1629 0718 F0E0      		movw r26,r16
 1630 071a FF2E      		ld r24,X+
 1631 071c F02D      		ld r25,X
 1632 071e F182      		std Z+3,r25
 1633 0720 E082      		std Z+2,r24
 1634 0722 0F2E      		call printf
 1635 0724 F0E0      		in r30,__SP_L__
 1636 0726 CF2E      		in r31,__SP_H__
 1637 0728 F0E0      		adiw r30,1
 1638 072a DF2E      		std Z+1,r15
 1639 072c F02D      		st Z,r14
 1640 072e D601      		movw r26,r12
 1641 0730 8D91      		adiw r26,4
 1642 0732 9D91      		ld r24,X+
 1643 0734 8D01      		ld r25,X
 1644 0736 9383      		sbiw r26,4+1
 1645 0738 8283      		std Z+3,r25
 1646 073a 0E94 0000 		std Z+2,r24
 1647 073e EDB7      		call printf
 1648 0740 FEB7      		in r30,__SP_L__
 1649 0742 3196      		in r31,__SP_H__
 1650 0744 F182      		adiw r30,1
 1651 0746 E082      		std Z+1,r15
 1652 0748 D801      		st Z,r14
 1653 074a 8D91      		movw r26,r12
 1654 074c 9C91      		adiw r26,6
 1655 074e 9383      		ld r24,X+
 1656 0750 8283      		ld r25,X
 1657 0752 0E94 0000 		sbiw r26,6+1
 1658 0756 EDB7      		std Z+3,r25
 1659 0758 FEB7      		std Z+2,r24
 1660 075a 3196      		call printf
 1661 075c F182      		in r30,__SP_L__
 1662 075e E082      		in r31,__SP_H__
 1663 0760 D601      		adiw r30,1
 1664 0762 1496      		std Z+1,r15
 1665 0764 8D91      		st Z,r14
 1666 0766 9C91      		movw r26,r12
 1667 0768 1597      		adiw r26,8
 1668 076a 9383      		ld r24,X+
 1669 076c 8283      		ld r25,X
 1670 076e 0E94 0000 		sbiw r26,8+1
 1671 0772 EDB7      		std Z+3,r25
 1672 0774 FEB7      		std Z+2,r24
 1673 0776 3196      		call printf
 1674 0778 F182      		in r30,__SP_L__
 1675 077a E082      		in r31,__SP_H__
 1676 077c D601      		adiw r30,1
 1677 077e 1696      		std Z+1,r15
 1678 0780 8D91      		st Z,r14
 1679 0782 9C91      		movw r26,r12
 1680 0784 1797      		adiw r26,10
 1681 0786 9383      		ld r24,X+
 1682 0788 8283      		ld r25,X
 1683 078a 0E94 0000 		sbiw r26,10+1
 1684 078e EDB7      		std Z+3,r25
 1685 0790 FEB7      		std Z+2,r24
 1686 0792 3196      		call printf
 1688 0796 E082      	.LM163:
 1689 0798 D601      		pop __tmp_reg__
 1690 079a 1896      		pop __tmp_reg__
 1691 079c 8D91      		pop __tmp_reg__
 1692 079e 9C91      		pop __tmp_reg__
 1693 07a0 1997      		ldi r24,lo8(10)
 1694 07a2 9383      		ldi r25,hi8(10)
 1695 07a4 8283      		call putchar
 1696 07a6 0E94 0000 	/* epilogue start */
 1698 07ac FEB7      	.LM164:
 1699 07ae 3196      		pop r17
 1700 07b0 F182      		pop r16
 1701 07b2 E082      		pop r15
 1702 07b4 D601      		pop r14
 1703 07b6 1A96      		pop r13
 1704 07b8 8D91      		pop r12
 1705 07ba 9C91      		ret
 1707 07be 9383      	.Lscope21:
 1709 07c2 0E94 0000 	.global	UART_first_init
 1711               	UART_first_init:
 1713 07c8 0F90      	.LM165:
 1714 07ca 0F90      	.LFBB22:
 1715 07cc 0F90      	/* prologue: function */
 1716 07ce 8AE0      	/* frame size = 0 */
 1718 07d2 0E94 0000 	.LM166:
 1719               		ldi r24,lo8(12)
 1720               		ldi r25,hi8(12)
 1721               		sts (196)+1,r25
 1722 07d6 1F91      		sts 196,r24
 1724 07da FF90      	.LM167:
 1725 07dc EF90      		ldi r24,lo8(-104)
 1726 07de DF90      		sts 193,r24
 1728 07e2 0895      	.LM168:
 1729               		ldi r24,lo8(6)
 1730               		sts 194,r24
 1732               	.LM169:
 1733               		ldi r24,lo8(gs(UART_putchar))
 1734               		ldi r25,hi8(gs(UART_putchar))
 1735               		ldi r22,lo8(gs(UART_getchar))
 1736               		ldi r23,hi8(gs(UART_getchar))
 1737               		call fdevopen
 1739               	.LM170:
 1740               	/* #APP */
 1741               	 ;  320 "ir_heat.c" 1
 1742 07e4 8CE0      		sei
 1743 07e6 90E0      	 ;  0 "" 2
 1744 07e8 9093 C500 	/* epilogue start */
 1746               	.LM171:
 1747               	/* #NOAPP */
 1748 07f0 88E9      		ret
 1750               	.Lscope22:
 1751               		.data
 1752 07f6 86E0      	.LC7:
 1753 07f8 8093 C200 		.string	"\n\nStart\n"
 1754               	.LC8:
 1755               		.string	"Error Temp=0"
 1756 07fc 80E0      	.LC9:
 1757 07fe 90E0      		.string	"Startup %i "
 1758 0800 60E0      	.LC10:
 1759 0802 70E0      		.string	"Temp: %i, "
 1760 0804 0E94 0000 	.LC11:
 1761               		.string	"exp_s: %i, s2: %i, bc: %i, fx: %i\n"
 1762               	.LC12:
 1763               		.string	"On-Counter: %i; \n"
 1764               	.LC13:
 1765 0808 7894      		.string	"Off-Counter: %i; \n"
 1766               	.LC14:
 1767               		.string	"Status     %x\n"
 1768               	.LC15:
 1769               		.string	"Dist:      %u mm\n"
 1770               	.LC16:
 1771 080a 0895      		.string	"SigCount:  %u MCPS\n"
 1772               	.LC17:
 1773               		.string	"AmbiCount: %u MCPS\n"
 1774               	.LC18:
 1775               		.string	"SpadCount: %u\n"
 1776 004e 0A0A 5374 	.LC19:
 1776      6172 740A 
 1776      00
 1777               		.string	"!!! Timeout !!!"
 1778 0057 4572 726F 		.text
 1778      7220 5465 
 1778      6D70 3D30 
 1778      00
 1780 0064 5374 6172 	.global	main
 1780      7475 7020 
 1780      2569 2000 
 1782 0070 5465 6D70 	main:
 1782      3A20 2569 
 1782      2C20 00
 1784 007b 6578 705F 	.LM172:
 1784      733A 2025 
 1784      692C 2073 
 1784      323A 2025 
 1784      692C 2062 
 1785               	.LFBB23:
 1786 009e 4F6E 2D43 		push r2
 1786      6F75 6E74 
 1786      6572 3A20 
 1786      2569 3B20 
 1786      0A00 
 1787               		push r3
 1788 00b0 4F66 662D 		push r4
 1788      436F 756E 
 1788      7465 723A 
 1788      2025 693B 
 1788      200A 00
 1789               		push r5
 1790 00c3 5374 6174 		push r6
 1790      7573 2020 
 1790      2020 2025 
 1790      780A 00
 1791               		push r7
 1792 00d2 4469 7374 		push r8
 1792      3A20 2020 
 1792      2020 2025 
 1792      7520 6D6D 
 1792      0A00 
 1793               		push r9
 1794 00e4 5369 6743 		push r10
 1794      6F75 6E74 
 1794      3A20 2025 
 1794      7520 4D43 
 1794      5053 0A00 
 1795               		push r11
 1796 00f8 416D 6269 		push r12
 1796      436F 756E 
 1796      743A 2025 
 1796      7520 4D43 
 1796      5053 0A00 
 1797               		push r13
 1798 010c 5370 6164 		push r14
 1798      436F 756E 
 1798      743A 2025 
 1798      750A 00
 1799               		push r15
 1800 011b 2121 2120 		push r16
 1800      5469 6D65 
 1800      6F75 7420 
 1800      2121 2100 
 1801               		push r17
 1802               		push r29
 1803               		push r28
 1804               		in r28,__SP_L__
 1805               		in r29,__SP_H__
 493:ir_heat.c     **** 
 494:ir_heat.c     **** 
 495:ir_heat.c     **** 
 496:ir_heat.c     **** 
 497:ir_heat.c     **** // ***********************************************************
 498:ir_heat.c     **** // Main program
 499:ir_heat.c     **** //
 500:ir_heat.c     **** int main(void) {
 1806               	 function */
 1807               	/* frame size = 10 */
 1809 080c 2F92      	.LM173:
 1810 080e 3F92      		ldi r24,lo8(-64)
 1811 0810 4F92      		out 36-32,r24
 1813 0814 6F92      	.LM174:
 1814 0816 7F92      		ldi r24,lo8(8)
 1815 0818 8F92      		out 39-32,r24
 1817 081c AF92      	.LM175:
 1818 081e BF92      		ldi r24,lo8(24)
 1819 0820 CF92      		out 42-32,r24
 1821 0824 EF92      	.LM176:
 1822 0826 FF92      		ldi r24,lo8(63)
 1823 0828 0F93      		out 37-32,r24
 1825 082c DF93      	.LM177:
 1826 082e CF93      		ldi r24,lo8(-9)
 1827 0830 CDB7      		out 40-32,r24
 1829 0834 2A97      	.LM178:
 1830 0836 0FB6      		ldi r16,lo8(43)
 1831 0838 F894      		ldi r17,hi8(43)
 1832 083a DEBF      		ldi r24,lo8(-25)
 1833 083c 0FBE      		movw r30,r16
 1834 083e CDBF      		st Z,r24
 1836               	.LM179:
 501:ir_heat.c     ****    // Ausgänge definieren
 502:ir_heat.c     **** 	DDRB = 0x00 | (1<<RELAIS) | (1<<BUZZER);
 1837               	LM180-.LFBB23
 1838               	.LM180:
 1839 0840 80EC      	/* #APP */
 1840 0842 84B9      	 ;  515 "ir_heat.c" 1
 503:ir_heat.c     **** 	DDRC = 0x00 | (1<<FLASH_LED);
 1841               	
 1842               	 ;  0 "" 2
 1844 0846 87B9      	.LM181:
 504:ir_heat.c     **** 	DDRD = 0x00 | (1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED);
 1845               	#NOAPP */
 1846               		ldi r18,lo8(41)
 1847 0848 88E1      		ldi r24,lo8(24)
 1848 084a 8AB9      		ldi r25,hi8(24)
 505:ir_heat.c     **** 
 506:ir_heat.c     **** 	// Ausgänge ausschalten
 507:ir_heat.c     **** 	PORTB = ~((1<<RELAIS) | (1<<BUZZER));
 1849               	APP */
 1850               	 ;  516 "ir_heat.c" 1
 1851 084c 8FE3      		in __tmp_reg__,__SREG__
 1852 084e 85B9      		cli
 508:ir_heat.c     **** 	PORTC = ~(1<<FLASH_LED);
 1853               	
 1854               		sts 96,r24
 1855 0850 87EF      		out __SREG__,__tmp_reg__
 1856 0852 88B9      		sts 96,r18
 509:ir_heat.c     **** 	PORTD = ~((1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED));
 1857               	;  0 "" 2
 1858               	/* #NOAPP */
 1859 0854 0BE2      	.LBB57:
 1861 0858 87EE      	.LM182:
 1862 085a F801      		ldi r24,lo8(2)
 1863 085c 8083      		ldi r25,hi8(2)
 510:ir_heat.c     **** 
 511:ir_heat.c     **** 	// TWI aus Energiesparmode rausnehmen
 512:ir_heat.c     **** 	PRR != ~(1<<PRTWI);
 1864               	8,lo8(-128)
 1865               	/* #APP */
 1866 085e 8091 6400 	 ;  519 "ir_heat.c" 1
 513:ir_heat.c     **** 
 514:ir_heat.c     **** 	// Whatchdog initialisieren
 515:ir_heat.c     **** 	wdt_reset();
 1867               	 __tmp_reg__,__SREG__
 1868               		cli
 1869               		sts 97, r18
 1870               		sts 97, r24
 1871 0862 A895      		out __SREG__, __tmp_reg__
 1872               	 ;  0 "" 2
 516:ir_heat.c     **** 	wdt_enable(WDTO_8S);
 1873               	APP */
 1874               	.LBE57:
 1876 0864 29E2      	.LM183:
 1877 0866 88E1      		call UART_first_init
 1879               	.LM184:
 1880               		call i2c_init
 1882 086c F894      	.LM185:
 1883 086e A895      		sts interval,__zero_reg__
 1885 0874 0FBE      	.LM186:
 1886 0876 2093 6000 		ldi r24,lo8(7)
 1887               		sts 177,r24
 1889               	.LM187:
 1890               		ldi r25,lo8(1)
 517:ir_heat.c     **** 	
 518:ir_heat.c     **** 	// Set clock divider to 4 => 2MHz
 519:ir_heat.c     **** 	clock_prescale_set(clock_div_4);
 1891               	bn	68,0,533,.LM188-.LFBB23
 1892               	.LM188:
 1893 087a 82E0      		out 68-32,__zero_reg__
 1895 087e 20E8      	.LM189:
 1896               		ldi r24,lo8(3)
 1897               		out 69-32,r24
 1899 0882 F894      	.LM190:
 1900 0884 2093 6100 		sts 110,r25
 1902 088c 0FBE      	.LM191:
 1903               		sts 128,__zero_reg__
 1905               	.LM192:
 520:ir_heat.c     **** 	
 521:ir_heat.c     **** 	// UART initialisieren
 522:ir_heat.c     **** 	UART_first_init();
 1906               	_reg__
 1908 088e 0E94 0000 	.LM193:
 523:ir_heat.c     **** 	i2c_init();
 1909               	s 130,__zero_reg__
 1911 0892 0E94 0000 	.LM194:
 524:ir_heat.c     **** 	//initMillis();
 525:ir_heat.c     **** 	
 526:ir_heat.c     **** 	interval=0;
 1912               	s 111,r25
 1914 0896 1092 0000 	.LM195:
 527:ir_heat.c     **** 	
 528:ir_heat.c     **** 	// Timer 2 initialisieren (RTC)
 529:ir_heat.c     ****    TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);	// clk/256
 1915               	i r24,lo8(2)
 1916               		sts 105,r24
 1918 089c 8093 B100 	.LM196:
 530:ir_heat.c     ****    TIMSK2 = (1<<TOIE2);
 1919               	 61-32,r25
 1921 08a0 91E0      	.LM197:
 1922 08a2 9093 7000 		ldi r24,lo8(.LC7)
 531:ir_heat.c     **** 
 532:ir_heat.c     ****  	// Timer 0 initialisieren (Blinken)
 533:ir_heat.c     **** 	TCCR0A = 0;
 1923               	 r25,hi8(.LC7)
 1924               		call puts
 534:ir_heat.c     **** 	TCCR0B = (0<<CS02) | (1<<CS01) | (1<<CS00);
 1926               	198:
 1927               		movw r30,r16
 1928 08a8 83E0      		ld r24,Z
 1929 08aa 85BD      		ori r24,lo8(16)
 535:ir_heat.c     **** 	TIMSK0 = (1<<TOIE0);
 1930               	Z,r24
 1932 08ac 9093 6E00 	.LM199:
 536:ir_heat.c     **** 	
 537:ir_heat.c     **** 	// Timer 1 initialisieren (Entprellen?)
 538:ir_heat.c     **** 	TCCR1A = 0;
 1933               	 r24,Z
 1934               		andi r24,lo8(-9)
 1935 08b0 1092 8000 		st Z,r24
 539:ir_heat.c     **** 	TIMER1_STOP;
 1936               	tabn	68,0,551,.LM200-.LFBB23
 1937               	.LM200:
 1938 08b4 1092 8100 		ldi r24,lo8(0)
 540:ir_heat.c     **** 	TCCR1C = 0;
 1939               	ll set_relais
 1941 08b8 1092 8200 	.LM201:
 541:ir_heat.c     **** 	TIMSK1 = (1<<TOIE1);
 1942               	s mode,__zero_reg__
 1944 08bc 9093 6F00 	.LM202:
 542:ir_heat.c     **** 	
 543:ir_heat.c     **** 	// Interrupt für Taster initialisieren
 544:ir_heat.c     **** 	EICRA = (1<<ISC01);
 1945               	i r24,lo8(1)
 1946               		call initVL53L0X
 1948 08c2 8093 6900 	.LM203:
 545:ir_heat.c     **** 	EIMSK = (1<<INT0);
 1949               	 r22,lo8(0x3dcccccd)
 1950               		ldi r23,hi8(0x3dcccccd)
 1951 08c6 9DBB      		ldi r24,hlo8(0x3dcccccd)
 546:ir_heat.c     **** 	
 547:ir_heat.c     **** 
 548:ir_heat.c     **** 	printf("\n\nStart\n\n");
 1952               	i r25,hhi8(0x3dcccccd)
 1953               		call setSignalRateLimit
 1955 08ca 90E0      	.LM204:
 1956 08cc 0E94 0000 	/* #APP */
 549:ir_heat.c     **** 	STATUS_LED1_ON;		// grüne LED ein
 1957               	85 "ir_heat.c" 1
 1958               		sei
 1959 08d0 F801      	 ;  0 "" 2
 1960 08d2 8081      	/* #NOAPP */
 1961 08d4 8061      		ldi r16,lo8(0)
 1962 08d6 8083      		ldi r17,hi8(0)
 550:ir_heat.c     **** 	STATUS_LED2_OFF;		// rote LED aus
 1963               	15
 1964               		ldi r31,lo8(-1)
 1965 08d8 8081      		std Y+10,r31
 1966 08da 877F      		mov __tmp_reg__,r31
 1967 08dc 8083      		ldi r31,lo8(3)
 551:ir_heat.c     **** 	set_relais(0);			// Relais aus
 1968               	r4,r31
 1969               		mov r31,__tmp_reg__
 1970 08de 80E0      		clr r6
 1971 08e0 0E94 0000 		clr r7
 552:ir_heat.c     **** 	mode = MODE_OFF;
 1972               	 r5
 1974 08e4 1092 0000 	.LM205:
 553:ir_heat.c     **** 	
 554:ir_heat.c     **** 	initVL53L0X(1);	
 1975               	v __tmp_reg__,r31
 1976               		ldi r31,lo8(43)
 1977 08e8 81E0      		mov r10,r31
 1978 08ea 0E94 0000 		clr r11
 555:ir_heat.c     **** 	// lower the return signal rate limit (default is 0.25 MCPS)	
 556:ir_heat.c     **** 	setSignalRateLimit(0.1);	
 1979               	 r31,__tmp_reg__
 1980               	.LBB58:
 1981 08ee 6DEC      	.LBB59:
 1982 08f0 7CEC      	.LBB60:
 1983 08f2 8CEC      	.LBB61:
 1985 08f6 0E94 0000 	.Ltext12:
 557:ir_heat.c     **** 	// increase laser pulse periods (defaults are 14 and 10 PCLKs)	
 558:ir_heat.c     **** 	//setVcselPulsePeriod(VcselPeriodPreRange, 18);	
 559:ir_heat.c     **** 	//setVcselPulsePeriod(VcselPeriodFinalRange, 14);	
 560:ir_heat.c     **** 	//setMeasurementTimingBudget( 100 * 1000UL );		
 561:ir_heat.c     **** 	// integrate over 500 ms per measurement
 562:ir_heat.c     **** 	
 563:ir_heat.c     **** //	int16_t temp, temp_sum, temp_a;
 564:ir_heat.c     **** //	int16_t	lookahead;
 565:ir_heat.c     **** //	int16_t 	slope, max_slope;
 566:ir_heat.c     **** //	int16_t	slope_raw;
 567:ir_heat.c     **** 	int16_t 	temp, temp_sum = 0;
 568:ir_heat.c     **** 	int16_t	slope_raw, slope = 0, temp_a, max_slope;
 569:ir_heat.c     **** 	uint8_t	count=0;
 570:ir_heat.c     **** 	uint8_t  last_interval = 0xff;
 571:ir_heat.c     **** 	uint8_t	startup = 3;
 572:ir_heat.c     **** 	uint8_t	on_counter = 0;
 573:ir_heat.c     **** 	int8_t	beep_counter = 0;
 574:ir_heat.c     **** 	int16_t	factor;
 575:ir_heat.c     **** 	int16_t	integral = 0;
 576:ir_heat.c     **** 	int8_t	fx = 0;
 577:ir_heat.c     **** 	
 578:ir_heat.c     **** 	int16_t	slope_std = 0;
 579:ir_heat.c     **** 	int16_t	slope_real = 0;
 580:ir_heat.c     **** 	
 581:ir_heat.c     **** 	statInfo_t xTraStats;
 582:ir_heat.c     **** 	uint16_t	dist;
 583:ir_heat.c     **** 		
 584:ir_heat.c     **** 	// Interrupts aktivieren
 585:ir_heat.c     **** 	sei();
 1986               		68,0,105,.LM206-.LFBB23
 1987               	.LM206:
 1988               		mov __tmp_reg__,r31
 1989               		ldi r31,lo8(-15536)
 1990 08fa 7894      		mov r2,r31
 1991               		ldi r31,hi8(-15536)
 1992               		mov r3,r31
 1993 08fc 00E0      		mov r31,__tmp_reg__
 1994 08fe 10E0      	.L122:
 1995 0900 FF24      	.LBE61:
 1996 0902 FFEF      	.LBE60:
 1997 0904 FA87      	.LBE59:
 1998 0906 0F2E      	.LBE58:
 2000 090a 4F2E      	.Ltext13:
 2002 090e 6624      	.LM207:
 2003 0910 7724      		lds r20,interval
 2004 0912 5524      		cpi r20,lo8(16)
 586:ir_heat.c     **** 
 587:ir_heat.c     ****    while(1) {
 588:ir_heat.c     ****    	if(!(interval < 16)) { 					// Alle 16x (alle 4 Sekunden) Temperatur checken
 589:ir_heat.c     ****    		wdt_reset();                  	// Whatchdog zurücksetzen
 590:ir_heat.c     **** 
 591:ir_heat.c     **** 			temp = temp_sum / count;				// Mittelwert der 16 Messungen ermitteln
 592:ir_heat.c     **** 
 593:ir_heat.c     ****    		interval=0;
 594:ir_heat.c     ****    		count=0;
 595:ir_heat.c     **** 			temp_sum = 0;
 596:ir_heat.c     **** 	      //printf("Temp: %i\n", temp);
 597:ir_heat.c     **** 	      if(temp==0) {
 598:ir_heat.c     **** 	      	// error!
 599:ir_heat.c     **** 	      	printf("Error Temp=0");
 600:ir_heat.c     **** 	      }
 601:ir_heat.c     **** 	      else {
 602:ir_heat.c     **** 				if (startup>0) {
 603:ir_heat.c     **** 					// wird nur beim ersten Durchlauf, direkt nach Startup ausgeführt
 604:ir_heat.c     **** 					printf("Startup %i ", startup);
 605:ir_heat.c     **** 					startup--;
 606:ir_heat.c     **** 					temp = get_temperature(ADR_T_OBJ1);
 607:ir_heat.c     **** 					slope = 0;
 608:ir_heat.c     **** 				}
 609:ir_heat.c     ****    	   	printf("Temp: %i, ", temp);
 610:ir_heat.c     ****    	   	add_value(temp);									// Neue Temperatur zu Array hinzufügen
 611:ir_heat.c     ****    	   	slope_raw = get_slope();						// Aktuelle Steigung ermitteln
 612:ir_heat.c     ****    	   	if (slope_raw < -100) slope_raw = -100;
 613:ir_heat.c     ****    	   	
 614:ir_heat.c     ****    	   	factor = (temp - 620) / -25;					// Fakort ermitteln
 615:ir_heat.c     ****    	   	temp_a = get_temperature(ADR_T_A);
 616:ir_heat.c     ****    	   	//factor = (temp - 900 + 2*temp_a ) / -25;					// Fakort ermitteln
 617:ir_heat.c     ****    	   	if(factor < 0) factor = 0;
 618:ir_heat.c     ****    	   	   	   	
 619:ir_heat.c     **** 				if(slope_raw > factor) { 						// "Steigungsintegral"
 620:ir_heat.c     **** 					integral = 8*(integral + slope_raw) / factor;
 621:ir_heat.c     **** 					if(integral > 2000) integral = 2000;
 622:ir_heat.c     **** 				}
 623:ir_heat.c     **** 				else {
 624:ir_heat.c     **** 					integral = integral / 4;
 625:ir_heat.c     **** 				}
 626:ir_heat.c     **** 				
 627:ir_heat.c     **** //				slope = (31*slope + 10*slope_raw)/32; 		// Steigung dämpfen
 628:ir_heat.c     **** 
 629:ir_heat.c     **** 				
 630:ir_heat.c     **** 				if(slope_raw < -10) slope_raw = -10;
 631:ir_heat.c     **** 				if(slope_raw<0) {									// Fallende Temperaturen werden stärker gewichtet
 632:ir_heat.c     **** 	   	   	slope = (3*slope + 10*slope_raw)/4;		// Negative Steigung wird mit einer Dämpfung von 8 ge
 633:ir_heat.c     **** 				}
 634:ir_heat.c     **** 				else {
 635:ir_heat.c     **** 	   	   	slope = (31*slope + 10*slope_raw)/32;	// Positive Steigung wird mit einer Dämpfung von 16 
 636:ir_heat.c     **** 	   	   }
 637:ir_heat.c     **** 	   	
 638:ir_heat.c     **** 
 639:ir_heat.c     **** 	   		slope_real = get_slope2();
 640:ir_heat.c     **** 
 641:ir_heat.c     **** 				//printf("bc: %i,sr: %i", beep_counter, slope_real);
 642:ir_heat.c     **** 				if(beep_counter > 0) {
 643:ir_heat.c     **** 					beep_counter++;
 644:ir_heat.c     **** 					if((slope_real < 0)) {
 645:ir_heat.c     **** 						fx = fx+20;
 646:ir_heat.c     **** 						beep_counter = -10;
 647:ir_heat.c     **** 					}
 648:ir_heat.c     **** 				}
 649:ir_heat.c     **** 				
 650:ir_heat.c     **** 				if(fx > 60) fx= 60;
 651:ir_heat.c     **** 
 652:ir_heat.c     **** 	   		slope_std = exp_slope(temp) + fx;
 653:ir_heat.c     **** 	   	
 654:ir_heat.c     **** /*
 655:ir_heat.c     ****    	   	printf("slope_raw: %i, slope: %i ", slope_raw, slope);
 656:ir_heat.c     ****      	   	printf("Ambient: %i\n", get_temperature(ADR_T_A));
 657:ir_heat.c     **** */				
 658:ir_heat.c     **** 
 659:ir_heat.c     **** 				// temp_a 150 -> 45
 660:ir_heat.c     **** 				// temp_a 100 -> 60
 661:ir_heat.c     **** //   	   	max_slope = temp_a * -1.3 + 240;
 662:ir_heat.c     **** //   	   	max_slope = max_slope * (600-temp)/50;
 663:ir_heat.c     **** 				max_slope = (float)temp * -0.8 + 360;
 664:ir_heat.c     **** 
 665:ir_heat.c     **** //   	   	printf("sl_raw: %i, sl: %i, s_max: %i, f: %i, int: %i t_a: %i\n", slope_raw, slope, max_s
 666:ir_heat.c     ****    	   	printf("exp_s: %i, s2: %i, bc: %i, fx: %i\n", slope_std, slope_real, beep_counter, fx);
 667:ir_heat.c     **** 
 668:ir_heat.c     **** //				if((slope > max_slope) || (integral > 500)) {
 669:ir_heat.c     **** 				if(slope_real > slope_std) {
 670:ir_heat.c     **** 					on_counter++;
 671:ir_heat.c     **** 		   		printf("On-Counter: %i; \n", on_counter);
 672:ir_heat.c     **** 	   			if(mode == MODE_ON_NO_PROT){
 673:ir_heat.c     **** 						//on_counter++;
 674:ir_heat.c     **** 	   				if(on_counter==3){
 675:ir_heat.c     **** 	   					beep(BEEP_SHORT);
 676:ir_heat.c     **** 	   					beep_counter=1;
 677:ir_heat.c     **** 	   					on_counter = 0;
 678:ir_heat.c     **** 	   				}
 679:ir_heat.c     ****   					}
 680:ir_heat.c     ****    				else {
 681:ir_heat.c     ****    					if(get_last_slope() > 0) {
 682:ir_heat.c     **** 							//on_counter++;
 683:ir_heat.c     **** 			   			if((on_counter > 11) || (temp > 520)) {
 684:ir_heat.c     ****    							off_counter = OFF_COUNTER+1;
 685:ir_heat.c     ****    							on_counter = 0;
 686:ir_heat.c     ****    							if(mode == MODE_ON) {
 687:ir_heat.c     **** 	   							beep(BEEP_XLONG);
 688:ir_heat.c     ****    								if(temp<500) {
 689:ir_heat.c     **** 				   					beep_counter=1;
 690:ir_heat.c     ****    									//fx = fx+20;
 691:ir_heat.c     ****    								}
 692:ir_heat.c     ****    							}
 693:ir_heat.c     **** 		   				}
 694:ir_heat.c     **** 		   				else {
 695:ir_heat.c     **** 		   					if( ((on_counter > 4) && ((on_counter % 3) == 0)) || (temp > 500) ) {
 696:ir_heat.c     **** 		   						beep(BEEP_LONG);
 697:ir_heat.c     **** 		   						beep_counter = 1;
 698:ir_heat.c     **** 		   					}
 699:ir_heat.c     ****    						}
 700:ir_heat.c     ****    					}
 701:ir_heat.c     ****    					else {
 702:ir_heat.c     ****    						if(slope_raw<0) on_counter=0;
 703:ir_heat.c     ****    					}
 704:ir_heat.c     ****    				}
 705:ir_heat.c     **** 				}			
 706:ir_heat.c     **** 				else {
 707:ir_heat.c     **** 					on_counter = 0;
 708:ir_heat.c     **** 				}					
 709:ir_heat.c     ****    	   }
 710:ir_heat.c     **** 
 711:ir_heat.c     ****    		if(off_counter) {
 712:ir_heat.c     ****    			// Protection Counter läuft
 713:ir_heat.c     ****   				off_counter--;
 714:ir_heat.c     ****   				if(mode == MODE_ON) mode = MODE_TEMP_PROT;
 715:ir_heat.c     **** 				printf("Off-Counter: %i; \n", off_counter);
 716:ir_heat.c     ****    		}
 717:ir_heat.c     ****    		else {
 718:ir_heat.c     ****    			if(mode == MODE_TEMP_PROT) {
 719:ir_heat.c     ****    				slope = 0;
 720:ir_heat.c     ****    				integral = 0;
 721:ir_heat.c     ****    				mode = MODE_OFF;
 722:ir_heat.c     ****    			}
 723:ir_heat.c     ****    		}
 724:ir_heat.c     ****    		
 725:ir_heat.c     ****    			readRangeSingleMillimeters( &xTraStats );	// blocks until measurement is finished
 726:ir_heat.c     **** //				dist = readRangeSingleMillimeters( 0 );	// blocks until measurement is finished
 727:ir_heat.c     **** //				printf("Dist: %i mm\n", dist);
 728:ir_heat.c     **** 
 729:ir_heat.c     **** 				printf("Status     %x\n", xTraStats.rangeStatus);
 730:ir_heat.c     **** 				printf("Dist:      %u mm\n", xTraStats.rawDistance);
 731:ir_heat.c     **** 				printf("SigCount:  %u MCPS\n", xTraStats.signalCnt);
 732:ir_heat.c     **** 				printf("AmbiCount: %u MCPS\n", xTraStats.ambientCnt);
 733:ir_heat.c     **** 				printf("SpadCount: %u\n", xTraStats.spadCnt);
 734:ir_heat.c     **** 				if ( timeoutOccurred() ) {
 735:ir_heat.c     **** 					printf("!!! Timeout !!!\n");
 736:ir_heat.c     **** 				}
 737:ir_heat.c     ****    		
 738:ir_heat.c     **** 		}
 739:ir_heat.c     **** 		else if(interval != last_interval) {
 740:ir_heat.c     **** 			// In jedem Interval 1x die Temperatur abrufen
 741:ir_heat.c     **** 			// und für den Mittelwert aufsummieren
 742:ir_heat.c     ****    		last_interval = interval;
 743:ir_heat.c     ****     		if(count<16) {
 744:ir_heat.c     **** 	   		count++;
 745:ir_heat.c     ****    			// Messwerte für den Mittelwert aufsummieren
 746:ir_heat.c     ****    			temp_sum += get_temperature(ADR_T_OBJ1);
 747:ir_heat.c     ****    			
 748:ir_heat.c     ****    		}
 749:ir_heat.c     ****    		//_delay_ms(100);
 750:ir_heat.c     **** 			//printf("Test: %X\n", readReg(0xC1));
 751:ir_heat.c     **** 			//_delay_ms(100);
 752:ir_heat.c     ****    	}
 753:ir_heat.c     **** 
 754:ir_heat.c     **** 		// Je nach Mode Relais und LEDs setzen
 755:ir_heat.c     **** 		switch(mode) {
 756:ir_heat.c     **** 		case MODE_OFF:
 757:ir_heat.c     **** 			set_relais(0);
 758:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 759:ir_heat.c     **** 			STATUS_LED2_OFF;
 760:ir_heat.c     **** 			off_counter = 0;
 761:ir_heat.c     **** 			on_counter = 0;
 762:ir_heat.c     **** 			beep_counter = 0;
 763:ir_heat.c     **** 			break;
 764:ir_heat.c     **** 		case MODE_ON:
 765:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 766:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 767:ir_heat.c     **** 			set_relais(1);
 768:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2005               	5
 2007 0914 0F2E      	.LM208:
 2008 0916 FBE2      	/* #APP */
 2009 0918 AF2E      	 ;  589 "ir_heat.c" 1
 2010 091a BB24      		wdr
 2011 091c F02D      	 ;  0 "" 2
 2013               	.LM209:
 2014               	/* #NOAPP */
 2015               		movw r24,r16
 2016               		mov r22,r15
 2017               		ldi r23,lo8(0)
 2018               		call __divmodhi4
 2019               		mov r24,r22
 2020 091e 0F2E      		mov r25,r23
 2021 0920 F0E5      		movw r12,r24
 2023 0924 F3EC      	.LM210:
 2024 0926 3F2E      		sts interval,__zero_reg__
 2026               	.LM211:
 2027               		cp r12,__zero_reg__
 2028               		cpc r13,__zero_reg__
 2029               		brne .L96
 2031               	.LM212:
 2032               		rcall .
 2033               		ldi r24,lo8(.LC8)
 2034               		ldi r25,hi8(.LC8)
 2035 092a 4091 0000 		in r30,__SP_L__
 2036 092e 4031      		in r31,__SP_H__
 2037 0930 04F4      		std Z+2,r25
 2038 0932 00C0      		std Z+1,r24
 2039               		call printf
 2040               		pop __tmp_reg__
 2041               		pop __tmp_reg__
 2042               		rjmp .L97
 2043 0934 A895      	.L96:
 2045               	.LM213:
 2046               		tst r4
 2047               		breq .L98
 2049 0938 6F2D      	.LM214:
 2050 093a 70E0      		rcall .
 2051 093c 0E94 0000 		rcall .
 2052 0940 862F      		in r30,__SP_L__
 2053 0942 972F      		in r31,__SP_H__
 2054 0944 6C01      		adiw r30,1
 2055               		ldi r24,lo8(.LC9)
 2056               		ldi r25,hi8(.LC9)
 2057 0946 1092 0000 		std Z+1,r25
 2058               		st Z,r24
 2059               		std Z+2,r4
 2060 094a C114      		std Z+3,__zero_reg__
 2061 094c D104      		call printf
 2063               	.LM215:
 2064               		dec r4
 2066 0952 80E0      	.LM216:
 2067 0954 90E0      		pop __tmp_reg__
 2068 0956 EDB7      		pop __tmp_reg__
 2069 0958 FEB7      		pop __tmp_reg__
 2070 095a 9283      		pop __tmp_reg__
 2071 095c 8183      		ldi r24,lo8(7)
 2072 095e 0E94 0000 		call get_temperature
 2073 0962 0F90      		movw r12,r24
 2074 0964 0F90      	.L98:
 2076               	.LM217:
 2077               		rcall .
 2078               		rcall .
 2079 0968 4420      		in r30,__SP_L__
 2080 096a 01F0      		in r31,__SP_H__
 2081               		adiw r30,1
 2082               		ldi r24,lo8(.LC10)
 2083 096c 00D0      		ldi r25,hi8(.LC10)
 2084 096e 00D0      		std Z+1,r25
 2085 0970 EDB7      		st Z,r24
 2086 0972 FEB7      		std Z+3,r13
 2087 0974 3196      		std Z+2,r12
 2088 0976 80E0      		call printf
 2090 097a 9183      	.LM218:
 2091 097c 8083      		pop __tmp_reg__
 2092 097e 4282      		pop __tmp_reg__
 2093 0980 1382      		pop __tmp_reg__
 2094 0982 0E94 0000 		pop __tmp_reg__
 2095               		movw r24,r12
 2096               		call add_value
 2098               	.LM219:
 2099               		call get_slope
 2100 0988 0F90      		movw r8,r24
 2102 098c 0F90      	.LM220:
 2103 098e 0F90      		ldi r24,lo8(6)
 2104 0990 87E0      		call get_temperature
 2106 0996 6C01      	.LM221:
 2107               		call get_slope2
 2108               		movw r14,r24
 2110 0998 00D0      	.LM222:
 2111 099a 00D0      		cp __zero_reg__,r7
 2112 099c EDB7      		brge .L99
 2114 09a0 3196      	.LM223:
 2115 09a2 80E0      		tst r25
 2116 09a4 90E0      		brlt .L100
 2118 09a8 8083      	.LM224:
 2119 09aa D382      		inc r7
 2120 09ac C282      		rjmp .L99
 2121 09ae 0E94 0000 	.L100:
 2123               	.LM225:
 2124 09b2 0F90      		ldi r25,lo8(20)
 2125 09b4 0F90      		add r5,r25
 2126 09b6 0F90      		mov __tmp_reg__,r31
 2127 09b8 0F90      		ldi r31,lo8(-10)
 2128 09ba C601      		mov r7,r31
 2129 09bc 0E94 0000 		mov r31,__tmp_reg__
 2130               	.L99:
 2131               		ldi r30,lo8(60)
 2132 09c0 0E94 0000 		cp r30,r5
 2133 09c4 4C01      		brge .L101
 2134               		mov __tmp_reg__,r31
 2135               		ldi r31,lo8(60)
 2136 09c6 86E0      		mov r5,r31
 2137 09c8 0E94 0000 		mov r31,__tmp_reg__
 2138               	.L101:
 2140 09cc 0E94 0000 	.LM226:
 2141 09d0 7C01      		movw r24,r12
 2142               		call exp_slope
 2143               		mov r18,r5
 2144 09d2 1714      		clr r19
 2145 09d4 04F4      		sbrc r18,7
 2146               		com r19
 2147               		movw r16,r18
 2148 09d6 9923      		add r16,r24
 2149 09d8 04F0      		adc r17,r25
 2151               	.LM227:
 2152 09da 7394      		in r24,__SP_L__
 2153 09dc 00C0      		in r25,__SP_H__
 2154               		sbiw r24,10
 2155               		in __tmp_reg__,__SREG__
 2156               		cli
 2157 09de 94E1      		out __SP_H__,r25
 2158 09e0 590E      		out __SREG__,__tmp_reg__
 2159 09e2 0F2E      		out __SP_L__,r24
 2160 09e4 F6EF      		in r30,__SP_L__
 2161 09e6 7F2E      		in r31,__SP_H__
 2162 09e8 F02D      		adiw r30,1
 2163               		ldi r24,lo8(.LC11)
 2164 09ea ECE3      		ldi r25,hi8(.LC11)
 2165 09ec E515      		std Z+1,r25
 2166 09ee 04F4      		st Z,r24
 2167 09f0 0F2E      		std Z+3,r17
 2168 09f2 FCE3      		std Z+2,r16
 2169 09f4 5F2E      		std Z+5,r15
 2170 09f6 F02D      		std Z+4,r14
 2171               		mov r24,r7
 2172               		clr r25
 2173               		sbrc r24,7
 2174 09f8 C601      		com r25
 2175 09fa 0E94 0000 		std Z+7,r25
 2176 09fe 252D      		std Z+6,r24
 2177 0a00 3327      		std Z+9,r19
 2178 0a02 27FD      		std Z+8,r18
 2179 0a04 3095      		call printf
 2181 0a08 080F      	.LM228:
 2182 0a0a 191F      		in r30,__SP_L__
 2183               		in r31,__SP_H__
 2184               		adiw r30,10
 2185 0a0c 8DB7      		in __tmp_reg__,__SREG__
 2186 0a0e 9EB7      		cli
 2187 0a10 0A97      		out __SP_H__,r31
 2188 0a12 0FB6      		out __SREG__,__tmp_reg__
 2189 0a14 F894      		out __SP_L__,r30
 2190 0a16 9EBF      		cp r16,r14
 2191 0a18 0FBE      		cpc r17,r15
 2192 0a1a 8DBF      		brlt .+2
 2193 0a1c EDB7      		rjmp .L102
 2195 0a20 3196      	.LM229:
 2196 0a22 80E0      		inc r6
 2198 0a26 9183      	.LM230:
 2199 0a28 8083      		rcall .
 2200 0a2a 1383      		rcall .
 2201 0a2c 0283      		in r30,__SP_L__
 2202 0a2e F582      		in r31,__SP_H__
 2203 0a30 E482      		adiw r30,1
 2204 0a32 872D      		ldi r24,lo8(.LC12)
 2205 0a34 9927      		ldi r25,hi8(.LC12)
 2206 0a36 87FD      		std Z+1,r25
 2207 0a38 9095      		st Z,r24
 2208 0a3a 9783      		std Z+2,r6
 2209 0a3c 8683      		std Z+3,__zero_reg__
 2210 0a3e 3187      		call printf
 2212 0a42 0E94 0000 	.LM231:
 2213               		pop __tmp_reg__
 2214               		pop __tmp_reg__
 2215 0a46 EDB7      		pop __tmp_reg__
 2216 0a48 FEB7      		pop __tmp_reg__
 2217 0a4a 3A96      		lds r24,mode
 2218 0a4c 0FB6      		cpi r24,lo8(2)
 2219 0a4e F894      		brne .L103
 2221 0a52 0FBE      	.LM232:
 2222 0a54 EDBF      		ldi r25,lo8(3)
 2223 0a56 0E15      		cp r6,r25
 2224 0a58 1F05      		breq .+2
 2225 0a5a 04F0      		rjmp .L97
 2227               	.LM233:
 2228               		ldi r24,lo8(1)
 2229 0a5e 6394      		call beep
 2230               		clr r6
 2231               		clr r7
 2232 0a60 00D0      		inc r7
 2233 0a62 00D0      		rjmp .L97
 2234 0a64 EDB7      	.L103:
 2236 0a68 3196      	.LM234:
 2237 0a6a 80E0      		call get_last_slope
 2238 0a6c 90E0      		cp __zero_reg__,r24
 2239 0a6e 9183      		cpc __zero_reg__,r25
 2240 0a70 8083      		brge .L104
 2242 0a74 1382      	.LM235:
 2243 0a76 0E94 0000 		ldi r30,lo8(11)
 2244               		cp r30,r6
 2245               		brlo .L105
 2246 0a7a 0F90      		ldi r31,lo8(521)
 2247 0a7c 0F90      		cp r12,r31
 2248 0a7e 0F90      		ldi r31,hi8(521)
 2249 0a80 0F90      		cpc r13,r31
 2250 0a82 8091 0000 		brlt .L106
 2251 0a86 8230      	.L105:
 2253               	.LM236:
 2254               		ldi r21,lo8(3)
 2255 0a8a 93E0      		sts off_counter,r21
 2257 0a8e 01F0      	.LM237:
 2258 0a90 00C0      		lds r24,mode
 2259               		cpi r24,lo8(1)
 2260               		breq .L107
 2261 0a92 81E0      		clr r6
 2262 0a94 0E94 0000 		ldi r24,lo8(3)
 2263 0a98 6624      		rjmp .L108
 2264 0a9a 7724      	.L107:
 2266 0a9e 00C0      	.LM238:
 2267               		ldi r24,lo8(4)
 2268               		call beep
 2270 0aa0 0E94 0000 	.LM239:
 2271 0aa4 1816      		ldi r24,lo8(500)
 2272 0aa6 1906      		cp r12,r24
 2273 0aa8 04F4      		ldi r24,hi8(500)
 2274               		cpc r13,r24
 2275               		brge .L102
 2276 0aaa EBE0      		clr r6
 2277 0aac E615      		clr r7
 2278 0aae 00F0      		inc r7
 2279 0ab0 F9E0      		rjmp .L97
 2280 0ab2 CF16      	.L106:
 2282 0ab6 DF06      	.LM240:
 2283 0ab8 04F0      		ldi r25,lo8(4)
 2284               		cp r25,r6
 2285               		brsh .L109
 2286               		mov r24,r6
 2287 0aba 53E0      		ldi r22,lo8(3)
 2288 0abc 5093 0000 		call __udivmodqi4
 2289               		tst r25
 2290               		breq .L110
 2291 0ac0 8091 0000 	.L109:
 2292 0ac4 8130      		ldi r30,lo8(501)
 2293 0ac6 01F0      		cp r12,r30
 2294 0ac8 6624      		ldi r30,hi8(501)
 2295 0aca 83E0      		cpc r13,r30
 2296 0acc 00C0      		brlt .L97
 2297               	.L110:
 2299               	.LM241:
 2300 0ace 84E0      		ldi r24,lo8(3)
 2301 0ad0 0E94 0000 		call beep
 2302               		clr r7
 2303               		inc r7
 2304 0ad4 84EF      		rjmp .L97
 2305 0ad6 C816      	.L104:
 2307 0ada D806      	.LM242:
 2308 0adc 04F4      		tst r9
 2309 0ade 6624      		brge .L97
 2310 0ae0 7724      	.L102:
 2311 0ae2 7394      		clr r6
 2312 0ae4 00C0      	.L97:
 2314               	.LM243:
 2315               		lds r24,off_counter
 2316 0ae6 94E0      		tst r24
 2317 0ae8 9615      		breq .L111
 2318 0aea 00F4      	.L108:
 2320 0aee 63E0      	.LM244:
 2321 0af0 0E94 0000 		subi r24,lo8(-(-1))
 2322 0af4 9923      		sts off_counter,r24
 2324               	.LM245:
 2325 0af8 E5EF      		lds r24,mode
 2326 0afa CE16      		cpi r24,lo8(1)
 2327 0afc E1E0      		brne .L112
 2328 0afe DE06      		ldi r31,lo8(3)
 2329 0b00 04F0      		sts mode,r31
 2330               	.L112:
 2332               	.LM246:
 2333 0b02 83E0      		rcall .
 2334 0b04 0E94 0000 		rcall .
 2335 0b08 7724      		in r30,__SP_L__
 2336 0b0a 7394      		in r31,__SP_H__
 2337 0b0c 00C0      		adiw r30,1
 2338               		ldi r24,lo8(.LC13)
 2339               		ldi r25,hi8(.LC13)
 2340               		std Z+1,r25
 2341 0b0e 9920      		st Z,r24
 2342 0b10 04F4      		lds r24,off_counter
 2343               		std Z+2,r24
 2344 0b12 6624      		std Z+3,__zero_reg__
 2345               		call printf
 2346               		pop __tmp_reg__
 2347               		pop __tmp_reg__
 2348 0b14 8091 0000 		pop __tmp_reg__
 2349 0b18 8823      		pop __tmp_reg__
 2350 0b1a 01F0      		rjmp .L113
 2351               	.L111:
 2353               	.LM247:
 2354 0b1c 8150      		lds r24,mode
 2355 0b1e 8093 0000 		cpi r24,lo8(3)
 2356               		brne .L113
 2358 0b22 8091 0000 	.LM248:
 2359 0b26 8130      		sts mode,__zero_reg__
 2360 0b28 01F4      	.L113:
 2362 0b2c F093 0000 	.LM249:
 2363               		movw r24,r28
 2364               		adiw r24,1
 2365               		call readRangeSingleMillimeters
 2367 0b32 00D0      	.LM250:
 2368 0b34 EDB7      		rcall .
 2369 0b36 FEB7      		rcall .
 2370 0b38 3196      		in r30,__SP_L__
 2371 0b3a 80E0      		in r31,__SP_H__
 2372 0b3c 90E0      		adiw r30,1
 2373 0b3e 9183      		ldi r24,lo8(.LC14)
 2374 0b40 8083      		ldi r25,hi8(.LC14)
 2375 0b42 8091 0000 		std Z+1,r25
 2376 0b46 8283      		st Z,r24
 2377 0b48 1382      		ldd r24,Y+9
 2378 0b4a 0E94 0000 		std Z+2,r24
 2379 0b4e 0F90      		std Z+3,__zero_reg__
 2380 0b50 0F90      		call printf
 2382 0b54 0F90      	.LM251:
 2383 0b56 00C0      		in r30,__SP_L__
 2384               		in r31,__SP_H__
 2385               		adiw r30,1
 2386               		ldi r24,lo8(.LC15)
 2387 0b58 8091 0000 		ldi r25,hi8(.LC15)
 2388 0b5c 8330      		std Z+1,r25
 2389 0b5e 01F4      		st Z,r24
 2390               		ldd r24,Y+1
 2391               		ldd r25,Y+2
 2392 0b60 1092 0000 		std Z+3,r25
 2393               		std Z+2,r24
 2394               		call printf
 2396 0b64 CE01      	.LM252:
 2397 0b66 0196      		in r30,__SP_L__
 2398 0b68 0E94 0000 		in r31,__SP_H__
 2399               		adiw r30,1
 2400               		ldi r24,lo8(.LC16)
 2401 0b6c 00D0      		ldi r25,hi8(.LC16)
 2402 0b6e 00D0      		std Z+1,r25
 2403 0b70 EDB7      		st Z,r24
 2404 0b72 FEB7      		ldd r24,Y+3
 2405 0b74 3196      		ldd r25,Y+4
 2406 0b76 80E0      		std Z+3,r25
 2407 0b78 90E0      		std Z+2,r24
 2408 0b7a 9183      		call printf
 2410 0b7e 8985      	.LM253:
 2411 0b80 8283      		in r30,__SP_L__
 2412 0b82 1382      		in r31,__SP_H__
 2413 0b84 0E94 0000 		adiw r30,1
 2414               		ldi r24,lo8(.LC17)
 2415               		ldi r25,hi8(.LC17)
 2416 0b88 EDB7      		std Z+1,r25
 2417 0b8a FEB7      		st Z,r24
 2418 0b8c 3196      		ldd r24,Y+5
 2419 0b8e 80E0      		ldd r25,Y+6
 2420 0b90 90E0      		std Z+3,r25
 2421 0b92 9183      		std Z+2,r24
 2422 0b94 8083      		call printf
 2424 0b98 9A81      	.LM254:
 2425 0b9a 9383      		in r30,__SP_L__
 2426 0b9c 8283      		in r31,__SP_H__
 2427 0b9e 0E94 0000 		adiw r30,1
 2428               		ldi r24,lo8(.LC18)
 2429               		ldi r25,hi8(.LC18)
 2430 0ba2 EDB7      		std Z+1,r25
 2431 0ba4 FEB7      		st Z,r24
 2432 0ba6 3196      		ldd r24,Y+7
 2433 0ba8 80E0      		ldd r25,Y+8
 2434 0baa 90E0      		std Z+3,r25
 2435 0bac 9183      		std Z+2,r24
 2436 0bae 8083      		call printf
 2438 0bb2 9C81      	.LM255:
 2439 0bb4 9383      		pop __tmp_reg__
 2440 0bb6 8283      		pop __tmp_reg__
 2441 0bb8 0E94 0000 		pop __tmp_reg__
 2442               		pop __tmp_reg__
 2443               		call timeoutOccurred
 2444 0bbc EDB7      		tst r24
 2445 0bbe FEB7      		brne .L114
 2446 0bc0 3196      		ldi r16,lo8(0)
 2447 0bc2 80E0      		ldi r17,hi8(0)
 2448 0bc4 90E0      		clr r15
 2449 0bc6 9183      		rjmp .L115
 2450 0bc8 8083      	.L114:
 2452 0bcc 9E81      	.LM256:
 2453 0bce 9383      		ldi r24,lo8(.LC19)
 2454 0bd0 8283      		ldi r25,hi8(.LC19)
 2455 0bd2 0E94 0000 		call puts
 2456               		ldi r16,lo8(0)
 2457               		ldi r17,hi8(0)
 2458 0bd6 EDB7      		clr r15
 2459 0bd8 FEB7      		rjmp .L115
 2460 0bda 3196      	.L95:
 2462 0bde 90E0      	.LM257:
 2463 0be0 9183      		mov r18,r20
 2464 0be2 8083      		clr r19
 2465 0be4 8F81      		sbrc r18,7
 2466 0be6 9885      		com r19
 2467 0be8 9383      		ldd r30,Y+10
 2468 0bea 8283      		mov r24,r30
 2469 0bec 0E94 0000 		ldi r25,lo8(0)
 2470               		cp r18,r24
 2471               		cpc r19,r25
 2472 0bf0 0F90      		breq .L115
 2474 0bf4 0F90      	.LM258:
 2475 0bf6 0F90      		std Y+10,r20
 2477 0bfc 8823      	.LM259:
 2478 0bfe 01F4      		ldi r31,lo8(15)
 2479 0c00 00E0      		cp r31,r15
 2480 0c02 10E0      		brlo .L115
 2482 0c06 00C0      	.LM260:
 2483               		inc r15
 2485               	.LM261:
 2486 0c08 80E0      		ldi r24,lo8(7)
 2487 0c0a 90E0      		call get_temperature
 2488 0c0c 0E94 0000 		add r16,r24
 2489 0c10 00E0      		adc r17,r25
 2490 0c12 10E0      	.L115:
 2492 0c16 00C0      	.LM262:
 2493               		lds r24,mode
 2494               		cpi r24,lo8(1)
 2495               		breq .L118
 2496 0c18 242F      		cpi r24,lo8(1)
 2497 0c1a 3327      		brlo .L117
 2498 0c1c 27FD      		cpi r24,lo8(2)
 2499 0c1e 3095      		breq .L119
 2500 0c20 EA85      		cpi r24,lo8(3)
 2501 0c22 8E2F      		brne .L124
 2502 0c24 90E0      		rjmp .L125
 2503 0c26 2817      	.L117:
 2505 0c2a 01F0      	.LM263:
 2506               		ldi r24,lo8(0)
 2507               		call set_relais
 2509               	.LM264:
 2510               		movw r30,r10
 2511 0c2e FFE0      		ld r24,Z
 2512 0c30 FF15      		ori r24,lo8(16)
 2513 0c32 00F0      		st Z,r24
 2515               	.LM265:
 2516 0c34 F394      		ld r24,Z
 2517               		andi r24,lo8(-9)
 2518               		st Z,r24
 2520 0c38 0E94 0000 	.LM266:
 2521 0c3c 080F      		sts off_counter,__zero_reg__
 2522 0c3e 191F      		clr r6
 2523               		clr r7
 2524               		rjmp .L121
 2525               	.L118:
 2527 0c44 8130      	.LM267:
 2528 0c46 01F0      		movw r30,r10
 2529 0c48 8130      		ld r24,Z
 2530 0c4a 00F0      		ori r24,lo8(16)
 2531 0c4c 8230      		st Z,r24
 2532 0c4e 01F0      	.L119:
 2534 0c52 01F4      	.LM268:
 2535 0c54 00C0      		ldi r24,lo8(1)
 2536               		call set_relais
 2538               	.LM269:
 2539 0c56 80E0      		movw r30,r10
 2540 0c58 0E94 0000 		ld r24,Z
 2541               		ori r24,lo8(8)
 2542               		st Z,r24
 2543 0c5c F501      		rjmp .L121
 2544 0c5e 8081      	.L125:
 2546 0c62 8083      	.LM270:
 2547               		ldi r24,lo8(0)
 2548               		call set_relais
 2550 0c66 877F      	.LM271:
 2551 0c68 8083      		movw r30,r10
 2552               		ld r24,Z
 2553               		andi r24,lo8(-17)
 2554 0c6a 1092 0000 		st Z,r24
 2556 0c70 7724      	.LM272:
 2557 0c72 00C0      		ld r24,Z
 2558               		ori r24,lo8(8)
 2559               		st Z,r24
 2560               		rjmp .L121
 2561 0c74 F501      	.L124:
 2563 0c78 8061      	.LM273:
 2564 0c7a 8083      		sts mode,__zero_reg__
 2565               	.L121:
 2566               	.LBB65:
 2567               	.LBB64:
 2568 0c7c 81E0      	.LBB63:
 2569 0c7e 0E94 0000 	.LBB62:
 2571               	.Ltext14:
 2573 0c84 8081      	.LM274:
 2574 0c86 8860      		movw r24,r2
 2575 0c88 8083      	/* #APP */
 2576 0c8a 00C0      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 2577               		1: sbiw r24,1
 769:ir_heat.c     **** 			break;
 770:ir_heat.c     **** 		case MODE_TEMP_PROT:
 771:ir_heat.c     **** 			set_relais(0);
 2578               	/* #APP */
 2579               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 2580 0c8c 80E0      		1: sbiw r24,1
 2581 0c8e 0E94 0000 		brne 1b
 772:ir_heat.c     **** 			STATUS_LED1_OFF;
 2582               	
 2583               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 2584 0c92 F501      		1: sbiw r24,1
 2585 0c94 8081      		brne 1b
 2586 0c96 8F7E      	 ;  0 "" 2
 2587 0c98 8083      	/* #NOAPP */
 773:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2588               	c/../../avr/include/util/delay_basic.h" 1
 2589               		1: sbiw r24,1
 2590 0c9a 8081      		brne 1b
 2591 0c9c 8860      	 ;  0 "" 2
 2592 0c9e 8083      	/* #NOAPP */
 2593 0ca0 00C0      		rjmp .L122
 2594               	.LBE62:
 774:ir_heat.c     **** 			slope = 0;
 775:ir_heat.c     **** 			integral = 0;
 776:ir_heat.c     **** 			break;
 777:ir_heat.c     **** 		default:
 778:ir_heat.c     **** 			mode = MODE_OFF;
 2595               	il/delay_basic.h" 1
 2596               		1: sbiw r24,1
 2597 0ca2 1092 0000 		brne 1b
 2598               	 ;  0 "" 2
 2599               	/* #NOAPP */
 2600               		rjmp .L122
 2601               	.LBE62:
 2602               	.LBE63:
 2603               	.LBE64:
 2604               	.LBE65:
 2620               	.Lscope23:
 2621               	.global	interval
 2622               		.data
 2625               	interval:
 2626               		.byte	-12
 2627               	.global	off_counter
 2628               	.global	off_counter
 2629               		.section .bss
 2632               	off_counter:
 2633               		.skip 1,0
 2634               	.global	flash_button
 2635               	.global	flash_button
 2638               	flash_button:
 2639               		.skip 1,0
 2640 012b F4        	.global	flash_LED
 2641               	.global	flash_LED
 2644               	flash_LED:
 2645               		.skip 1,0
 2646               	.global	g_Millis
 2647 0000 00        	.global	g_Millis
 2650               	g_Millis:
 2651               		.skip 4,0
 2652               		.lcomm last.2165,1
 2653 0001 00        		.lcomm last_slope.2051,2
 2654               		.lcomm running.1919,1
 2655               		.lcomm c2.1893,1
 2656               		.lcomm c1.1892,1
 2657               		.comm tbuf,32,1
 2658               		.comm rbuf,32,1
 2659 0002 00        		.comm t_in,1,1
 2660               		.comm t_out,1,1
 2661               		.comm r_in,1,1
 2662               		.comm r_out,1,1
 2663               		.comm t_array,12,1
 2664               		.comm mode,1,1
 2665 0003 0000 0000 		.comm slope2,2,1
 2685               		.text
 2687               	.Letext0:
 2688               	.global __do_copy_data
 2689               	.global __do_clear_bss
 2690               	...
DEFINED SYMBOLS
                            *ABS*:00000000 ir_heat.c
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:2      *ABS*:0000003f __SREG__
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:3      *ABS*:0000003e __SP_H__
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:4      *ABS*:0000003d __SP_L__
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:5      *ABS*:00000034 __CCP__
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:101    .text:00000000 millis
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:2664   .bss:00000003 g_Millis
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:143    .text:00000020 __vector_9
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:2639   .data:0000012b interval
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:194    .text:00000076 __vector_13
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:227    .text:00000096 __vector_16
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:2669   .bss:0000000c c1.1892
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:2668   .bss:0000000b c2.1893
                            *COM*:00000001 mode
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:348    .text:00000132 __vector_18
                            *COM*:00000001 r_in
                            *COM*:00000020 rbuf
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:398    .text:00000170 __vector_19
                            *COM*:00000001 t_in
                            *COM*:00000001 t_out
                            *COM*:00000020 tbuf
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:461    .text:000001ca tbuflen
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:483    .text:000001d6 UART_putchar
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:540    .text:00000222 rbuflen
                            *COM*:00000001 r_out
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:561    .text:0000022e UART_getchar
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:601    .text:00000254 exp_slope
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:650    .text:00000294 get_slope2
                            *COM*:0000000c t_array
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:2666   .bss:00000008 last_slope.2051
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:695    .text:000002da add_value
                            *COM*:00000002 slope2
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:810    .text:000003a0 get_slope
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:887    .text:00000420 get_last_slope
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:913    .text:0000043a _beep
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:995    .text:00000478 set_relais
                             .bss:00000007 last.2165
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:1063   .text:000004be beep
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:1233   .text:00000546 __vector_1
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:2667   .bss:0000000a running.1919
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:1499   .text:00000678 get_temperature
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:1596   .text:000006e8 print_array
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:1734   .text:000007e4 UART_first_init
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:1805   .text:0000080c main
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:2646   .bss:00000000 off_counter
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:2652   .bss:00000001 flash_button
C:\Users\Thorsten\AppData\Local\Temp/ccE95cYH.s:2658   .bss:00000002 flash_LED

UNDEFINED SYMBOLS
__divmodhi4
__udivmodhi4
puts
i2c_start
i2c_write
i2c_rep_start
i2c_readAck
i2c_stop
printf
putchar
fdevopen
i2c_init
initVL53L0X
setSignalRateLimit
__udivmodqi4
readRangeSingleMillimeters
timeoutOccurred
__do_copy_data
__do_clear_bss
