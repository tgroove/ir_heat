   1               		.file	"ir_heat.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  87               	.global	__vector_9
  89               	__vector_9:
   1:ir_heat.c     **** // ***********************************************************
   2:ir_heat.c     **** // Project:
   3:ir_heat.c     **** // Author:
   4:ir_heat.c     **** // Module description:
   5:ir_heat.c     **** // ***********************************************************
   6:ir_heat.c     **** 
   7:ir_heat.c     **** #ifndef F_CPU
   8:ir_heat.c     **** #define F_CPU 1000000UL
   9:ir_heat.c     **** #endif
  10:ir_heat.c     **** 
  11:ir_heat.c     **** #include <avr\io.h>              // Most basic include files
  12:ir_heat.c     **** #include <avr\interrupt.h>       // Add the necessary ones
  13:ir_heat.c     **** //#include <avr\signal.h>          // here
  14:ir_heat.c     **** #include <avr\wdt.h>
  15:ir_heat.c     **** 
  16:ir_heat.c     **** #include <stdio.h>
  17:ir_heat.c     **** #include <string.h>
  18:ir_heat.c     **** #include <stdlib.h>
  19:ir_heat.c     **** #include	<util/delay.h>
  20:ir_heat.c     **** 
  21:ir_heat.c     **** #include "i2c_mstr.h"
  22:ir_heat.c     **** #include "ir_heat.h"
  23:ir_heat.c     **** 
  24:ir_heat.c     **** #define 	MLX90614_WRITE	(0x5A<<1)
  25:ir_heat.c     **** #define 	MLX90614_READ	(MLX90614_WRITE+1)
  26:ir_heat.c     **** #define	ADR_T_A			0x06
  27:ir_heat.c     **** #define	ADR_T_OBJ1		0x07
  28:ir_heat.c     **** #define	ADR_T_OBJ2		0x08
  29:ir_heat.c     **** 
  30:ir_heat.c     **** 
  31:ir_heat.c     **** #define __STDIO_FDEVOPEN_COMPAT_12						
  32:ir_heat.c     **** // Buffer sizes must be 2^n
  33:ir_heat.c     **** //
  34:ir_heat.c     **** #define TBUFSIZE			32
  35:ir_heat.c     **** #define RBUFSIZE			32
  36:ir_heat.c     **** 
  37:ir_heat.c     **** #define TMASK				(TBUFSIZE-1)
  38:ir_heat.c     **** #define RMASK				(RBUFSIZE-1)
  39:ir_heat.c     **** 
  40:ir_heat.c     **** #define FLASH_LED			PC3
  41:ir_heat.c     **** #define STATUS_LED1		PD4
  42:ir_heat.c     **** #define STATUS_LED2		PD3
  43:ir_heat.c     **** #define RELAIS				PB6
  44:ir_heat.c     **** #define BUZZER				PB7
  45:ir_heat.c     **** #define SWITCH				PD2
  46:ir_heat.c     **** 
  47:ir_heat.c     **** #define RELAIS_ON			PORTB |= (1<<RELAIS)
  48:ir_heat.c     **** #define RELAIS_OFF		PORTB &=~(1<<RELAIS)
  49:ir_heat.c     **** 
  50:ir_heat.c     **** #define BUZZER_ON			PORTB |= (1<<BUZZER)
  51:ir_heat.c     **** #define BUZZER_OFF		PORTB &=~(1<<BUZZER)
  52:ir_heat.c     **** 
  53:ir_heat.c     **** #define STATUS_LED1_ON	PORTD |= (1<<STATUS_LED1)
  54:ir_heat.c     **** #define STATUS_LED1_OFF	PORTD &=~(1<<STATUS_LED1)
  55:ir_heat.c     **** 
  56:ir_heat.c     **** #define FLASH_LED_ON		PORTC |= (1<<FLASH_LED)
  57:ir_heat.c     **** #define FLASH_LED_OFF	PORTC &=~(1<<FLASH_LED)
  58:ir_heat.c     **** 
  59:ir_heat.c     **** #define STATUS_LED2_ON	PORTD |= (1<<STATUS_LED2)
  60:ir_heat.c     **** #define STATUS_LED2_OFF	PORTD &=~(1<<STATUS_LED2)
  61:ir_heat.c     **** 
  62:ir_heat.c     **** #define OFF_COUNTER		2
  63:ir_heat.c     **** 
  64:ir_heat.c     **** #define TIMER1_STOP		TCCR1B = 0
  65:ir_heat.c     **** #define TIMER1_RUN		TCCR1B = (0<<CS12) | (1<<CS11) | (0<<CS10)
  66:ir_heat.c     **** 
  67:ir_heat.c     **** #define	MODE_OFF				0
  68:ir_heat.c     **** #define	MODE_ON				1
  69:ir_heat.c     **** #define	MODE_ON_NO_PROT	2
  70:ir_heat.c     **** #define	MODE_TEMP_PROT		3
  71:ir_heat.c     **** 
  72:ir_heat.c     **** #define	BEEP_SHORT			1
  73:ir_heat.c     **** #define	BEEP_2SHORT			2
  74:ir_heat.c     **** #define	BEEP_LONG			3
  75:ir_heat.c     **** #define	BEEP_XLONG			4
  76:ir_heat.c     **** #define	BEEP_2LONG			5
  77:ir_heat.c     **** #define	BEEP_SHORT_LONG	6
  78:ir_heat.c     **** 
  79:ir_heat.c     **** // Define here the global static variables
  80:ir_heat.c     **** //
  81:ir_heat.c     **** volatile unsigned char tbuf[TBUFSIZE];  // TX buffer
  82:ir_heat.c     **** volatile unsigned char rbuf[RBUFSIZE];  // RX buffer
  83:ir_heat.c     **** 
  84:ir_heat.c     **** volatile unsigned char t_in;            // TX buffer in index
  85:ir_heat.c     **** volatile unsigned char t_out;           // TX buffer out index
  86:ir_heat.c     **** 
  87:ir_heat.c     **** volatile unsigned char r_in;            // RX buffer in index
  88:ir_heat.c     **** volatile unsigned char r_out;           // RX buffer out index
  89:ir_heat.c     **** 
  90:ir_heat.c     **** int8_t	interval = -12;
  91:ir_heat.c     **** int16_t 	t_array[6];
  92:ir_heat.c     **** uint8_t	off_counter = 0;
  93:ir_heat.c     **** uint8_t	mode;
  94:ir_heat.c     **** int16_t	slope2;
  95:ir_heat.c     **** uint8_t	flash_button = 0;
  96:ir_heat.c     **** uint8_t	flash_LED = 0;
  97:ir_heat.c     **** 
  98:ir_heat.c     **** /*
  99:ir_heat.c     **** uint16_t	t_la_threshold_up 	=  300;
 100:ir_heat.c     **** uint16_t	t_abs_threshold_up 	=  270;
 101:ir_heat.c     **** uint16_t	t_la_threshold_down 	=  250;
 102:ir_heat.c     **** uint16_t	t_abs_threshold_down	=  250;
 103:ir_heat.c     **** */
 104:ir_heat.c     **** 
 105:ir_heat.c     **** 
 106:ir_heat.c     **** // Clock Timer
 107:ir_heat.c     **** SIGNAL(SIG_OVERFLOW2) {
  90               	ush r0
  91               		clr __zero_reg__
  92               		push r24
  93 0000 1F92      	/* prologue: Signal */
  94 0002 0F92      	/* frame size = 0 */
  96 0006 0F92      	.LM1:
  97 0008 1124      		lds r24,interval
  98 000a 8F93      		subi r24,lo8(-(1))
  99               		sts interval,r24
 100               	/* epilogue start */
 108:ir_heat.c     **** 	interval++;
 101               	0,109,.LM2-.LFBB1
 102               	.LM2:
 103 000c 8091 0000 		pop r24
 104 0010 8F5F      		pop r0
 105 0012 8093 0000 		out __SREG__,r0
 106               		pop r0
 109:ir_heat.c     **** }
 107               	_zero_reg__
 108               		reti
 110 0018 0F90      	.Lscope1:
 112 001c 0F90      	.global	__vector_13
 114 0020 1895      	__vector_13:
 116               	.LM3:
 117               	.LFBB2:
 118               		push __zero_reg__
 119               		push r0
 120               		in r0,__SREG__
 110:ir_heat.c     **** 
 111:ir_heat.c     **** SIGNAL(SIG_OVERFLOW1) {
 121               	__zero_reg__
 122               	/* prologue: Signal */
 123               	/* frame size = 0 */
 125 0024 0F92      	.LM4:
 126 0026 0FB6      		sts 129,__zero_reg__
 128 002a 1124      	.LM5:
 129               		sts 133,__zero_reg__
 112:ir_heat.c     **** 	TIMER1_STOP;
 131               	 132,__zero_reg__
 132               	/* epilogue start */
 113:ir_heat.c     **** 	TCNT1H = 0;
 134               	7:
 135               		pop r0
 136 0030 1092 8500 		out __SREG__,r0
 114:ir_heat.c     **** 	TCNT1L = 0;
 137               	p r0
 138               		pop __zero_reg__
 139 0034 1092 8400 		reti
 115:ir_heat.c     **** }
 141               	ope2:
 143 0038 0F90      	.global	__vector_16
 145 003c 0F90      	__vector_16:
 147 0040 1895      	.LM8:
 148               	.LFBB3:
 149               		push __zero_reg__
 150               		push r0
 151               		in r0,__SREG__
 152               		push r0
 153               		clr __zero_reg__
 116:ir_heat.c     **** 
 117:ir_heat.c     **** 
 118:ir_heat.c     **** // LED Flasher
 119:ir_heat.c     **** SIGNAL(SIG_OVERFLOW0) {
 154               	sh r19
 155               		push r20
 156               		push r24
 157 0042 1F92      		push r25
 158 0044 0F92      		push r30
 159 0046 0FB6      		push r31
 160 0048 0F92      	/* prologue: Signal */
 161 004a 1124      	/* frame size = 0 */
 163 004e 3F93      	.LM9:
 164 0050 4F93      		lds r24,c1.1724
 165 0052 8F93      		mov r18,r24
 166 0054 9F93      		subi r18,lo8(-(1))
 167 0056 EF93      		sts c1.1724,r18
 169               	.LM10:
 170               		lds r24,c2.1725
 120:ir_heat.c     **** 	static uint8_t	c1 = 0;
 121:ir_heat.c     **** 	static uint8_t c2 = 0;
 122:ir_heat.c     **** 	uint8_t slow=0;
 123:ir_heat.c     **** 	c1++;
 171               	i r19,lo8(-(1))
 172               		sts c2.1725,r19
 174 005e 282F      	.LM11:
 175 0060 2F5F      		lds r20,mode
 176 0062 2093 0000 		cpi r20,lo8(3)
 124:ir_heat.c     **** 	c2++;
 177               	.L6
 179 0066 8091 0000 	.LM12:
 180 006a 382F      		mov r24,r18
 181 006c 3F5F      		ldi r25,lo8(0)
 182 006e 3093 0000 		sbiw r24,7
 125:ir_heat.c     **** 	
 126:ir_heat.c     **** 	// Tasten LED
 127:ir_heat.c     **** 	if (mode==MODE_TEMP_PROT) {
 183               	.L6
 185 0072 4091 0000 	.LM13:
 186 0076 4330      		ldi r30,lo8(40)
 187 0078 01F4      		ldi r31,hi8(40)
 128:ir_heat.c     **** 		if(c1 > (6<<slow)) {
 188               	24,Z
 189               		ori r24,lo8(8)
 190 007a 822F      		st Z,r24
 191 007c 90E0      	.L6:
 193 0080 04F0      	.LM14:
 129:ir_heat.c     **** 			FLASH_LED_ON;
 194               	24,r18
 195               		ldi r25,lo8(0)
 196 0082 E8E2      		sbiw r24,11
 197 0084 F0E0      		brlt .L7
 199 0088 8860      	.LM15:
 200 008a 8083      		sts c1.1724,__zero_reg__
 130:ir_heat.c     **** 		}
 131:ir_heat.c     **** 	}
 132:ir_heat.c     **** 	if(c1 > (10<<slow)) {
 202               	ldi r30,lo8(40)
 203               		ldi r31,hi8(40)
 204 008c 822F      		ld r24,Z
 205 008e 90E0      		andi r24,lo8(-9)
 206 0090 0B97      		st Z,r24
 207 0092 04F0      	.L7:
 133:ir_heat.c     **** 		c1 = 0;
 208               	n	68,0,138,.LM17-.LFBB3
 209               	.LM17:
 210 0094 1092 0000 		cpi r20,lo8(2)
 134:ir_heat.c     **** 		FLASH_LED_OFF;
 211               	ne .L8
 213 0098 E8E2      	.LM18:
 214 009a F0E0      		cpi r19,lo8(121)
 215 009c 8081      		brlo .L8
 217 00a0 8083      	.LM19:
 218               		ldi r30,lo8(43)
 135:ir_heat.c     **** 	}
 136:ir_heat.c     **** 	
 137:ir_heat.c     **** 	// Status LED
 138:ir_heat.c     **** 	if (mode==MODE_ON_NO_PROT) {
 219               	,hi8(43)
 220               		ld r24,Z
 221 00a2 4230      		andi r24,lo8(-17)
 222 00a4 01F4      		st Z,r24
 139:ir_heat.c     **** 		if(c2 > 120) {
 223               	
 225 00a6 3937      	.LM20:
 226 00a8 00F0      		cpi r19,lo8(-120)
 140:ir_heat.c     **** 			STATUS_LED1_OFF;	// rot
 227               	lo .L10
 229 00aa EBE2      	.LM21:
 230 00ac F0E0      		sts c2.1725,__zero_reg__
 232 00b0 8F7E      	.LM22:
 233 00b2 8083      		ldi r30,lo8(43)
 234               		ldi r31,hi8(43)
 141:ir_heat.c     **** 		}
 142:ir_heat.c     **** 	}
 143:ir_heat.c     **** 	if(c2 > 135) {
 235               	Z
 236               		ori r24,lo8(16)
 237 00b4 3838      		st Z,r24
 238 00b6 00F0      	.L10:
 144:ir_heat.c     **** 		c2 = 0;
 239               	pilogue start */
 241 00b8 1092 0000 	.LM23:
 145:ir_heat.c     **** 		STATUS_LED1_ON; 		// orange
 242               	p r31
 243               		pop r30
 244 00bc EBE2      		pop r25
 245 00be F0E0      		pop r24
 246 00c0 8081      		pop r20
 247 00c2 8061      		pop r19
 248 00c4 8083      		pop r18
 249               		pop r0
 250               		out __SREG__,r0
 146:ir_heat.c     **** 	}	
 147:ir_heat.c     **** }
 251               	pop __zero_reg__
 252               		reti
 258 00d0 3F91      	.Lscope3:
 260 00d4 0F90      	.global	__vector_18
 262 00d8 0F90      	__vector_18:
 264 00dc 1895      	.LM24:
 265               	.LFBB4:
 266               		push __zero_reg__
 267               		push r0
 268               		in r0,__SREG__
 269               		push r0
 270               		clr __zero_reg__
 271               		push r24
 272               		push r30
 273               		push r31
 274               	/* prologue: Signal */
 148:ir_heat.c     **** 
 149:ir_heat.c     **** 
 150:ir_heat.c     **** 
 151:ir_heat.c     **** //*******************************************
 152:ir_heat.c     **** //
 153:ir_heat.c     **** // Taster IQR und Entprellung
 154:ir_heat.c     **** //
 155:ir_heat.c     **** SIGNAL(SIG_INTERRUPT0) {
 156:ir_heat.c     **** 	static uint8_t running = 0;
 157:ir_heat.c     **** 	
 158:ir_heat.c     **** 	if(running | TCNT1H | TCNT1L){
 159:ir_heat.c     **** //		printf("X");
 160:ir_heat.c     **** 		return;
 161:ir_heat.c     **** 	}
 162:ir_heat.c     **** 	running = 1;
 163:ir_heat.c     **** 	wdt_reset();
 164:ir_heat.c     **** 	
 165:ir_heat.c     **** 	uint16_t i;
 166:ir_heat.c     **** 	uint16_t c = 0;
 167:ir_heat.c     **** 	EIMSK = 0;
 168:ir_heat.c     **** 	sei();
 169:ir_heat.c     **** 	//printf("In");
 170:ir_heat.c     **** 	for(i=0;i<1000;i++) if((PIND & (1<<SWITCH))) c++;
 171:ir_heat.c     **** 	//printf(" %i ", c);
 172:ir_heat.c     **** 
 173:ir_heat.c     **** 	if(c < 200) {
 174:ir_heat.c     **** 		TCNT1L = 1;
 175:ir_heat.c     **** 		TIMER1_RUN;
 176:ir_heat.c     **** 		switch(mode) {
 177:ir_heat.c     **** 		case MODE_OFF:
 178:ir_heat.c     **** 			mode = MODE_ON;
 179:ir_heat.c     **** 			set_relais(1);
 180:ir_heat.c     **** 			STATUS_LED1_ON;			// orange
 181:ir_heat.c     **** 			STATUS_LED2_ON;
 182:ir_heat.c     **** 			c = 0;
 183:ir_heat.c     **** 			while((!(PIND & (1<<SWITCH))) && (c < 300)) {
 184:ir_heat.c     **** 				c++;
 185:ir_heat.c     **** 				_delay_ms (10);
 186:ir_heat.c     **** 			}
 187:ir_heat.c     **** 			//printf("c: %i", c);
 188:ir_heat.c     **** 
 189:ir_heat.c     **** 			if(c < 300) {
 190:ir_heat.c     **** 				// normal einnschalten
 191:ir_heat.c     **** 				mode = MODE_ON;
 192:ir_heat.c     **** 			}
 193:ir_heat.c     **** 			else {
 194:ir_heat.c     **** 				// einschalten, aber ohne Hitzeschutz
 195:ir_heat.c     **** 				mode = MODE_ON_NO_PROT;
 196:ir_heat.c     **** 				printf("Temperature Protection Off!\n");
 197:ir_heat.c     **** 				STATUS_LED1_OFF;		// rot
 198:ir_heat.c     **** 				STATUS_LED2_ON;
 199:ir_heat.c     **** 				beep(BEEP_SHORT_LONG);
 200:ir_heat.c     **** 			}
 201:ir_heat.c     **** 			break;
 202:ir_heat.c     **** 		case MODE_ON:
 203:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 204:ir_heat.c     **** 		case MODE_TEMP_PROT:
 205:ir_heat.c     **** 		default:
 206:ir_heat.c     **** 			printf("\nxXx\n");
 207:ir_heat.c     **** 			mode = MODE_OFF;
 208:ir_heat.c     **** 		}
 209:ir_heat.c     **** 	}
 210:ir_heat.c     **** //	printf("Out\n");
 211:ir_heat.c     **** 	EIFR 		= (1<<INTF0);
 212:ir_heat.c     **** 	EIMSK 	= (1<<INT0);
 213:ir_heat.c     **** 	running 	= 0;
 214:ir_heat.c     **** 	//printf("Exit\n");
 215:ir_heat.c     **** }
 216:ir_heat.c     **** 
 217:ir_heat.c     **** 
 218:ir_heat.c     **** 
 219:ir_heat.c     **** SIGNAL(SIG_USART_RECV) {
 275               	tabn	68,0,224,.LM25-.LFBB4
 276               	.LM25:
 277               		lds r24,198
 279 00e0 0F92      	.LM26:
 280 00e2 0FB6      		lds r30,r_in
 281 00e4 0F92      		ldi r31,lo8(0)
 282 00e6 1124      		andi r30,lo8(31)
 283 00e8 8F93      		andi r31,hi8(31)
 284 00ea EF93      		subi r30,lo8(-(rbuf))
 285 00ec FF93      		sbci r31,hi8(-(rbuf))
 286               		st Z,r24
 220:ir_heat.c     **** //******************
 221:ir_heat.c     **** // RX interrupt handler
 222:ir_heat.c     **** //
 223:ir_heat.c     **** 	char c;	
 224:ir_heat.c     **** 	c = UDR0;							// Get received char
 288               	24,r_in
 289               		subi r24,lo8(-(1))
 290 00ee 8091 C600 		sts r_in,r24
 225:ir_heat.c     **** 	rbuf[r_in & RMASK] = c;
 291               	epilogue start */
 293 00f2 E091 0000 	.LM28:
 294 00f6 F0E0      		pop r31
 295 00f8 EF71      		pop r30
 296 00fa F070      		pop r24
 297 00fc E050      		pop r0
 298 00fe F040      		out __SREG__,r0
 299 0100 8083      		pop r0
 226:ir_heat.c     **** 	r_in++;
 300               	ro_reg__
 301               		reti
 227:ir_heat.c     **** }
 306               	e4:
 308 010c FF91      	.global	__vector_19
 310 0110 8F91      	__vector_19:
 312 0114 0FBE      	.LM29:
 313 0116 0F90      	.LFBB5:
 314 0118 1F90      		push __zero_reg__
 315 011a 1895      		push r0
 316               		in r0,__SREG__
 317               		push r0
 318               		clr __zero_reg__
 319               		push r24
 320               		push r25
 321               		push r30
 322               		push r31
 323               	/* prologue: Signal */
 324               	/* frame size = 0 */
 228:ir_heat.c     **** 
 229:ir_heat.c     **** SIGNAL(SIG_USART_DATA) {
 325               	M30-.LFBB5
 326               	.LM30:
 327               		lds r25,t_in
 328 011c 1F92      		lds r24,t_out
 329 011e 0F92      		cp r25,r24
 330 0120 0FB6      		breq .L14
 332 0124 1124      	.LM31:
 333 0126 8F93      		lds r30,t_out
 334 0128 9F93      		ldi r31,lo8(0)
 335 012a EF93      		andi r30,lo8(31)
 336 012c FF93      		andi r31,hi8(31)
 337               		subi r30,lo8(-(tbuf))
 338               		sbci r31,hi8(-(tbuf))
 230:ir_heat.c     **** //*******************
 231:ir_heat.c     **** // Data register empty interrupt handler.
 232:ir_heat.c     **** // Indicates that next char can be transmitted
 233:ir_heat.c     **** //
 234:ir_heat.c     **** 	if(t_in != t_out) {
 339               	 198,r24
 341 012e 9091 0000 	.LM32:
 342 0132 8091 0000 		lds r24,t_out
 343 0136 9817      		subi r24,lo8(-(1))
 344 0138 01F0      		sts t_out,r24
 235:ir_heat.c     **** 		UDR0 = tbuf[t_out & TMASK];
 345               	.L16
 346               	.L14:
 348 013e F0E0      	.LM33:
 349 0140 EF71      		ldi r30,lo8(193)
 350 0142 F070      		ldi r31,hi8(193)
 351 0144 E050      		ld r24,Z
 352 0146 F040      		andi r24,lo8(-33)
 353 0148 8081      		st Z,r24
 354 014a 8093 C600 	.L16:
 236:ir_heat.c     **** 		t_out++;	
 355               	e start */
 357 014e 8091 0000 	.LM34:
 358 0152 8F5F      		pop r31
 359 0154 8093 0000 		pop r30
 360 0158 00C0      		pop r25
 361               		pop r24
 237:ir_heat.c     **** 	}
 238:ir_heat.c     **** 	else {
 239:ir_heat.c     **** 		UCSR0B &= ~(1<<UDRIE0);
 362               	
 363               		out __SREG__,r0
 364 015a E1EC      		pop r0
 365 015c F0E0      		pop __zero_reg__
 366 015e 8081      		reti
 368 0162 8083      	.Lscope5:
 370               	.global	tbuflen
 240:ir_heat.c     **** 	}
 241:ir_heat.c     **** }
 371               	buflen, @function
 372               	tbuflen:
 374 0166 EF91      	.LM35:
 375 0168 9F91      	.LFBB6:
 376 016a 8F91      	/* prologue: function */
 377 016c 0F90      	/* frame size = 0 */
 379 0170 0F90      	.LM36:
 380 0172 1F90      		lds r24,t_in
 381 0174 1895      		lds r25,t_out
 383               	.LM37:
 384               		sub r24,r25
 385               	/* epilogue start */
 386               		ret
 242:ir_heat.c     **** 
 243:ir_heat.c     **** char tbuflen(void) {
 388               		"UART_putchar:F(0,1)",36,0,0,UART_putchar
 391               	.global	UART_putchar
 244:ir_heat.c     **** //****************
 245:ir_heat.c     **** // Retrieve pending chars in TX buffer
 246:ir_heat.c     **** //
 247:ir_heat.c     **** 	return(t_in - t_out);
 393               	putchar:
 395 0176 8091 0000 	.LM38:
 396 017a 9091 0000 	.LFBB7:
 248:ir_heat.c     **** }
 397               	h r17
 398               		push r28
 399 017e 891B      		push r29
 400               	/* prologue: function */
 401 0180 0895      	/* frame size = 0 */
 402               		mov r17,r24
 404               	.LM39:
 405               		ldi r28,lo8(32)
 406               		ldi r29,hi8(32)
 407               	.L20:
 408               		call tbuflen
 409               		movw r18,r28
 249:ir_heat.c     **** 
 250:ir_heat.c     **** int UART_putchar(char c, FILE *stream) {
 410               		sbc r19,__zero_reg__
 411               		cpi r18,3
 412               		cpc r19,__zero_reg__
 413 0182 1F93      		brlt .L20
 415 0186 DF93      	.LM40:
 416               		lds r30,t_in
 417               		ldi r31,lo8(0)
 418 0188 182F      		andi r30,lo8(31)
 251:ir_heat.c     **** //*********************
 252:ir_heat.c     **** // Fills the transmit buffer, if it is full wait
 253:ir_heat.c     **** //
 254:ir_heat.c     **** 	while((TBUFSIZE - tbuflen()) <= 2);  // Wait...
 419               	,hi8(31)
 420               		subi r30,lo8(-(tbuf))
 421 018a C0E2      		sbci r31,hi8(-(tbuf))
 422 018c D0E0      		st Z,r17
 424 018e 0E94 0000 	.LM41:
 425 0192 9E01      		lds r24,t_in
 426 0194 281B      		subi r24,lo8(-(1))
 427 0196 3109      		sts t_in,r24
 429 019a 3105      	.LM42:
 430 019c 04F0      		ldi r30,lo8(193)
 255:ir_heat.c     **** 	
 256:ir_heat.c     **** 	// Add data to the transmit buffer, enable TXCIE
 257:ir_heat.c     **** 	//
 258:ir_heat.c     **** 	tbuf[t_in & TMASK] = c;
 431               	(193)
 432               		ld r24,Z
 433 019e E091 0000 		ori r24,lo8(32)
 434 01a2 F0E0      		st Z,r24
 436 01a6 F070      	.LM43:
 437 01a8 E050      		ldi r24,lo8(0)
 438 01aa F040      		ldi r25,hi8(0)
 439 01ac 1083      	/* epilogue start */
 259:ir_heat.c     **** 	t_in++;	
 440               		pop r28
 441               		pop r17
 442 01ae 8091 0000 		ret
 444 01b4 8093 0000 	.Lscope7:
 260:ir_heat.c     **** 	UCSR0B |= (1<<UDRIE0);			// Enable UDR empty interrupt	
 445               	bs	"rbuflen:F(0,2)",36,0,0,rbuflen
 446               	.global	rbuflen
 448 01ba F0E0      	rbuflen:
 450 01be 8062      	.LM44:
 451 01c0 8083      	.LFBB8:
 261:ir_heat.c     **** 	return(0);
 262:ir_heat.c     **** }
 452               	ogue: function */
 453               	/* frame size = 0 */
 455 01c4 90E0      	.LM45:
 456               		lds r24,r_in
 457 01c6 DF91      		lds r25,r_out
 459 01ca 1F91      	.LM46:
 460 01cc 0895      		sub r24,r25
 461               	/* epilogue start */
 462               		ret
 464               	.Lscope8:
 263:ir_heat.c     **** 
 264:ir_heat.c     **** char rbuflen(void) {
 467               	tchar
 469               	UART_getchar:
 471               	.LM47:
 265:ir_heat.c     **** // ***************
 266:ir_heat.c     **** // Retrive pending chars in RX buffer
 267:ir_heat.c     **** //
 268:ir_heat.c     **** 	return(r_in - r_out);
 472               	9:
 473               	/* prologue: function */
 474 01ce 8091 0000 	/* frame size = 0 */
 475 01d2 9091 0000 	.L26:
 269:ir_heat.c     **** }
 476               	abn	68,0,277,.LM48-.LFBB9
 477               	.LM48:
 478 01d6 891B      		call rbuflen
 479               		tst r24
 480 01d8 0895      		breq .L26
 482               	.LM49:
 483               		lds r30,r_out
 484               		ldi r31,lo8(0)
 485               		andi r30,lo8(31)
 486               		andi r31,hi8(31)
 487               		subi r30,lo8(-(rbuf))
 270:ir_heat.c     **** 
 271:ir_heat.c     **** int UART_getchar(FILE *stream) {
 488               	8(-(rbuf))
 489               		ld r24,Z
 491               	.LM50:
 492               		lds r25,r_out
 493               		subi r25,lo8(-(1))
 272:ir_heat.c     **** //*******************
 273:ir_heat.c     **** // Retieves character from UART. This function is to be passed
 274:ir_heat.c     **** // to fdevopen
 275:ir_heat.c     **** //
 276:ir_heat.c     **** 	unsigned char c;
 277:ir_heat.c     **** 	while(rbuflen() == 0);	  // Wait...
 494               	_out,r25
 496 01da 0E94 0000 	.LM51:
 497 01de 8823      		ldi r25,lo8(0)
 498 01e0 01F0      	/* epilogue start */
 278:ir_heat.c     **** 	c = rbuf[r_out & RMASK];
 503 01e8 EF71      	.Lscope9:
 505 01ec E050      	.global	add_value
 507 01f0 8081      	add_value:
 279:ir_heat.c     **** 	r_out++;	
 508               	8,0,321,.LM52-.LFBB10
 509               	.LM52:
 510 01f2 9091 0000 	.LFBB10:
 511 01f6 9F5F      	/* prologue: function */
 512 01f8 9093 0000 	/* frame size = 0 */
 280:ir_heat.c     **** 	return(c);
 281:ir_heat.c     **** }
 513               	r20,r24
 514               		mov r21,r25
 516               	.LM53:
 517 01fe 0895      		lds r24,t_array
 518               		lds r25,(t_array)+1
 519               		or r24,r25
 520               		brne .L30
 522               	.LM54:
 523               		ldi r30,lo8(t_array+10)
 524               		ldi r31,hi8(t_array+10)
 525               		st Z,r20
 526               		std Z+1,r21
 282:ir_heat.c     **** 
 283:ir_heat.c     **** void UART_first_init(void) {
 284:ir_heat.c     **** //***********************
 285:ir_heat.c     **** // The function fdevopen(..) must contain as parameters the
 286:ir_heat.c     **** // corresponding  ..putchar() and  ..getchar() functions, defined before.
 287:ir_heat.c     **** //
 288:ir_heat.c     **** 	UBRR0 = 12;										 		// 4800 BPS
 289:ir_heat.c     **** 	
 290:ir_heat.c     **** 	UCSR0B = (1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0);	// 8 Databits, receive and transmit enabled, receive a
 291:ir_heat.c     **** 	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
 292:ir_heat.c     **** 	
 293:ir_heat.c     **** 	fdevopen(UART_putchar, UART_getchar);
 294:ir_heat.c     **** 	sei();											 		// Global interrupt enable
 295:ir_heat.c     **** }
 296:ir_heat.c     **** 
 297:ir_heat.c     **** 
 298:ir_heat.c     **** 
 299:ir_heat.c     **** //*********************************************
 300:ir_heat.c     **** //
 301:ir_heat.c     **** // Gibt den Temperatur Ringspeicher
 302:ir_heat.c     **** // über den UART aus
 303:ir_heat.c     **** //
 304:ir_heat.c     **** void print_array(){
 305:ir_heat.c     **** 	uint8_t i;
 306:ir_heat.c     ****   	printf("Array:");
 307:ir_heat.c     **** 	for(i=0;i<6;i++) {
 308:ir_heat.c     ****    	printf(" %i", t_array[i]);
 309:ir_heat.c     **** 	}
 310:ir_heat.c     ****   	printf("\n");
 311:ir_heat.c     **** }
 312:ir_heat.c     **** 
 313:ir_heat.c     **** 
 314:ir_heat.c     **** 
 315:ir_heat.c     **** //*********************************************
 316:ir_heat.c     **** //
 317:ir_heat.c     **** // Fügt einen Meßwert zum Ringspeicher hinzu
 318:ir_heat.c     **** // Der Ringspeicher enthält die letzten 6 Werte
 319:ir_heat.c     **** // t_array[5] ist der neuste Wert
 320:ir_heat.c     **** //
 321:ir_heat.c     **** void add_value(uint16_t value) {
 527               		sbiw r26,2
 528               		st X,r20
 529               		adiw r26,1
 530               		st X,r21
 531               		movw r26,r30
 532 0200 482F      		sbiw r26,4
 533 0202 592F      		st X,r20
 322:ir_heat.c     **** 	uint8_t i;
 323:ir_heat.c     **** 	if(t_array[0]==0) {
 534               	26,1
 535               		st X,r21
 536 0204 8091 0000 		movw r26,r30
 537 0208 9091 0000 		sbiw r26,6
 538 020c 892B      		st X,r20
 539 020e 01F4      		adiw r26,1
 324:ir_heat.c     **** 		t_array[0]=t_array[1]=t_array[2]=t_array[3]=t_array[4]=t_array[5]=value;
 540               	r21
 541               		movw r26,r30
 542 0210 E0E0      		sbiw r26,8
 543 0212 F0E0      		st X,r20
 544 0214 4083      		adiw r26,1
 545 0216 5183      		st X,r21
 546 0218 DF01      		sbiw r30,10
 547 021a 1297      		st Z,r20
 548 021c 4C93      		std Z+1,r21
 549 021e 1196      		ret
 550 0220 5C93      	.L30:
 551 0222 DF01      		ldi r30,lo8(t_array)
 552 0224 1497      		ldi r31,hi8(t_array)
 554 0228 1196      	.LM55:
 555 022a 5C93      		ldi r18,lo8(t_array+10)
 556 022c DF01      		ldi r19,hi8(t_array+10)
 557 022e 1697      	.L32:
 559 0232 1196      	.LM56:
 560 0234 5C93      		ldd r24,Z+2
 561 0236 DF01      		ldd r25,Z+3
 562 0238 1897      		st Z+,r24
 563 023a 4C93      		st Z+,r25
 565 023e 5C93      	.LM57:
 566 0240 3A97      		cp r30,r18
 567 0242 4083      		cpc r31,r19
 568 0244 5183      		brne .L32
 570               	.LM58:
 571 0248 E0E0      		mov r18,r20
 572 024a F0E0      		mov r19,r21
 325:ir_heat.c     **** 	}
 326:ir_heat.c     **** 	else {
 327:ir_heat.c     **** 		for(i=0;i<5;i++) {
 573               	ray+10,r18
 575 024c 20E0      	.LM59:
 576 024e 30E0      		lds r24,t_array+8
 577               		lds r25,(t_array+8)+1
 328:ir_heat.c     **** 			t_array[i]=t_array[i+1];
 578               	r18,r24
 579               		sbc r19,r25
 580 0250 8281      		movw r24,r18
 581 0252 9381      		lsl r24
 582 0254 8193      		rol r25
 583 0256 9193      		lsl r18
 584               		rol r19
 585               		lsl r18
 586 0258 E217      		rol r19
 587 025a F307      		lsl r18
 588 025c 01F4      		rol r19
 329:ir_heat.c     **** 		}
 330:ir_heat.c     **** 		t_array[5] = value;
 589               	8
 590               		adc r25,r19
 591 025e 242F      		lds r22,slope2
 592 0260 352F      		lds r23,(slope2)+1
 593 0262 3093 0000 		movw r18,r22
 594 0266 2093 0000 		lsl r18
 331:ir_heat.c     **** 		slope2 = (10*(t_array[5]-t_array[4]) + 19*slope2) / 20;
 595               	19
 596               		movw r20,r18
 597 026a 8091 0000 		lsl r20
 598 026e 9091 0000 		rol r21
 599 0272 281B      		lsl r20
 600 0274 390B      		rol r21
 601 0276 C901      		lsl r20
 602 0278 880F      		rol r21
 603 027a 991F      		add r18,r20
 604 027c 220F      		adc r19,r21
 605 027e 331F      		add r18,r22
 606 0280 220F      		adc r19,r23
 607 0282 331F      		add r24,r18
 608 0284 220F      		adc r25,r19
 609 0286 331F      		ldi r22,lo8(20)
 610 0288 820F      		ldi r23,hi8(20)
 611 028a 931F      		call __divmodhi4
 612 028c 6091 0000 		sts (slope2)+1,r23
 613 0290 7091 0000 		sts slope2,r22
 614 0294 9B01      		ret
 616 0298 331F      	.Lscope10:
 618 029c 440F      	.global	get_slope
 620 02a0 440F      	get_slope:
 622 02a4 440F      	.LM60:
 623 02a6 551F      	.LFBB11:
 624 02a8 240F      	/* prologue: function */
 625 02aa 351F      	/* frame size = 0 */
 627 02ae 371F      	.LM61:
 628 02b0 820F      		ldi r26,lo8(t_array+8)
 629 02b2 931F      		ldi r27,hi8(t_array+8)
 630 02b4 64E1      		movw r30,r26
 631 02b6 70E0      		ld r18,Z+
 632 02b8 0E94 0000 		ld r19,Z+
 633 02bc 7093 0000 		lds r24,t_array+2
 634 02c0 6093 0000 		lds r25,(t_array+2)+1
 635 02c4 0895      		sub r18,r24
 636               		sbc r19,r25
 637               		movw r24,r18
 638               		lsl r24
 639               		rol r25
 640               		lsl r24
 641               		rol r25
 332:ir_heat.c     **** 	}
 333:ir_heat.c     **** }
 334:ir_heat.c     **** 
 335:ir_heat.c     **** 
 336:ir_heat.c     **** 
 337:ir_heat.c     **** //********************************************
 338:ir_heat.c     **** //
 339:ir_heat.c     **** // Gibt die gemittelte Steigung
 340:ir_heat.c     **** // über die letzten 4 Sekunden zurück
 341:ir_heat.c     **** //
 342:ir_heat.c     **** int16_t get_slope() {
 642               	
 643               		ldd r21,Z+1
 644               		ld r18,X+
 645               		ld r19,X
 646               		sbiw r26,1
 647               		sub r20,r18
 648               		sbc r21,r19
 649 02c6 A0E0      		movw r18,r20
 650 02c8 B0E0      		lsl r18
 651 02ca FD01      		rol r19
 652 02cc 2191      		add r18,r20
 653 02ce 3191      		adc r19,r21
 654 02d0 8091 0000 		add r24,r18
 655 02d4 9091 0000 		adc r25,r19
 656 02d8 281B      		adiw r26,6
 657 02da 390B      		ld r20,X+
 658 02dc C901      		ld r21,X
 659 02de 880F      		sbiw r26,6+1
 660 02e0 991F      		adiw r26,4
 661 02e2 880F      		ld r18,X+
 662 02e4 991F      		ld r19,X
 663 02e6 820F      		sbiw r26,4+1
 664 02e8 931F      		sub r20,r18
 665 02ea 1897      		sbc r21,r19
 666 02ec 4081      		movw r18,r20
 667 02ee 5181      		lsl r18
 668 02f0 2D91      		rol r19
 669 02f2 3C91      		add r18,r20
 670 02f4 1197      		adc r19,r21
 671 02f6 421B      		movw r20,r18
 672 02f8 530B      		lsl r20
 673 02fa 9A01      		rol r21
 674 02fc 220F      		lsl r20
 675 02fe 331F      		rol r21
 676 0300 240F      		add r18,r20
 677 0302 351F      		adc r19,r21
 678 0304 820F      		add r24,r18
 679 0306 931F      		adc r25,r19
 680 0308 1696      		ldi r22,lo8(9)
 681 030a 4D91      		ldi r23,hi8(9)
 682 030c 5C91      		call __divmodhi4
 683 030e 1797      		mov r24,r22
 684 0310 1496      		mov r25,r23
 685 0312 2D91      	/* epilogue start */
 687 0316 1597      	.LM62:
 688 0318 421B      		ret
 690 031c 9A01      	.Lscope11:
 692 0320 331F      	.global	get_last_slope
 694 0324 351F      	get_last_slope:
 696 0328 440F      	.LM63:
 697 032a 551F      	.LFBB12:
 698 032c 440F      	/* prologue: function */
 699 032e 551F      	/* frame size = 0 */
 701 0332 351F      	.LM64:
 702 0334 820F      		lds r18,t_array+10
 703 0336 931F      		lds r19,(t_array+10)+1
 704 0338 69E0      		lds r24,t_array+8
 705 033a 70E0      		lds r25,(t_array+8)+1
 706 033c 0E94 0000 		sub r18,r24
 707 0340 862F      		sbc r19,r25
 709               	.LM65:
 343:ir_heat.c     **** 	int16_t s1, s2, s3;
 344:ir_heat.c     **** 
 345:ir_heat.c     **** 	s1 = t_array[5] - t_array[0];
 346:ir_heat.c     **** 	s2 = t_array[4] - t_array[1];
 347:ir_heat.c     **** 	s3 = t_array[3] - t_array[2];
 348:ir_heat.c     **** 	
 349:ir_heat.c     **** 	return ((3*s1+5*s2+15*s3)/9);
 350:ir_heat.c     **** }
 710               	_slope, .-get_last_slope
 711               	.Lscope12:
 714               	.global	_beep
 716               	_beep:
 718               	.LM66:
 351:ir_heat.c     **** 
 352:ir_heat.c     **** 
 353:ir_heat.c     **** 
 354:ir_heat.c     **** //********************************************
 355:ir_heat.c     **** //
 356:ir_heat.c     **** // Gibt die aktuelle Steigung der Temperatur zurück
 357:ir_heat.c     **** // in 0.1°C in 4s
 358:ir_heat.c     **** //
 359:ir_heat.c     **** int16_t	get_last_slope() {
 719               	/* prologue: function */
 720               	/* frame size = 0 */
 722               	.LM67:
 723               		ldi r30,lo8(37)
 724               		ldi r31,hi8(37)
 725               		ld r18,Z
 726 0346 2091 0000 		ori r18,lo8(-128)
 727 034a 3091 0000 		st Z,r18
 729 0352 9091 0000 	.LM68:
 730 0356 281B      		ldi r22,lo8(20)
 731 0358 390B      		ldi r23,hi8(20)
 360:ir_heat.c     ****     return (t_array[5] - t_array[4]);
 361:ir_heat.c     **** }
 732               	odhi4
 733               		mov r24,r22
 734 035a 822F      		mov r25,r23
 735 035c 932F      		sbiw r24,0
 736               		breq .L40
 737 035e 0895      		ldi r18,lo8(0)
 738               		ldi r19,hi8(0)
 739               	.LBB36:
 740               	.LBB37:
 741               	.LBB38:
 742               	.LBB39:
 744               	.Ltext1:
 362:ir_heat.c     **** 
 363:ir_heat.c     **** 
 364:ir_heat.c     **** 
 365:ir_heat.c     **** //********************************************
 366:ir_heat.c     **** //
 367:ir_heat.c     **** // Liest die vom MLX90614 gemessene Temperatur aus
 368:ir_heat.c     **** // Rückgabe in 0.1°C, also 215 = 21.5°C
 369:ir_heat.c     **** //
 370:ir_heat.c     **** uint16_t get_temperature(uint8_t adr) {
 371:ir_heat.c     **** 	uint16_t raw;
 372:ir_heat.c     **** 	uint8_t 	ret;
 373:ir_heat.c     **** 	uint8_t 	lo, hi, pec;
 374:ir_heat.c     **** 	uint8_t	pec_read[6];
 375:ir_heat.c     **** 
 376:ir_heat.c     **** 	i2c_start(MLX90614_WRITE);
 377:ir_heat.c     **** 	i2c_write(adr);
 378:ir_heat.c     **** 	
 379:ir_heat.c     **** 	ret = i2c_rep_start(MLX90614_READ);
 380:ir_heat.c     **** 	if(ret) {
 381:ir_heat.c     **** 		i2c_rep_start(MLX90614_READ);
 382:ir_heat.c     ****    }
 383:ir_heat.c     **** 
 384:ir_heat.c     **** 	lo = i2c_read_ack();
 385:ir_heat.c     **** 	hi = i2c_read_ack();
 386:ir_heat.c     **** 	raw = (uint16_t)(hi<<8)+lo;
 387:ir_heat.c     **** 	pec = i2c_read_ack();
 388:ir_heat.c     **** 	
 389:ir_heat.c     **** 	i2c_stop();
 390:ir_heat.c     **** 	
 391:ir_heat.c     **** 	if(raw & 0x8000) return 0;
 392:ir_heat.c     **** 	
 393:ir_heat.c     **** 	return (raw / 5 - 2731); 					// 1 = 0.1°C
 394:ir_heat.c     **** }
 395:ir_heat.c     **** 
 396:ir_heat.c     **** 
 397:ir_heat.c     **** 
 398:ir_heat.c     **** void _beep(uint16_t duration_ms){
 745               	105,.LM69-.LFBB13
 746               	.LM69:
 747               		ldi r20,lo8(5000)
 748               		ldi r21,hi8(5000)
 749               	.L41:
 399:ir_heat.c     **** 	uint16_t i;
 400:ir_heat.c     **** 	BUZZER_ON;
 750               	 r30,r20
 751               	/* #APP */
 752 0360 E5E2      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 753 0362 F0E0      		1: sbiw r30,1
 754 0364 2081      		brne 1b
 755 0366 2068      	 ;  0 "" 2
 756 0368 2083      	/* #NOAPP */
 401:ir_heat.c     **** 	for(i=0;i<(duration_ms/20);i++) _delay_ms(20);
 757               	
 758               	.LBE38:
 759 036a 64E1      	.LBE37:
 760 036c 70E0      	.LBE36:
 762 0372 862F      	.Ltext2:
 764 0376 0097      	.LM70:
 765 0378 01F0      		subi r18,lo8(-(1))
 766 037a 20E0      		sbci r19,hi8(-(1))
 767 037c 30E0      		cp r18,r24
 768               		cpc r19,r25
 769               		brlo .L41
 770               	.L40:
 772               	.LM71:
 773               		ldi r30,lo8(37)
   1:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   5:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   8:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  11:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      distribution.
  15:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  16:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  20:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  32:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  34:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  37:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  39:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \file */
  40:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \code
  42:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \endcode
  44:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  45:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  53:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  60:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  62:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  63:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  64:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #endif
  68:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  69:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  71:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     register.
  76:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  77:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     can be achieved.
  79:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  80:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
  81:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
  83:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	);
  89:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** }
  90:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  91:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  93:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     counter register pair.
  98:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  99:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****  */
 102:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
 103:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
 105:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 774               	
 775               		ld r24,Z
 776 037e 48E8      		andi r24,lo8(127)
 777 0380 53E1      		st Z,r24
 778               	/* epilogue start */
 780               	.LM72:
 781               		ret
 786               	.Lscope13:
 789               	.global	beep
 791               	beep:
 793               	.LM73:
 794 0388 2F5F      	.LFBB14:
 795 038a 3F4F      	/* prologue: function */
 796 038c 2817      	/* frame size = 0 */
 798 0390 00F0      	.LM74:
 799               	/* #APP */
 402:ir_heat.c     **** 	BUZZER_OFF;
 800               	i
 801               	 ;  0 "" 2
 803 0394 F0E0      	.LM75:
 804 0396 8081      	 ;  408 "ir_heat.c" 1
 805 0398 8F77      		wdr
 806 039a 8083      	 ;  0 "" 2
 403:ir_heat.c     **** }
 808               	* #NOAPP */
 809               		cpi r24,lo8(3)
 810 039c 0895      		breq .L48
 811               		cpi r24,lo8(4)
 812               		brsh .L51
 813               		cpi r24,lo8(1)
 814               		breq .L46
 815               		cpi r24,lo8(2)
 816               		brne .L45
 817               		rjmp .L53
 818               	.L51:
 819               		cpi r24,lo8(4)
 820               		breq .L49
 404:ir_heat.c     **** 
 405:ir_heat.c     **** 
 406:ir_heat.c     **** void	beep(uint8_t type){
 821               	6)
 822               		brne .L45
 823               		rjmp .L54
 824               	.L46:
 407:ir_heat.c     **** 	cli();
 826               	:
 827               		ldi r24,lo8(120)
 828               		ldi r25,hi8(120)
 829               		call _beep
 830 039e F894      		rjmp .L45
 831               	.L48:
 408:ir_heat.c     **** 	wdt_reset();
 832               	n	68,0,414,.LM78-.LFBB14
 833               	.LM78:
 834               		ldi r24,lo8(350)
 835 03a0 A895      		ldi r25,hi8(350)
 836               		call _beep
 409:ir_heat.c     **** 	switch(type){
 837               	 .L45
 838               	.L49:
 840 03a2 8330      	.LM79:
 841 03a4 01F0      		ldi r24,lo8(850)
 842 03a6 8430      		ldi r25,hi8(850)
 843 03a8 00F4      		call _beep
 844 03aa 8130      		rjmp .L45
 845 03ac 01F0      	.L53:
 847 03b0 01F4      	.LM80:
 848 03b2 00C0      		ldi r24,lo8(80)
 849               		ldi r25,hi8(80)
 850 03b4 8430      		call _beep
 851 03b6 01F0      	.LBB40:
 852 03b8 8630      	.LBB41:
 853 03ba 01F4      	.LBB42:
 854 03bc 00C0      	.LBB43:
 410:ir_heat.c     **** 	case BEEP_SHORT:
 411:ir_heat.c     **** 		_beep(120);
 856               	,0,105,.LM81-.LFBB14
 857               	.LM81:
 858 03be 88E7      		ldi r24,lo8(20000)
 859 03c0 90E0      		ldi r25,hi8(20000)
 860 03c2 0E94 0000 	/* #APP */
 861 03c6 00C0      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 862               		1: sbiw r24,1
 412:ir_heat.c     **** 		break;
 413:ir_heat.c     **** 	case BEEP_LONG:
 414:ir_heat.c     **** 		_beep(350);
 863               	b
 864               	 ;  0 "" 2
 865 03c8 8EE5      	/* #NOAPP */
 866 03ca 91E0      	.LBE43:
 867 03cc 0E94 0000 	.LBE42:
 868 03d0 00C0      	.LBE41:
 869               	.LBE40:
 415:ir_heat.c     **** 		break;
 416:ir_heat.c     **** 	case BEEP_XLONG:
 417:ir_heat.c     **** 		_beep(850);
 870               		"ir_heat.c",132,0,0,.Ltext4
 871               	.Ltext4:
 873 03d4 93E0      	.LM82:
 874 03d6 0E94 0000 		ldi r24,lo8(80)
 875 03da 00C0      		ldi r25,hi8(80)
 876               		call _beep
 418:ir_heat.c     **** 		break;
 419:ir_heat.c     **** 	case BEEP_2SHORT:
 420:ir_heat.c     **** 		_beep(80);
 877               	L45
 878               	.L54:
 880 03de 90E0      	.LM83:
 881 03e0 0E94 0000 		ldi r24,lo8(100)
 882               		ldi r25,hi8(100)
 883               		call _beep
 884               	.LBB44:
 885               	.LBB45:
 886               	.LBB46:
 887               	.LBB47:
 889               	.Ltext5:
 891 03e6 9EE4      	.LM84:
 892               		ldi r24,lo8(-20536)
 893               		ldi r25,hi8(-20536)
 894 03e8 0197      	/* #APP */
 895 03ea 01F4      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 896               		1: sbiw r24,1
 897               		brne 1b
 898               	 ;  0 "" 2
 899               	/* #NOAPP */
 900               	.LBE47:
 901               	.LBE46:
 902               	.LBE45:
 903               	.LBE44:
 421:ir_heat.c     **** 		_delay_ms(80);
 422:ir_heat.c     **** 		_beep(80);
 904               	,.Ltext6
 905               	.Ltext6:
 907 03ee 90E0      	.LM85:
 908 03f0 0E94 0000 		ldi r24,lo8(350)
 909 03f4 00C0      		ldi r25,hi8(350)
 910               		call _beep
 423:ir_heat.c     **** 		break;
 424:ir_heat.c     **** 	case BEEP_SHORT_LONG:
 425:ir_heat.c     **** 		_beep(100);
 912               	.LM86:
 913 03f6 84E6      	/* #APP */
 914 03f8 90E0      	 ;  429 "ir_heat.c" 1
 915 03fa 0E94 0000 		sei
 916               	 ;  0 "" 2
 917               	/* epilogue start */
 919               	.LM87:
 920               	/* #NOAPP */
 921               		ret
 923               	.Lscope14:
 924 03fe 88EC      		.data
 925 0400 9FEA      	.LC0:
 926               		.string	">>> Relais ON"
 927               	.LC1:
 928 0402 0197      		.string	">>> Relais OFF"
 929 0404 01F4      		.text
 932               	.global	set_relais
 934               	set_relais:
 936               	.LM88:
 937               	.LFBB15:
 426:ir_heat.c     **** 		_delay_ms(180);
 427:ir_heat.c     **** 		_beep(350);		
 938               	tion */
 939               	/* frame size = 0 */
 940 0406 8EE5      		mov r17,r24
 942 040a 0E94 0000 	.LM89:
 943               		tst r24
 428:ir_heat.c     **** 	}
 429:ir_heat.c     **** 	sei();	
 944               	.L56
 946               	.LM90:
 947               		lds r24,last.1975
 948 040e 7894      		cp r17,r24
 949               		breq .L57
 950               		ldi r24,lo8(.LC0)
 430:ir_heat.c     **** }
 951               	5,hi8(.LC0)
 952               		call puts
 953               	.L57:
 955               	.LM91:
 956               		ldi r30,lo8(37)
 957               		ldi r31,hi8(37)
 958               		ld r24,Z
 959 0000 3E3E 3E20 		ori r24,lo8(64)
 959      5265 6C61 
 959      6973 204F 
 959      4E00 
 960               		st Z,r24
 961 000e 3E3E 3E20 		rjmp .L58
 961      5265 6C61 
 961      6973 204F 
 961      4646 00
 962               	.L56:
 964               	.LM92:
 965               		lds r24,last.1975
 966               		tst r24
 967               		breq .L59
 431:ir_heat.c     **** 
 432:ir_heat.c     **** 
 433:ir_heat.c     **** 
 434:ir_heat.c     **** //***************************************************
 435:ir_heat.c     **** //
 436:ir_heat.c     **** // Relais Ein- und Ausschalen
 437:ir_heat.c     **** //
 438:ir_heat.c     **** void set_relais(uint8_t on) {
 968               	)
 969               		ldi r25,hi8(.LC1)
 970               		call puts
 971 0412 1F93      	.L59:
 973               	.LM93:
 974 0414 182F      		ldi r30,lo8(37)
 439:ir_heat.c     **** 	static uint8_t last = 0;
 440:ir_heat.c     **** 	if(on) {
 975               	1,hi8(37)
 976               		ld r24,Z
 977 0416 8823      		andi r24,lo8(-65)
 978 0418 01F0      		st Z,r24
 441:ir_heat.c     **** 		if(on != last) printf(">>> Relais ON\n");
 979               	:
 981 041a 8091 0000 	.LM94:
 982 041e 1817      		sts last.1975,r17
 983 0420 01F0      	/* epilogue start */
 985 0424 90E0      	.LM95:
 986 0426 0E94 0000 		pop r17
 987               		ret
 442:ir_heat.c     **** 		RELAIS_ON;
 988               	t_relais, .-set_relais
 992 042e 8081      	.Lscope15:
 993 0430 8064      		.data
 994 0432 8083      	.LC2:
 995 0434 00C0      		.string	"Temperature Protection Off!"
 996               	.LC3:
 443:ir_heat.c     **** 	}
 444:ir_heat.c     **** 	else {
 445:ir_heat.c     **** 		if(on != last) printf(">>> Relais OFF\n");
 997               	"\nxXx"
 998               		.text
 1000 043a 8823      	.global	__vector_1
 1002 043e 80E0      	__vector_1:
 1004 0442 0E94 0000 	.LM96:
 1005               	.LFBB16:
 446:ir_heat.c     **** 		RELAIS_OFF;
 1006               	ero_reg__
 1007               		push r0
 1008 0446 E5E2      		in r0,__SREG__
 1009 0448 F0E0      		push r0
 1010 044a 8081      		clr __zero_reg__
 1011 044c 8F7B      		push r18
 1012 044e 8083      		push r19
 1013               		push r20
 447:ir_heat.c     **** 	}
 448:ir_heat.c     **** 	last = on;
 1014               	1
 1015               		push r22
 1016 0450 1093 0000 		push r23
 1017               		push r24
 449:ir_heat.c     **** }
 1018               	h r25
 1019               		push r26
 1020 0454 1F91      		push r27
 1021 0456 0895      		push r30
 1022               		push r31
 1023               	/* prologue: Signal */
 1024               	/* frame size = 0 */
 1026               	.LM97:
 1027               		lds r24,133
 1028               		lds r18,132
 1029 001d 5465 6D70 		lds r25,running.1751
 1029      6572 6174 
 1029      7572 6520 
 1029      5072 6F74 
 1029      6563 7469 
 1030               		or r24,r25
 1031 0039 0A78 5878 		or r24,r18
 1031      00
 1032               		breq .+2
 1033               		rjmp .L72
 1035               	.LM98:
 1036               		ldi r24,lo8(1)
 1037               		sts running.1751,r24
 1039               	.LM99:
 1040 0458 1F92      	/* #APP */
 1041 045a 0F92      	 ;  163 "ir_heat.c" 1
 1042 045c 0FB6      		wdr
 1043 045e 0F92      	 ;  0 "" 2
 1045 0462 2F93      	.LM100:
 1046 0464 3F93      	/* #NOAPP */
 1047 0466 4F93      		out 61-32,__zero_reg__
 1049 046a 6F93      	.LM101:
 1050 046c 7F93      	/* #APP */
 1051 046e 8F93      	 ;  168 "ir_heat.c" 1
 1052 0470 9F93      		sei
 1053 0472 AF93      	 ;  0 "" 2
 1054 0474 BF93      	/* #NOAPP */
 1055 0476 EF93      		ldi r18,lo8(0)
 1056 0478 FF93      		ldi r19,hi8(0)
 1057               		ldi r20,lo8(0)
 1058               		ldi r21,hi8(0)
 1060               	.LM102:
 1061 047a 8091 8500 		ldi r30,lo8(41)
 1062 047e 2091 8400 		ldi r31,hi8(41)
 1063 0482 9091 0000 	.L64:
 1064 0486 892B      		ld r24,Z
 1065 0488 822B      		sbrs r24,2
 1066 048a 01F0      		rjmp .L63
 1067 048c 00C0      		subi r20,lo8(-(1))
 1068               		sbci r21,hi8(-(1))
 1069               	.L63:
 1070 048e 81E0      		subi r18,lo8(-(1))
 1071 0490 8093 0000 		sbci r19,hi8(-(1))
 1072               		ldi r24,hi8(1000)
 1073               		cpi r18,lo8(1000)
 1074               		cpc r19,r24
 1075               		brne .L64
 1077               	.LM103:
 1078               		cpi r20,200
 1079               		cpc r21,__zero_reg__
 1080               		brlo .+2
 1081 0496 1DBA      		rjmp .L65
 1083               	.LM104:
 1084               		ldi r24,lo8(1)
 1085               		sts 132,r24
 1087               	.LM105:
 1088               		ldi r24,lo8(2)
 1089 049a 20E0      		sts 129,r24
 1091 049e 40E0      	.LM106:
 1092 04a0 50E0      		lds r24,mode
 1093               		tst r24
 1094               		breq .+2
 1095 04a2 E9E2      		rjmp .L75
 1097               	.LM107:
 1098 04a6 8081      		ldi r24,lo8(1)
 1099 04a8 82FF      		sts mode,r24
 1101 04ac 4F5F      	.LM108:
 1102 04ae 5F4F      		call set_relais
 1104 04b0 2F5F      	.LM109:
 1105 04b2 3F4F      		ldi r30,lo8(43)
 1106 04b4 83E0      		ldi r31,hi8(43)
 1107 04b6 283E      		ld r24,Z
 1108 04b8 3807      		ori r24,lo8(16)
 1109 04ba 01F4      		st Z,r24
 1111               	.LM110:
 1112 04bc 483C      		ld r24,Z
 1113 04be 5105      		ori r24,lo8(8)
 1114 04c0 00F0      		st Z,r24
 1116               	.LM111:
 1117               		sbic 41-32,2
 1118 04c4 81E0      		rjmp .L68
 1119 04c6 8093 8400 		ldi r18,lo8(0)
 1120               		ldi r19,hi8(0)
 1121               	.LBB48:
 1122 04ca 82E0      	.LBB49:
 1123 04cc 8093 8100 	.LBB50:
 1124               	.LBB51:
 1126 04d0 8091 0000 	.Ltext7:
 1128 04d6 01F0      	.LM112:
 1129 04d8 00C0      		ldi r20,lo8(2500)
 1130               		ldi r21,hi8(2500)
 1131               	.LBE51:
 1132 04da 81E0      	.LBE50:
 1133 04dc 8093 0000 	.LBE49:
 1134               	.LBE48:
 1136 04e0 0E94 0000 	.Ltext8:
 1138               	.LM113:
 1139 04e4 EBE2      		ldi r30,lo8(41)
 1140 04e6 F0E0      		ldi r31,hi8(41)
 1141 04e8 8081      	.L70:
 1143 04ec 8083      	.LM114:
 1144               		subi r18,lo8(-(1))
 1145               		sbci r19,hi8(-(1))
 1146 04ee 8081      	.LBB55:
 1147 04f0 8860      	.LBB54:
 1148 04f2 8083      	.LBB53:
 1149               	.LBB52:
 1151 04f4 4A99      	.Ltext9:
 1153 04f8 20E0      	.LM115:
 1154 04fa 30E0      		movw r24,r20
 1155               	/* #APP */
 1156               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1157               		1: sbiw r24,1
 1158               		brne 1b
 1159               	 ;  0 "" 2
 1160               	/* #NOAPP */
 1161               	.LBE52:
 1162               	.LBE53:
 1163 04fc 44EC      	.LBE54:
 1164 04fe 59E0      	.LBE55:
 1166               	.Ltext10:
 1168               	.LM116:
 1169               		ld r24,Z
 1170               		sbrc r24,2
 1171               		rjmp .L69
 1172               		ldi r24,hi8(300)
 1173 0500 E9E2      		cpi r18,lo8(300)
 1174 0502 F0E0      		cpc r19,r24
 1175               		brne .L70
 1176               		rjmp .L71
 1177               	.L69:
 1179 0506 3F4F      	.LM117:
 1180               		subi r18,lo8(300)
 1181               		sbci r19,hi8(300)
 1182               		brsh .L71
 1183               	.L68:
 1185               	.LM118:
 1186               		ldi r24,lo8(1)
 1187               		sts mode,r24
 1188 0508 CA01      		rjmp .L65
 1189               	.L71:
 1191 050a 0197      	.LM119:
 1192 050c 01F4      		ldi r24,lo8(2)
 1193               		sts mode,r24
 1195               	.LM120:
 1196               		ldi r24,lo8(.LC2)
 1197               		ldi r25,hi8(.LC2)
 1198               		call puts
 1200               	.LM121:
 1201               		ldi r30,lo8(43)
 1202               		ldi r31,hi8(43)
 1203 050e 8081      		ld r24,Z
 1204 0510 82FD      		andi r24,lo8(-17)
 1205 0512 00C0      		st Z,r24
 1207 0516 2C32      	.LM122:
 1208 0518 3807      		ld r24,Z
 1209 051a 01F4      		ori r24,lo8(8)
 1210 051c 00C0      		st Z,r24
 1212               	.LM123:
 1213               		ldi r24,lo8(6)
 1214 051e 2C52      		ldi r25,hi8(6)
 1215 0520 3140      		call beep
 1216 0522 00F4      		rjmp .L65
 1217               	.L75:
 1219               	.LM124:
 1220 0524 81E0      		ldi r24,lo8(.LC3)
 1221 0526 8093 0000 		ldi r25,hi8(.LC3)
 1222 052a 00C0      		call puts
 1224               	.LM125:
 1225               		sts mode,__zero_reg__
 1226 052c 82E0      	.L65:
 1228               	.LM126:
 1229               		ldi r24,lo8(1)
 1230 0532 80E0      		out 60-32,r24
 1232 0536 0E94 0000 	.LM127:
 1233               		out 61-32,r24
 1235 053a EBE2      	.LM128:
 1236 053c F0E0      		sts running.1751,__zero_reg__
 1237 053e 8081      	.L72:
 1238 0540 8F7E      	/* epilogue start */
 1240               	.LM129:
 1241               		pop r31
 1242 0544 8081      		pop r30
 1243 0546 8860      		pop r27
 1244 0548 8083      		pop r26
 1245               		pop r25
 1246               		pop r24
 1247 054a 86E0      		pop r23
 1248 054c 90E0      		pop r22
 1249 054e 0E94 0000 		pop r21
 1250 0552 00C0      		pop r20
 1251               		pop r19
 1252               		pop r18
 1253               		pop r0
 1254 0554 80E0      		out __SREG__,r0
 1255 0556 90E0      		pop r0
 1256 0558 0E94 0000 		pop __zero_reg__
 1257               		reti
 1264 0562 8CBB      	.Lscope16:
 1267 0564 8DBB      	.global	get_temperature
 1269               	get_temperature:
 1271               	.LM130:
 1272               	.LFBB17:
 1273               		push r17
 1274               		push r28
 1275 056a FF91      		push r29
 1276 056c EF91      	/* prologue: function */
 1277 056e BF91      	/* frame size = 0 */
 1278 0570 AF91      		mov r17,r24
 1280 0574 8F91      	.LM131:
 1281 0576 7F91      		ldi r24,lo8(-76)
 1282 0578 6F91      		call i2c_start
 1284 057c 4F91      	.LM132:
 1285 057e 3F91      		mov r24,r17
 1286 0580 2F91      		call i2c_write
 1288 0584 0FBE      	.LM133:
 1289 0586 0F90      		ldi r24,lo8(-75)
 1290 0588 1F90      		call i2c_rep_start
 1292               	.LM134:
 1293               		tst r24
 1294               		breq .L77
 1296               	.LM135:
 1297               		ldi r24,lo8(-75)
 1298               		call i2c_rep_start
 1299               	.L77:
 1301               	.LM136:
 1302               		call i2c_read_ack
 1303               		mov r17,r24
 1305               	.LM137:
 1306               		call i2c_read_ack
 1308 058e CF93      	.LM138:
 1309 0590 DF93      		mov r19,r24
 1310               		ldi r18,lo8(0)
 1311               		movw r28,r18
 1312 0592 182F      		add r28,r17
 1313               		adc r29,__zero_reg__
 1315 0594 84EB      	.LM139:
 1316 0596 0E94 0000 		call i2c_read_ack
 1318               	.LM140:
 1319 059a 812F      		call i2c_stop
 1321               	.LM141:
 1322               		tst r29
 1323 05a0 85EB      		brge .L78
 1324 05a2 0E94 0000 		ldi r22,lo8(0)
 1325               		ldi r23,hi8(0)
 1326               		rjmp .L79
 1327 05a6 8823      	.L78:
 1329               	.LM142:
 1330               		movw r24,r28
 1331 05aa 85EB      		ldi r22,lo8(5)
 1332 05ac 0E94 0000 		ldi r23,hi8(5)
 1333               		call __udivmodhi4
 1334               		subi r22,lo8(-(-2731))
 1335               		sbci r23,hi8(-(-2731))
 1336 05b0 0E94 0000 	.L79:
 1338               	.LM143:
 1339               		mov r24,r22
 1340 05b6 0E94 0000 		mov r25,r23
 1341               	/* epilogue start */
 1342               		pop r29
 1343 05ba 382F      		pop r28
 1344 05bc 20E0      		pop r17
 1345 05be E901      		ret
 1351               	.Lscope17:
 1352               		.data
 1353 05c8 0E94 0000 	.LC4:
 1354               		.string	"Array:"
 1355               	.LC5:
 1356 05cc DD23      		.string	" %i"
 1357 05ce 04F4      		.text
 1359 05d2 70E0      	.global	print_array
 1361               	print_array:
 1363               	.LM144:
 1364 05d6 CE01      	.LFBB18:
 1365 05d8 65E0      		push r12
 1366 05da 70E0      		push r13
 1367 05dc 0E94 0000 		push r14
 1368 05e0 6B5A      		push r15
 1369 05e2 7A40      		push r16
 1370               		push r17
 1371               	/* prologue: function */
 1372               	/* frame size = 0 */
 1374 05e6 972F      	.LM145:
 1375               		rcall .
 1376 05e8 DF91      		ldi r24,lo8(.LC4)
 1377 05ea CF91      		ldi r25,hi8(.LC4)
 1378 05ec 1F91      		in r26,__SP_L__
 1379 05ee 0895      		in r27,__SP_H__
 1380               		adiw r26,1+1
 1381               		st X,r25
 1382               		st -X,r24
 1383               		sbiw r26,1
 1384               		call printf
 1386               	.LM146:
 1387               		rcall .
 1388 003e 4172 7261 		in r30,__SP_L__
 1388      793A 00
 1389               		in r31,__SP_H__
 1390 0045 2025 6900 		adiw r30,1
 1391               		mov __tmp_reg__,r31
 1392               		ldi r31,lo8(.LC5)
 1393               		mov r14,r31
 1394               		ldi r31,hi8(.LC5)
 1395               		mov r15,r31
 1396               		mov r31,__tmp_reg__
 1397               		std Z+1,r15
 1398               		st Z,r14
 1399 05f0 CF92      		mov __tmp_reg__,r31
 1400 05f2 DF92      		ldi r31,lo8(t_array)
 1401 05f4 EF92      		mov r12,r31
 1402 05f6 FF92      		ldi r31,hi8(t_array)
 1403 05f8 0F93      		mov r13,r31
 1404 05fa 1F93      		mov r31,__tmp_reg__
 1405               		movw r26,r12
 1406               		ld r24,X+
 1407               		ld r25,X+
 1408               		movw r16,r26
 1409 05fc 00D0      		std Z+3,r25
 1410 05fe 80E0      		std Z+2,r24
 1411 0600 90E0      		call printf
 1412 0602 ADB7      		in r30,__SP_L__
 1413 0604 BEB7      		in r31,__SP_H__
 1414 0606 1296      		adiw r30,1
 1415 0608 9C93      		std Z+1,r15
 1416 060a 8E93      		st Z,r14
 1417 060c 1197      		movw r26,r16
 1418 060e 0E94 0000 		ld r24,X+
 1419               		ld r25,X
 1420               		std Z+3,r25
 1421 0612 00D0      		std Z+2,r24
 1422 0614 EDB7      		call printf
 1423 0616 FEB7      		in r30,__SP_L__
 1424 0618 3196      		in r31,__SP_H__
 1425 061a 0F2E      		adiw r30,1
 1426 061c F0E0      		std Z+1,r15
 1427 061e EF2E      		st Z,r14
 1428 0620 F0E0      		movw r26,r12
 1429 0622 FF2E      		adiw r26,4
 1430 0624 F02D      		ld r24,X+
 1431 0626 F182      		ld r25,X
 1432 0628 E082      		sbiw r26,4+1
 1433 062a 0F2E      		std Z+3,r25
 1434 062c F0E0      		std Z+2,r24
 1435 062e CF2E      		call printf
 1436 0630 F0E0      		in r30,__SP_L__
 1437 0632 DF2E      		in r31,__SP_H__
 1438 0634 F02D      		adiw r30,1
 1439 0636 D601      		std Z+1,r15
 1440 0638 8D91      		st Z,r14
 1441 063a 9D91      		movw r26,r12
 1442 063c 8D01      		adiw r26,6
 1443 063e 9383      		ld r24,X+
 1444 0640 8283      		ld r25,X
 1445 0642 0E94 0000 		sbiw r26,6+1
 1446 0646 EDB7      		std Z+3,r25
 1447 0648 FEB7      		std Z+2,r24
 1448 064a 3196      		call printf
 1449 064c F182      		in r30,__SP_L__
 1450 064e E082      		in r31,__SP_H__
 1451 0650 D801      		adiw r30,1
 1452 0652 8D91      		std Z+1,r15
 1453 0654 9C91      		st Z,r14
 1454 0656 9383      		movw r26,r12
 1455 0658 8283      		adiw r26,8
 1456 065a 0E94 0000 		ld r24,X+
 1457 065e EDB7      		ld r25,X
 1458 0660 FEB7      		sbiw r26,8+1
 1459 0662 3196      		std Z+3,r25
 1460 0664 F182      		std Z+2,r24
 1461 0666 E082      		call printf
 1462 0668 D601      		in r30,__SP_L__
 1463 066a 1496      		in r31,__SP_H__
 1464 066c 8D91      		adiw r30,1
 1465 066e 9C91      		std Z+1,r15
 1466 0670 1597      		st Z,r14
 1467 0672 9383      		movw r26,r12
 1468 0674 8283      		adiw r26,10
 1469 0676 0E94 0000 		ld r24,X+
 1470 067a EDB7      		ld r25,X
 1471 067c FEB7      		sbiw r26,10+1
 1472 067e 3196      		std Z+3,r25
 1473 0680 F182      		std Z+2,r24
 1474 0682 E082      		call printf
 1476 0686 1696      	.LM147:
 1477 0688 8D91      		pop __tmp_reg__
 1478 068a 9C91      		pop __tmp_reg__
 1479 068c 1797      		pop __tmp_reg__
 1480 068e 9383      		pop __tmp_reg__
 1481 0690 8283      		ldi r24,lo8(10)
 1482 0692 0E94 0000 		ldi r25,hi8(10)
 1483 0696 EDB7      		call putchar
 1484 0698 FEB7      	/* epilogue start */
 1486 069c F182      	.LM148:
 1487 069e E082      		pop r17
 1488 06a0 D601      		pop r16
 1489 06a2 1896      		pop r15
 1490 06a4 8D91      		pop r14
 1491 06a6 9C91      		pop r13
 1492 06a8 1997      		pop r12
 1493 06aa 9383      		ret
 1495 06ae 0E94 0000 	.Lscope18:
 1497 06b4 FEB7      	.global	UART_first_init
 1499 06b8 F182      	UART_first_init:
 1501 06bc D601      	.LM149:
 1502 06be 1A96      	.LFBB19:
 1503 06c0 8D91      	/* prologue: function */
 1504 06c2 9C91      	/* frame size = 0 */
 1506 06c6 9383      	.LM150:
 1507 06c8 8283      		ldi r24,lo8(12)
 1508 06ca 0E94 0000 		ldi r25,hi8(12)
 1509               		sts (196)+1,r25
 1510               		sts 196,r24
 1512 06d0 0F90      	.LM151:
 1513 06d2 0F90      		ldi r24,lo8(-104)
 1514 06d4 0F90      		sts 193,r24
 1516 06d8 90E0      	.LM152:
 1517 06da 0E94 0000 		ldi r24,lo8(6)
 1518               		sts 194,r24
 1520               	.LM153:
 1521 06de 1F91      		ldi r24,lo8(gs(UART_putchar))
 1522 06e0 0F91      		ldi r25,hi8(gs(UART_putchar))
 1523 06e2 FF90      		ldi r22,lo8(gs(UART_getchar))
 1524 06e4 EF90      		ldi r23,hi8(gs(UART_getchar))
 1525 06e6 DF90      		call fdevopen
 1527 06ea 0895      	.LM154:
 1528               	/* #APP */
 1529               	 ;  294 "ir_heat.c" 1
 1530               		sei
 1531               	 ;  0 "" 2
 1532               	/* epilogue start */
 1534               	.LM155:
 1535               	/* #NOAPP */
 1536               		ret
 1538               	.Lscope19:
 1539               		.data
 1540               	.LC6:
 1541 06ec 8CE0      		.string	"\n\nStart\n"
 1542 06ee 90E0      	.LC7:
 1543 06f0 9093 C500 		.string	"Error Temp=0"
 1544 06f4 8093 C400 	.LC8:
 1545               		.string	"Startup %i "
 1546               	.LC9:
 1547 06f8 88E9      		.string	"Temp: %i, "
 1548 06fa 8093 C100 	.LC10:
 1549               		.string	"sl_raw: %i, sl: %i, f: %i, int: %i\n"
 1550               	.LC11:
 1551 06fe 86E0      		.string	"On-Counter: %i; \n"
 1552 0700 8093 C200 	.LC12:
 1553               		.string	"Off-Counter: %i; \n"
 1554               		.text
 1556 0706 90E0      	.global	main
 1558 070a 70E0      	main:
 1560               	.LM156:
 1561               	.LFBB20:
 1562               		push r2
 1563               		push r3
 1564 0710 7894      		push r4
 1565               		push r5
 1566               		push r6
 1567               		push r7
 1568               		push r8
 1569               		push r9
 1570 0712 0895      		push r10
 1571               		push r11
 1572               		push r12
 1573               		push r13
 1574               		push r14
 1575 0049 0A0A 5374 		push r15
 1575      6172 740A 
 1575      00
 1576               		push r16
 1577 0052 4572 726F 		push r17
 1577      7220 5465 
 1577      6D70 3D30 
 1577      00
 1578               		push r28
 1579 005f 5374 6172 		push r29
 1579      7475 7020 
 1579      2569 2000 
 1580               	/* prologue: function */
 1581 006b 5465 6D70 	/* frame size = 0 */
 1581      3A20 2569 
 1581      2C20 00
 1583 0076 736C 5F72 	.LM157:
 1583      6177 3A20 
 1583      2569 2C20 
 1583      736C 3A20 
 1583      2569 2C20 
 1584               		ldi r24,lo8(-64)
 1585 009a 4F6E 2D43 		out 36-32,r24
 1585      6F75 6E74 
 1585      6572 3A20 
 1585      2569 3B20 
 1585      0A00 
 1587 00ac 4F66 662D 	.LM158:
 1587      436F 756E 
 1587      7465 723A 
 1587      2025 693B 
 1587      200A 00
 1588               		ldi r24,lo8(8)
 1589               		out 39-32,r24
 1591               	.LM159:
 1592               		ldi r24,lo8(24)
 450:ir_heat.c     **** 
 451:ir_heat.c     **** 
 452:ir_heat.c     **** 
 453:ir_heat.c     **** 
 454:ir_heat.c     **** // ***********************************************************
 455:ir_heat.c     **** // Main program
 456:ir_heat.c     **** //
 457:ir_heat.c     **** int main(void) {
 1593               	out 37-32,r24
 1595               	.LM161:
 1596 0714 2F92      		ldi r24,lo8(-9)
 1597 0716 3F92      		out 40-32,r24
 1599 071a 5F92      	.LM162:
 1600 071c 6F92      		ldi r16,lo8(43)
 1601 071e 7F92      		ldi r17,hi8(43)
 1602 0720 8F92      		ldi r24,lo8(-25)
 1603 0722 9F92      		movw r30,r16
 1604 0724 AF92      		st Z,r24
 1606 0728 CF92      	.LM163:
 1607 072a DF92      		lds r24,100
 1609 072e FF92      	.LM164:
 1610 0730 0F93      	/* #APP */
 1611 0732 1F93      	 ;  472 "ir_heat.c" 1
 1612 0734 CF93      		wdr
 1613 0736 DF93      	 ;  0 "" 2
 1615               	.LM165:
 458:ir_heat.c     ****    // Ausgänge definieren
 459:ir_heat.c     **** 	DDRB = 0x00 | (1<<RELAIS) | (1<<BUZZER);
 1616               	o8(41)
 1617               		ldi r24,lo8(24)
 1618 0738 80EC      		ldi r25,hi8(24)
 1619 073a 84B9      	/* #APP */
 460:ir_heat.c     **** 	DDRC = 0x00 | (1<<FLASH_LED);
 1620               	473 "ir_heat.c" 1
 1621               		in __tmp_reg__,__SREG__
 1622 073c 88E0      		cli
 1623 073e 87B9      		wdr
 461:ir_heat.c     **** 	DDRD = 0x00 | (1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED);
 1624               	 96,r24
 1625               		out __SREG__,__tmp_reg__
 1626 0740 88E1      		sts 96,r18
 1627 0742 8AB9      		
 462:ir_heat.c     **** 
 463:ir_heat.c     **** 	// Ausgänge ausschalten
 464:ir_heat.c     **** 	PORTB = ~((1<<RELAIS) | (1<<BUZZER));
 1628               	0 "" 2
 1630 0744 8FE3      	.LM166:
 1631 0746 85B9      	/* #NOAPP */
 465:ir_heat.c     **** 	PORTC = ~(1<<FLASH_LED);
 1632               	l UART_first_init
 1634 0748 87EF      	.LM167:
 1635 074a 88B9      		call i2c_init
 466:ir_heat.c     **** 	PORTD = ~((1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED));
 1636               	abn	68,0,479,.LM168-.LFBB20
 1637               	.LM168:
 1638 074c 0BE2      		sts interval,__zero_reg__
 1640 0750 87EE      	.LM169:
 1641 0752 F801      		ldi r24,lo8(7)
 1642 0754 8083      		sts 177,r24
 467:ir_heat.c     **** 
 468:ir_heat.c     **** 	// TWI aus Energiesparmode rausnehmen
 469:ir_heat.c     **** 	PRR != ~(1<<PRTWI);
 1643               		68,0,483,.LM170-.LFBB20
 1644               	.LM170:
 1645 0756 8091 6400 		ldi r25,lo8(1)
 470:ir_heat.c     **** 
 471:ir_heat.c     **** 	// Whatchdog initialisieren
 472:ir_heat.c     **** 	wdt_reset();
 1646               	s 112,r25
 1648               	.LM171:
 1649               		out 68-32,__zero_reg__
 1651               	.LM172:
 473:ir_heat.c     **** 	wdt_enable(WDTO_8S);
 1652               	24,lo8(3)
 1653               		out 69-32,r24
 1655 075c 29E2      	.LM173:
 1656 075e 88E1      		sts 110,r25
 1658               	.LM174:
 1659               		sts 128,__zero_reg__
 1661 0764 F894      	.LM175:
 1662 0766 A895      		sts 129,__zero_reg__
 1664 076c 0FBE      	.LM176:
 1665 076e 2093 6000 		sts 130,__zero_reg__
 1667               	.LM177:
 474:ir_heat.c     **** 	
 475:ir_heat.c     **** 	// UART initialisieren
 476:ir_heat.c     **** 	UART_first_init();
 1668               	tabn	68,0,497,.LM178-.LFBB20
 1669               	.LM178:
 1670               		ldi r24,lo8(2)
 1671 0772 0E94 0000 		sts 105,r24
 477:ir_heat.c     **** 	i2c_init();
 1672               	abn	68,0,498,.LM179-.LFBB20
 1673               	.LM179:
 1674 0776 0E94 0000 		out 61-32,r25
 478:ir_heat.c     **** 	
 479:ir_heat.c     **** 	interval=0;
 1675               	tabn	68,0,501,.LM180-.LFBB20
 1676               	.LM180:
 1677 077a 1092 0000 		ldi r24,lo8(.LC6)
 480:ir_heat.c     **** 	
 481:ir_heat.c     **** 	// Timer 2 initialisieren (RTC)
 482:ir_heat.c     ****    TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);	// clk/256
 1678               	i r25,hi8(.LC6)
 1679               		call puts
 1681 0780 8093 B100 	.LM181:
 483:ir_heat.c     ****    TIMSK2 = (1<<TOIE2);
 1682               	w r30,r16
 1683               		ld r24,Z
 1684 0784 91E0      		ori r24,lo8(16)
 1685 0786 9093 7000 		st Z,r24
 484:ir_heat.c     **** 
 485:ir_heat.c     ****  	// Timer 0 initialisieren (Blinken)
 486:ir_heat.c     **** 	TCCR0A = 0;
 1686               	abn	68,0,503,.LM182-.LFBB20
 1687               	.LM182:
 1688 078a 14BC      		ld r24,Z
 487:ir_heat.c     **** 	TCCR0B = (0<<CS02) | (1<<CS01) | (1<<CS00);
 1689               	di r24,lo8(-9)
 1690               		st Z,r24
 1692 078e 85BD      	.LM183:
 488:ir_heat.c     **** 	TIMSK0 = (1<<TOIE0);
 1693               	 r24,lo8(0)
 1694               		call set_relais
 489:ir_heat.c     **** 	
 490:ir_heat.c     **** 	// Timer 1 initialisieren (Entprellen?)
 491:ir_heat.c     **** 	TCCR1A = 0;
 1696               	184:
 1697               		sts mode,__zero_reg__
 492:ir_heat.c     **** 	TIMER1_STOP;
 1699               	185:
 1700               	/* #APP */
 1701 0798 1092 8100 	 ;  517 "ir_heat.c" 1
 493:ir_heat.c     **** 	TCCR1C = 0;
 1702               	i
 1703               	 ;  0 "" 2
 1704 079c 1092 8200 	/* #NOAPP */
 494:ir_heat.c     **** 	TIMSK1 = (1<<TOIE1);
 1705               	i r28,lo8(0)
 1706               		ldi r29,hi8(0)
 1707 07a0 9093 6F00 		clr r14
 495:ir_heat.c     **** 	
 496:ir_heat.c     **** 	// Interrupt für Taster initialisieren
 497:ir_heat.c     **** 	EICRA = (1<<ISC01);
 1708               	r r15
 1709               		ldi r17,lo8(0)
 1710 07a4 82E0      		clr r3
 1711 07a6 8093 6900 		dec r3
 498:ir_heat.c     **** 	EIMSK = (1<<INT0);
 1712               	 __tmp_reg__,r31
 1713               		ldi r31,lo8(3)
 1714 07aa 9DBB      		mov r8,r31
 499:ir_heat.c     **** 	
 500:ir_heat.c     **** 
 501:ir_heat.c     **** 	printf("\n\nStart\n\n");
 1715               	v r31,__tmp_reg__
 1716               		clr r9
 1717 07ac 80E0      		clr r12
 1718 07ae 90E0      		clr r13
 502:ir_heat.c     **** 	STATUS_LED1_ON;		// grüne LED ein
 1720               	6:
 1721               		mov __tmp_reg__,r31
 1722 07b4 F801      		ldi r31,lo8(43)
 1723 07b6 8081      		mov r10,r31
 1724 07b8 8061      		clr r11
 1725 07ba 8083      		mov r31,__tmp_reg__
 503:ir_heat.c     **** 	STATUS_LED2_OFF;		// rote LED aus
 1726               	n	68,0,694,.LM187-.LFBB20
 1727               	.LM187:
 1728 07bc 8081      		clr r6
 1729 07be 877F      		clr r7
 504:ir_heat.c     **** 	set_relais(0);			// Relais aus
 1731               	8:
 1732               		mov __tmp_reg__,r31
 1733 07c2 80E0      		ldi r31,lo8(3)
 1734 07c4 0E94 0000 		mov r2,r31
 505:ir_heat.c     **** 	mode = MODE_OFF;
 1735               	 r31,__tmp_reg__
 1736               	.LBB56:
 1737 07c8 1092 0000 	.LBB57:
 506:ir_heat.c     **** 	
 507:ir_heat.c     **** 	int16_t 	temp, temp_sum = 0;
 508:ir_heat.c     **** 	int16_t	slope_raw, slope = 0;
 509:ir_heat.c     **** 	uint8_t	count=0;
 510:ir_heat.c     **** 	uint8_t  last_interval = 0xff;
 511:ir_heat.c     **** 	uint8_t	startup = 3;
 512:ir_heat.c     **** 	uint8_t	on_counter = 0;
 513:ir_heat.c     **** 	int16_t	factor;
 514:ir_heat.c     **** 	int16_t	integral = 0;
 515:ir_heat.c     **** 		
 516:ir_heat.c     **** 	// Interrupts aktivieren
 517:ir_heat.c     **** 	sei();
 1738               	B58:
 1739               	.LBB59:
 1741               	.Ltext11:
 1743               	.LM189:
 1744               		mov __tmp_reg__,r31
 1745 07ce C0E0      		ldi r31,lo8(25000)
 1746 07d0 D0E0      		mov r4,r31
 1747 07d2 EE24      		ldi r31,hi8(25000)
 1748 07d4 FF24      		mov r5,r31
 1749 07d6 10E0      		mov r31,__tmp_reg__
 1750 07d8 3324      	.L113:
 1751 07da 3A94      	.LBE59:
 1752 07dc 0F2E      	.LBE58:
 1753 07de F3E0      	.LBE57:
 1754 07e0 8F2E      	.LBE56:
 1756 07e4 9924      	.Ltext12:
 1758 07e8 DD24      	.LM190:
 518:ir_heat.c     **** 
 519:ir_heat.c     ****    while(1) {
 520:ir_heat.c     ****    	if(!(interval < 16)) { 					// Alle 16x (alle 4 Sekunden) Temperatur checken
 521:ir_heat.c     ****    		wdt_reset();                  	// Whatchdog zurücksetzen
 522:ir_heat.c     **** 
 523:ir_heat.c     **** 			temp = temp_sum / count;				// Mittelwert der 16 Messungen ermitteln
 524:ir_heat.c     **** 
 525:ir_heat.c     ****    		interval=0;
 526:ir_heat.c     ****    		count=0;
 527:ir_heat.c     **** 			temp_sum = 0;
 528:ir_heat.c     **** 	      //printf("Temp: %i\n", temp);
 529:ir_heat.c     **** 	      if(temp==0) {
 530:ir_heat.c     **** 	      	// error!
 531:ir_heat.c     **** 	      	printf("Error Temp=0");
 532:ir_heat.c     **** 	      }
 533:ir_heat.c     **** 	      else {
 534:ir_heat.c     **** 				if (startup>0) {
 535:ir_heat.c     **** 					// wird nur beim ersten Durchlauf, direkt nach Startup ausgeführt
 536:ir_heat.c     **** 					printf("Startup %i ", startup);
 537:ir_heat.c     **** 					startup--;
 538:ir_heat.c     **** 					temp = get_temperature(ADR_T_OBJ1);
 539:ir_heat.c     **** 					slope = 0;
 540:ir_heat.c     **** 				}
 541:ir_heat.c     ****    	   	printf("Temp: %i, ", temp);
 542:ir_heat.c     ****    	   	add_value(temp);									// Neue Temperatur zu Array hinzufügen
 543:ir_heat.c     ****    	   	slope_raw = get_slope();						// Aktuelle Steigung ermitteln
 544:ir_heat.c     ****    	   	
 545:ir_heat.c     ****    	   	factor = (temp - 620) / -25;					// Fakort ermitteln
 546:ir_heat.c     ****    	   	if(factor < 0) factor = 0;
 547:ir_heat.c     ****    	   	   	   	
 548:ir_heat.c     **** 				if(slope_raw > factor) { 						// "Steigungsintegral"
 549:ir_heat.c     **** 					integral = 8*(integral + slope_raw) / factor;
 550:ir_heat.c     **** 				}
 551:ir_heat.c     **** 				else {
 552:ir_heat.c     **** 					integral = integral / 4;
 553:ir_heat.c     **** 				}
 554:ir_heat.c     **** 				
 555:ir_heat.c     **** //				slope = (31*slope + 10*slope_raw)/32; 		// Steigung dämpfen
 556:ir_heat.c     **** 
 557:ir_heat.c     **** 				
 558:ir_heat.c     **** 				if(slope_raw < -10) slope_raw = -10;
 559:ir_heat.c     **** 				if(slope_raw<0) {									// Fallende Temperaturen werden stärker gewichtet
 560:ir_heat.c     **** 	   	   	slope = (7*slope + 10*slope_raw)/8;		// Negative Steigung wird mit einer Dämpfung von 8 ge
 561:ir_heat.c     **** 				}
 562:ir_heat.c     **** 				else {
 563:ir_heat.c     **** 	   	   	slope = (31*slope + 10*slope_raw)/32;	// Positive Steigung wird mit einer Dämpfung von 16 
 564:ir_heat.c     **** 	   	   }
 565:ir_heat.c     **** /*
 566:ir_heat.c     ****    	   	printf("slope_raw: %i, slope: %i ", slope_raw, slope);
 567:ir_heat.c     ****      	   	printf("Ambient: %i\n", get_temperature(ADR_T_A));
 568:ir_heat.c     **** */				
 569:ir_heat.c     **** 
 570:ir_heat.c     ****    	   	printf("sl_raw: %i, sl: %i, f: %i, int: %i\n", slope_raw, slope, factor, integral);
 571:ir_heat.c     **** 
 572:ir_heat.c     **** 				if((slope > 55) || (integral > 500)) {
 573:ir_heat.c     **** 		   		printf("On-Counter: %i; \n", on_counter);
 574:ir_heat.c     **** 	   			if(mode == MODE_ON_NO_PROT){
 575:ir_heat.c     **** 						on_counter++;
 576:ir_heat.c     **** 	   				if(on_counter==3){
 577:ir_heat.c     **** 	   					beep(BEEP_SHORT);
 578:ir_heat.c     **** 	   					on_counter = 0;
 579:ir_heat.c     **** 	   				}
 580:ir_heat.c     ****   					}
 581:ir_heat.c     ****    				else {
 582:ir_heat.c     ****    					if(get_last_slope() >= 0) {
 583:ir_heat.c     **** 							on_counter++;
 584:ir_heat.c     **** 			   			if(on_counter > 2) {
 585:ir_heat.c     ****    							off_counter = OFF_COUNTER+1;
 586:ir_heat.c     ****    							on_counter = 2;
 587:ir_heat.c     ****    							beep(BEEP_XLONG);
 588:ir_heat.c     **** 		   				}
 589:ir_heat.c     **** 		   				else {
 590:ir_heat.c     **** 	   						beep(BEEP_LONG);
 591:ir_heat.c     ****    						}
 592:ir_heat.c     ****    					}
 593:ir_heat.c     ****    				}
 594:ir_heat.c     **** 				}			
 595:ir_heat.c     **** 				else {
 596:ir_heat.c     **** 					on_counter = 0;
 597:ir_heat.c     **** 				}		
 598:ir_heat.c     **** 
 599:ir_heat.c     **** 			
 600:ir_heat.c     **** /*				// Je nach aktueller Temperatur und Steigung in Temperaturschutz gehen
 601:ir_heat.c     **** 				if(slope_raw > 1){	   						// nur aktiv werden, wenn die Temperatur aktuell steigt	
 602:ir_heat.c     **** 		   		if(temp > 480) {
 603:ir_heat.c     **** 		   			// Temperatur > 48°C
 604:ir_heat.c     **** 		   			if(slope > 30) {
 605:ir_heat.c     **** 		   				on_counter++;		   				
 606:ir_heat.c     **** 			   			printf("Temperature Protect Rule 48, ");
 607:ir_heat.c     **** 		   			}
 608:ir_heat.c     **** 		   		}
 609:ir_heat.c     **** 		   		else if(temp > 450) {
 610:ir_heat.c     **** 		   			// Temperatur > 45°C
 611:ir_heat.c     **** 		   			if(slope > 50) {
 612:ir_heat.c     **** 		   				on_counter++;
 613:ir_heat.c     **** 		   				printf("Temperature Protect Rule 45, ");
 614:ir_heat.c     **** 		   			}
 615:ir_heat.c     **** 		   		}
 616:ir_heat.c     **** 		   		else if(temp > 400) {
 617:ir_heat.c     **** 		   			// Temperatur > 40°C
 618:ir_heat.c     **** 		   			if(slope > 60) {
 619:ir_heat.c     **** 		   				on_counter++;
 620:ir_heat.c     **** 		   				printf("Temperature Protect Rule 40, ");
 621:ir_heat.c     **** 		   			}
 622:ir_heat.c     **** 		   		}
 623:ir_heat.c     **** 		   		else if(temp > 350) {
 624:ir_heat.c     **** 		   			// Temperatur > 35°C
 625:ir_heat.c     **** 		   			if(slope > 80) {
 626:ir_heat.c     **** 		   				on_counter++;
 627:ir_heat.c     **** 		   				printf("Temperature Protect Rule 35, ");
 628:ir_heat.c     ****   	             }
 629:ir_heat.c     **** 		   		}
 630:ir_heat.c     **** 		   		else if(temp > 300) {
 631:ir_heat.c     **** 		   			// Temperatur > 30°C
 632:ir_heat.c     **** 		   			if(slope > 120) {
 633:ir_heat.c     **** 		   				on_counter++;
 634:ir_heat.c     **** 			   			printf("Temperature Protect Rule 30, ");
 635:ir_heat.c     **** 			   		}
 636:ir_heat.c     **** 		   		}
 637:ir_heat.c     **** 		   		else if(slope > 160) {
 638:ir_heat.c     **** 	   				on_counter++;
 639:ir_heat.c     **** 		   			printf("Temperature Protect General Rule, ");
 640:ir_heat.c     **** 		   		}
 641:ir_heat.c     **** 		   		else {
 642:ir_heat.c     **** 		   			on_counter = 0;
 643:ir_heat.c     **** 		   		}
 644:ir_heat.c     **** 		   		
 645:ir_heat.c     **** 		   		if(on_counter) printf("On-Counter: %i; \n", on_counter);
 646:ir_heat.c     **** 		   		if(on_counter > 3) off_counter = OFF_COUNTER+1;
 647:ir_heat.c     ****    			}
 648:ir_heat.c     **** */
 649:ir_heat.c     ****    	   }
 650:ir_heat.c     **** 
 651:ir_heat.c     ****    		if(off_counter) {
 652:ir_heat.c     ****    			// Protection Counter läuft
 653:ir_heat.c     ****   				off_counter--;
 654:ir_heat.c     ****   				if(mode == MODE_ON) mode = MODE_TEMP_PROT;
 655:ir_heat.c     **** 				printf("Off-Counter: %i; \n", off_counter);
 656:ir_heat.c     ****    		}
 657:ir_heat.c     ****    		else {
 658:ir_heat.c     ****    			if(mode == MODE_TEMP_PROT) {
 659:ir_heat.c     ****    				slope = 0;
 660:ir_heat.c     ****    				integral = 0;
 661:ir_heat.c     ****    				mode = MODE_OFF;
 662:ir_heat.c     ****    			}
 663:ir_heat.c     ****    		}
 664:ir_heat.c     **** 		}
 665:ir_heat.c     **** 		else if(interval != last_interval) {
 666:ir_heat.c     **** 			// In jedem Interval 1x die Temperatur abrufen
 667:ir_heat.c     **** 			// und für den Mittelwert aufsummieren
 668:ir_heat.c     ****    		last_interval = interval;
 669:ir_heat.c     ****     		if(count<16) {
 670:ir_heat.c     **** 	   		count++;
 671:ir_heat.c     ****    			// Messwerte für den Mittelwert aufsummieren
 672:ir_heat.c     ****    			temp_sum += get_temperature(ADR_T_OBJ1);
 673:ir_heat.c     ****    		}
 674:ir_heat.c     ****    	}
 675:ir_heat.c     **** 
 676:ir_heat.c     **** 		// Je nach Mode Relais und LEDs setzen
 677:ir_heat.c     **** 		switch(mode) {
 678:ir_heat.c     **** 		case MODE_OFF:
 679:ir_heat.c     **** 			set_relais(0);
 680:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 1759               	i r20,lo8(16)
 1760               		brge .+2
 1761 07ea 0F2E      		rjmp .L86
 1763 07ee AF2E      	.LM191:
 1764 07f0 BB24      	/* #APP */
 1765 07f2 F02D      	 ;  521 "ir_heat.c" 1
 681:ir_heat.c     **** 			STATUS_LED2_OFF;
 682:ir_heat.c     **** 			off_counter = 0;
 683:ir_heat.c     **** 			on_counter = 0;
 684:ir_heat.c     **** 			break;
 685:ir_heat.c     **** 		case MODE_ON:
 686:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 687:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 688:ir_heat.c     **** 			set_relais(1);
 689:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 690:ir_heat.c     **** 			break;
 691:ir_heat.c     **** 		case MODE_TEMP_PROT:
 692:ir_heat.c     **** 			set_relais(0);
 693:ir_heat.c     **** 			STATUS_LED1_OFF;
 694:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 1766               	  0 "" 2
 1768 07f4 6624      	.LM192:
 1769 07f6 7724      	/* #NOAPP */
 1770               		movw r24,r28
 1771               		mov r22,r17
 1772 07f8 0F2E      		ldi r23,lo8(0)
 1773 07fa F3E0      		call __divmodhi4
 1774 07fc 2F2E      		mov r24,r22
 1775 07fe F02D      		mov r25,r23
 1776               		movw r28,r24
 1778               	.LM193:
 1779               		sts interval,__zero_reg__
 1781               	.LM194:
 1782               		sbiw r28,0
 1783               		brne .L87
 1785 0802 F8EA      	.LM195:
 1786 0804 4F2E      		rcall .
 1787 0806 F1E6      		ldi r18,lo8(.LC7)
 1788 0808 5F2E      		ldi r19,hi8(.LC7)
 1789 080a F02D      		in r30,__SP_L__
 1790               		in r31,__SP_H__
 1791               		std Z+2,r19
 1792               		std Z+1,r18
 1793               		call printf
 1794               		pop __tmp_reg__
 1795               		pop __tmp_reg__
 1796               		rjmp .L88
 1797               	.L87:
 1799 080c 4091 0000 	.LM196:
 1800 0810 4031      		tst r8
 1801 0812 04F4      		breq .L89
 1803               	.LM197:
 1804               		rcall .
 1805               		rcall .
 1806               		in r30,__SP_L__
 1807 0816 A895      		in r31,__SP_H__
 1808               		adiw r30,1
 1809               		ldi r24,lo8(.LC8)
 1810               		ldi r25,hi8(.LC8)
 1811               		std Z+1,r25
 1812 0818 CE01      		st Z,r24
 1813 081a 612F      		std Z+2,r8
 1814 081c 70E0      		std Z+3,__zero_reg__
 1815 081e 0E94 0000 		call printf
 1817 0824 972F      	.LM198:
 1818 0826 EC01      		dec r8
 1820               	.LM199:
 1821 0828 1092 0000 		pop __tmp_reg__
 1822               		pop __tmp_reg__
 1823               		pop __tmp_reg__
 1824 082c 2097      		pop __tmp_reg__
 1825 082e 01F4      		ldi r24,lo8(7)
 1826               		call get_temperature
 1827               		movw r28,r24
 1828 0830 00D0      		movw r14,r6
 1829 0832 20E0      	.L89:
 1831 0836 EDB7      	.LM200:
 1832 0838 FEB7      		rcall .
 1833 083a 3283      		rcall .
 1834 083c 2183      		in r30,__SP_L__
 1835 083e 0E94 0000 		in r31,__SP_H__
 1836 0842 0F90      		adiw r30,1
 1837 0844 0F90      		ldi r18,lo8(.LC9)
 1838 0846 00C0      		ldi r19,hi8(.LC9)
 1839               		std Z+1,r19
 1840               		st Z,r18
 1841               		std Z+3,r29
 1842 0848 8820      		std Z+2,r28
 1843 084a 01F0      		call printf
 1845               	.LM201:
 1846 084c 00D0      		pop __tmp_reg__
 1847 084e 00D0      		pop __tmp_reg__
 1848 0850 EDB7      		pop __tmp_reg__
 1849 0852 FEB7      		pop __tmp_reg__
 1850 0854 3196      		movw r24,r28
 1851 0856 80E0      		call add_value
 1853 085a 9183      	.LM202:
 1854 085c 8083      		call get_slope
 1855 085e 8282      		movw r16,r24
 1857 0862 0E94 0000 	.LM203:
 1858               		movw r24,r28
 1859               		subi r24,lo8(-(-620))
 1860 0866 8A94      		sbci r25,hi8(-(-620))
 1861               		ldi r22,lo8(-25)
 1862               		ldi r23,hi8(-25)
 1863 0868 0F90      		call __divmodhi4
 1864 086a 0F90      		mov r24,r22
 1865 086c 0F90      		mov r25,r23
 1866 086e 0F90      		movw r28,r24
 1867 0870 87E0      		tst r29
 1868 0872 0E94 0000 		brge .L90
 1869 0876 EC01      		movw r28,r6
 1870 0878 7301      	.L90:
 1872               	.LM204:
 1873               		cp r28,r16
 1874 087a 00D0      		cpc r29,r17
 1875 087c 00D0      		brge .L91
 1877 0880 FEB7      	.LM205:
 1878 0882 3196      		movw r24,r12
 1879 0884 20E0      		add r24,r16
 1880 0886 30E0      		adc r25,r17
 1881 0888 3183      		lsl r24
 1882 088a 2083      		rol r25
 1883 088c D383      		lsl r24
 1884 088e C283      		rol r25
 1885 0890 0E94 0000 		lsl r24
 1886               		rol r25
 1887               		movw r22,r28
 1888 0894 0F90      		call __divmodhi4
 1889 0896 0F90      		mov r24,r22
 1890 0898 0F90      		mov r25,r23
 1891 089a 0F90      		movw r12,r24
 1892 089c CE01      		rjmp .L92
 1893 089e 0E94 0000 	.L91:
 1895               	.LM206:
 1896 08a2 0E94 0000 		movw r24,r12
 1897 08a6 8C01      		tst r13
 1898               		brge .L93
 1899               		adiw r24,3
 1900 08a8 CE01      	.L93:
 1901 08aa 8C56      		movw r12,r24
 1902 08ac 9240      		asr r13
 1903 08ae 67EE      		ror r12
 1904 08b0 7FEF      		asr r13
 1905 08b2 0E94 0000 		ror r12
 1906 08b6 862F      	.L92:
 1908 08ba EC01      	.LM207:
 1909 08bc DD23      		ldi r19,hi8(-10)
 1910 08be 04F4      		cpi r16,lo8(-10)
 1911 08c0 E301      		cpc r17,r19
 1912               		brge .L94
 1913               		ldi r16,lo8(-10)
 1914               		ldi r17,hi8(-10)
 1915 08c2 C017      		rjmp .L95
 1916 08c4 D107      	.L94:
 1918               	.LM208:
 1919               		tst r17
 1920 08c8 C601      		brge .L96
 1921 08ca 800F      	.L95:
 1923 08ce 880F      	.LM209:
 1924 08d0 991F      		movw r18,r16
 1925 08d2 880F      		lsl r18
 1926 08d4 991F      		rol r19
 1927 08d6 880F      		movw r24,r16
 1928 08d8 991F      		lsl r24
 1929 08da BE01      		rol r25
 1930 08dc 0E94 0000 		lsl r24
 1931 08e0 862F      		rol r25
 1932 08e2 972F      		lsl r24
 1933 08e4 6C01      		rol r25
 1934 08e6 00C0      		add r18,r24
 1935               		adc r19,r25
 1936               		movw r24,r14
 1937               		lsl r24
 1938 08e8 C601      		rol r25
 1939 08ea DD20      		lsl r24
 1940 08ec 04F4      		rol r25
 1941 08ee 0396      		lsl r24
 1942               		rol r25
 1943 08f0 6C01      		sub r24,r14
 1944 08f2 D594      		sbc r25,r15
 1945 08f4 C794      		add r18,r24
 1946 08f6 D594      		adc r19,r25
 1947 08f8 C794      		tst r19
 1948               		brge .L97
 1949               		subi r18,lo8(-(7))
 1950               		sbci r19,hi8(-(7))
 1951 08fa 3FEF      	.L97:
 1952 08fc 063F      		movw r14,r18
 1953 08fe 1307      		asr r15
 1954 0900 04F4      		ror r14
 1955 0902 06EF      		asr r15
 1956 0904 1FEF      		ror r14
 1957 0906 00C0      		asr r15
 1958               		ror r14
 1959               		rjmp .L98
 1960               	.L96:
 1962 090a 04F4      	.LM210:
 1963               		ldi r30,lo8(31)
 1964               		ldi r31,hi8(31)
 1965               		mul r14,r30
 1966 090c 9801      		movw r24,r0
 1967 090e 220F      		mul r14,r31
 1968 0910 331F      		add r25,r0
 1969 0912 C801      		mul r15,r30
 1970 0914 880F      		add r25,r0
 1971 0916 991F      		clr r1
 1972 0918 880F      		movw r18,r16
 1973 091a 991F      		lsl r18
 1974 091c 880F      		rol r19
 1975 091e 991F      		movw r20,r16
 1976 0920 280F      		lsl r20
 1977 0922 391F      		rol r21
 1978 0924 C701      		lsl r20
 1979 0926 880F      		rol r21
 1980 0928 991F      		lsl r20
 1981 092a 880F      		rol r21
 1982 092c 991F      		add r18,r20
 1983 092e 880F      		adc r19,r21
 1984 0930 991F      		add r18,r24
 1985 0932 8E19      		adc r19,r25
 1986 0934 9F09      		tst r19
 1987 0936 280F      		brge .L99
 1988 0938 391F      		subi r18,lo8(-(31))
 1989 093a 3323      		sbci r19,hi8(-(31))
 1990 093c 04F4      	.L99:
 1991 093e 295F      		movw r14,r18
 1992 0940 3F4F      		asr r15
 1993               		ror r14
 1994 0942 7901      		asr r15
 1995 0944 F594      		ror r14
 1996 0946 E794      		asr r15
 1997 0948 F594      		ror r14
 1998 094a E794      		asr r15
 1999 094c F594      		ror r14
 2000 094e E794      		asr r15
 2001 0950 00C0      		ror r14
 2002               	.L98:
 2004               	.LM211:
 2005 0952 EFE1      		in r18,__SP_L__
 2006 0954 F0E0      		in r19,__SP_H__
 2007 0956 EE9E      		subi r18,lo8(-(-10))
 2008 0958 C001      		sbci r19,hi8(-(-10))
 2009 095a EF9E      		in __tmp_reg__,__SREG__
 2010 095c 900D      		cli
 2011 095e FE9E      		out __SP_H__,r19
 2012 0960 900D      		out __SREG__,__tmp_reg__
 2013 0962 1124      		out __SP_L__,r18
 2014 0964 9801      		in r30,__SP_L__
 2015 0966 220F      		in r31,__SP_H__
 2016 0968 331F      		adiw r30,1
 2017 096a A801      		ldi r24,lo8(.LC10)
 2018 096c 440F      		ldi r25,hi8(.LC10)
 2019 096e 551F      		std Z+1,r25
 2020 0970 440F      		st Z,r24
 2021 0972 551F      		std Z+3,r17
 2022 0974 440F      		std Z+2,r16
 2023 0976 551F      		std Z+5,r15
 2024 0978 240F      		std Z+4,r14
 2025 097a 351F      		std Z+7,r29
 2026 097c 280F      		std Z+6,r28
 2027 097e 391F      		std Z+9,r13
 2028 0980 3323      		std Z+8,r12
 2029 0982 04F4      		call printf
 2031 0986 3F4F      	.LM212:
 2032               		in r30,__SP_L__
 2033 0988 7901      		in r31,__SP_H__
 2034 098a F594      		adiw r30,10
 2035 098c E794      		in __tmp_reg__,__SREG__
 2036 098e F594      		cli
 2037 0990 E794      		out __SP_H__,r31
 2038 0992 F594      		out __SREG__,__tmp_reg__
 2039 0994 E794      		out __SP_L__,r30
 2040 0996 F594      		ldi r31,lo8(56)
 2041 0998 E794      		cp r14,r31
 2042 099a F594      		cpc r15,__zero_reg__
 2043 099c E794      		brge .L100
 2044               		ldi r18,lo8(501)
 2045               		cp r12,r18
 2046               		ldi r18,hi8(501)
 2047 099e 2DB7      		cpc r13,r18
 2048 09a0 3EB7      		brge .L100
 2049 09a2 2A50      		clr r9
 2050 09a4 3040      		rjmp .L88
 2051 09a6 0FB6      	.L100:
 2053 09aa 3EBF      	.LM213:
 2054 09ac 0FBE      		rcall .
 2055 09ae 2DBF      		rcall .
 2056 09b0 EDB7      		in r30,__SP_L__
 2057 09b2 FEB7      		in r31,__SP_H__
 2058 09b4 3196      		adiw r30,1
 2059 09b6 80E0      		ldi r24,lo8(.LC11)
 2060 09b8 90E0      		ldi r25,hi8(.LC11)
 2061 09ba 9183      		std Z+1,r25
 2062 09bc 8083      		st Z,r24
 2063 09be 1383      		std Z+2,r9
 2064 09c0 0283      		std Z+3,__zero_reg__
 2065 09c2 F582      		call printf
 2067 09c6 D783      	.LM214:
 2068 09c8 C683      		pop __tmp_reg__
 2069 09ca D186      		pop __tmp_reg__
 2070 09cc C086      		pop __tmp_reg__
 2071 09ce 0E94 0000 		pop __tmp_reg__
 2072               		lds r24,mode
 2073               		cpi r24,lo8(2)
 2074 09d2 EDB7      		brne .L101
 2076 09d6 3A96      	.LM215:
 2077 09d8 0FB6      		inc r9
 2079 09dc FEBF      	.LM216:
 2080 09de 0FBE      		ldi r25,lo8(3)
 2081 09e0 EDBF      		cp r9,r25
 2082 09e2 F8E3      		brne .L88
 2084 09e6 F104      	.LM217:
 2085 09e8 04F4      		ldi r24,lo8(1)
 2086 09ea 25EF      		call beep
 2087 09ec C216      		clr r9
 2088 09ee 21E0      		rjmp .L88
 2089 09f0 D206      	.L101:
 2091 09f4 9924      	.LM218:
 2092 09f6 00C0      		call get_last_slope
 2093               		tst r25
 2094               		brlt .L88
 2096 09f8 00D0      	.LM219:
 2097 09fa 00D0      		inc r9
 2099 09fe FEB7      	.LM220:
 2100 0a00 3196      		ldi r30,lo8(2)
 2101 0a02 80E0      		cp r30,r9
 2102 0a04 90E0      		brsh .L102
 2104 0a08 8083      	.LM221:
 2105 0a0a 9282      		sts off_counter,r2
 2107 0a0e 0E94 0000 	.LM222:
 2108               		ldi r24,lo8(4)
 2109               		call beep
 2110 0a12 0F90      		clr r9
 2111 0a14 0F90      		set
 2112 0a16 0F90      		bld r9,1
 2113 0a18 0F90      		rjmp .L88
 2114 0a1a 8091 0000 	.L102:
 2116 0a20 01F4      	.LM223:
 2117               		mov r24,r2
 2118               		call beep
 2119 0a22 9394      	.L88:
 2121               	.LM224:
 2122 0a24 93E0      		lds r24,off_counter
 2123 0a26 9916      		tst r24
 2124 0a28 01F4      		breq .L103
 2126               	.LM225:
 2127 0a2a 81E0      		mov r25,r24
 2128 0a2c 0E94 0000 		subi r25,lo8(-(-1))
 2129 0a30 9924      		sts off_counter,r25
 2131               	.LM226:
 2132               		lds r24,mode
 2133               		cpi r24,lo8(1)
 2134 0a34 0E94 0000 		brne .L104
 2135 0a38 9923      		sts mode,r2
 2136 0a3a 04F0      	.L104:
 2138               	.LM227:
 2139 0a3c 9394      		rcall .
 2140               		rcall .
 2141               		in r30,__SP_L__
 2142 0a3e E2E0      		in r31,__SP_H__
 2143 0a40 E915      		adiw r30,1
 2144 0a42 00F4      		ldi r18,lo8(.LC12)
 2145               		ldi r19,hi8(.LC12)
 2146               		std Z+1,r19
 2147 0a44 2092 0000 		st Z,r18
 2148               		std Z+2,r25
 2149               		std Z+3,__zero_reg__
 2150 0a48 84E0      		call printf
 2151 0a4a 0E94 0000 		movw r28,r6
 2152 0a4e 9924      		ldi r17,lo8(0)
 2153 0a50 6894      		pop __tmp_reg__
 2154 0a52 91F8      		pop __tmp_reg__
 2155 0a54 00C0      		pop __tmp_reg__
 2156               		pop __tmp_reg__
 2157               		rjmp .L105
 2158               	.L103:
 2160 0a58 0E94 0000 	.LM228:
 2161               		lds r24,mode
 2162               		cpi r24,lo8(3)
 2163               		breq .L106
 2164 0a5c 8091 0000 		movw r28,r6
 2165 0a60 8823      		ldi r17,lo8(0)
 2166 0a62 01F0      		rjmp .L105
 2167               	.L106:
 2169 0a64 982F      	.LM229:
 2170 0a66 9150      		sts mode,__zero_reg__
 2171 0a68 9093 0000 		movw r28,r6
 2172               		movw r14,r6
 2173               		ldi r17,lo8(0)
 2174 0a6c 8091 0000 		movw r12,r6
 2175 0a70 8130      		rjmp .L107
 2176 0a72 01F4      	.L86:
 2178               	.LM230:
 2179               		mov r18,r20
 2180               		clr r19
 2181 0a78 00D0      		sbrc r18,7
 2182 0a7a 00D0      		com r19
 2183 0a7c EDB7      		mov r24,r3
 2184 0a7e FEB7      		ldi r25,lo8(0)
 2185 0a80 3196      		cp r18,r24
 2186 0a82 20E0      		cpc r19,r25
 2187 0a84 30E0      		breq .L105
 2189 0a88 2083      	.LM231:
 2190 0a8a 9283      		mov r3,r20
 2192 0a8e 0E94 0000 	.LM232:
 2193 0a92 E301      		cpi r17,lo8(16)
 2194 0a94 10E0      		brsh .L105
 2196 0a98 0F90      	.LM233:
 2197 0a9a 0F90      		subi r17,lo8(-(1))
 2199 0a9e 00C0      	.LM234:
 2200               		ldi r24,lo8(7)
 2201               		call get_temperature
 2202               		add r28,r24
 2203 0aa0 8091 0000 		adc r29,r25
 2204 0aa4 8330      	.L105:
 2206 0aa8 E301      	.LM235:
 2207 0aaa 10E0      		lds r24,mode
 2208 0aac 00C0      		cpi r24,lo8(1)
 2209               		breq .L109
 2210               		cpi r24,lo8(1)
 2211               		brlo .L107
 2212 0aae 1092 0000 		cpi r24,lo8(2)
 2213 0ab2 E301      		breq .L110
 2214 0ab4 7301      		cpi r24,lo8(3)
 2215 0ab6 10E0      		brne .L115
 2216 0ab8 6301      		rjmp .L116
 2217 0aba 00C0      	.L107:
 2219               	.LM236:
 2220               		ldi r24,lo8(0)
 2221 0abc 242F      		call set_relais
 2223 0ac0 27FD      	.LM237:
 2224 0ac2 3095      		movw r30,r10
 2225 0ac4 832D      		ld r24,Z
 2226 0ac6 90E0      		ori r24,lo8(16)
 2227 0ac8 2817      		st Z,r24
 2229 0acc 01F0      	.LM238:
 2230               		ld r24,Z
 2231               		andi r24,lo8(-9)
 2232 0ace 342E      		st Z,r24
 2234               	.LM239:
 2235 0ad0 1031      		sts off_counter,__zero_reg__
 2236 0ad2 00F4      		clr r9
 2237               		rjmp .L112
 2238               	.L109:
 2240               	.LM240:
 2241               		movw r30,r10
 2242 0ad6 87E0      		ld r24,Z
 2243 0ad8 0E94 0000 		ori r24,lo8(16)
 2244 0adc C80F      		st Z,r24
 2245 0ade D91F      	.L110:
 2247               	.LM241:
 2248               		ldi r24,lo8(1)
 2249 0ae0 8091 0000 		call set_relais
 2251 0ae6 01F0      	.LM242:
 2252 0ae8 8130      		movw r30,r10
 2253 0aea 00F0      		ld r24,Z
 2254 0aec 8230      		ori r24,lo8(8)
 2255 0aee 01F0      		st Z,r24
 2256 0af0 8330      		rjmp .L112
 2257 0af2 01F4      	.L116:
 2259               	.LM243:
 2260               		ldi r24,lo8(0)
 2261               		call set_relais
 2263 0af8 0E94 0000 	.LM244:
 2264               		movw r30,r10
 2265               		ld r24,Z
 2266 0afc F501      		andi r24,lo8(-17)
 2267 0afe 8081      		st Z,r24
 2269 0b02 8083      	.LM245:
 2270               		ld r24,Z
 2271               		ori r24,lo8(8)
 2272 0b04 8081      		st Z,r24
 2273 0b06 877F      		movw r14,r6
 2274 0b08 8083      		movw r12,r6
 2275               		rjmp .L112
 2276               	.L115:
 2278 0b0e 9924      	.LM246:
 2279 0b10 00C0      		sts mode,__zero_reg__
 2280               	.L112:
 2281               	.LBB63:
 2282               	.LBB62:
 2283 0b12 F501      	.LBB61:
 2284 0b14 8081      	.LBB60:
 2286 0b18 8083      	.Ltext13:
 2288               	.LM247:
 2289               		movw r24,r4
 2290 0b1a 81E0      	/* #APP */
 2291 0b1c 0E94 0000 	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 2292               		1: sbiw r24,1
 2293               		brne 1b
 2294 0b20 F501      	 ;  0 "" 2
 2295 0b22 8081      	/* #NOAPP */
 2296 0b24 8860      		rjmp .L113
 2297 0b26 8083      	.LBE60:
 2298 0b28 00C0      	.LBE61:
 2299               	.LBE62:
 2300               	.LBE63:
 2314 0b3c 8083      	.Lscope20:
 2315 0b3e 7301      	.global	interval
 2316 0b40 6301      		.data
 695:ir_heat.c     **** 			slope = 0;
 696:ir_heat.c     **** 			integral = 0;
 697:ir_heat.c     **** 			break;
 698:ir_heat.c     **** 		default:
 699:ir_heat.c     **** 			mode = MODE_OFF;
 2319               	rval
 2320               		.data
 2323               	interval:
 2324               		.byte	-12
 2325               	.global	off_counter
 2326               	.global	off_counter
 2327               		.section .bss
 2330               	off_counter:
 2331 0b48 C201      		.skip 1,0
 2332               	.global	flash_button
 2333               	.global	flash_button
 2336               	flash_button:
 2337               		.skip 1,0
 2338 0b4e 00C0      	.global	flash_LED
 2339               	.global	flash_LED
 2342               	flash_LED:
 2343               		.skip 1,0
 2344               		.lcomm last.1975,1
 2345               		.lcomm running.1751,1
 2346               		.lcomm c2.1725,1
 2347               		.lcomm c1.1724,1
 2348               		.comm tbuf,32,1
 2349               		.comm rbuf,32,1
 2350               		.comm t_in,1,1
 2351               		.comm t_out,1,1
 2352               		.comm r_in,1,1
 2353               		.comm r_out,1,1
 2354               		.comm t_array,12,1
 2355               		.comm mode,1,1
 2356               		.comm slope2,2,1
 2374               		.text
 2376               	.Letext0:
 2377               	.global __do_copy_data
 2378               	.global __do_clear_bss
 2379               	...
DEFINED SYMBOLS
                            *ABS*:00000000 ir_heat.c
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:2      *ABS*:0000003f __SREG__
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:3      *ABS*:0000003e __SP_H__
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:4      *ABS*:0000003d __SP_L__
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:5      *ABS*:00000034 __CCP__
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:89     .text:00000000 __vector_9
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:2361   .data:000000bf interval
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:120    .text:00000022 __vector_13
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:153    .text:00000042 __vector_16
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:2384   .bss:00000006 c1.1724
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:2383   .bss:00000005 c2.1725
                            *COM*:00000001 mode
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:274    .text:000000de __vector_18
                            *COM*:00000001 r_in
                            *COM*:00000020 rbuf
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:324    .text:0000011c __vector_19
                            *COM*:00000001 t_in
                            *COM*:00000001 t_out
                            *COM*:00000020 tbuf
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:387    .text:00000176 tbuflen
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:409    .text:00000182 UART_putchar
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:466    .text:000001ce rbuflen
                            *COM*:00000001 r_out
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:487    .text:000001da UART_getchar
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:526    .text:00000200 add_value
                            *COM*:0000000c t_array
                            *COM*:00000002 slope2
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:641    .text:000002c6 get_slope
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:718    .text:00000346 get_last_slope
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:744    .text:00000360 _beep
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:820    .text:0000039e beep
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:967    .text:00000412 set_relais
                             .bss:00000003 last.1975
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:1036   .text:00000458 __vector_1
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:2382   .bss:00000004 running.1751
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:1303   .text:0000058c get_temperature
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:1395   .text:000005f0 print_array
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:1533   .text:000006ec UART_first_init
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:1592   .text:00000714 main
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:2368   .bss:00000000 off_counter
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:2374   .bss:00000001 flash_button
C:\Users\Thorsten\AppData\Local\Temp/ccfD11pe.s:2380   .bss:00000002 flash_LED

UNDEFINED SYMBOLS
__divmodhi4
__udivmodhi4
puts
i2c_start
i2c_write
i2c_rep_start
i2c_read_ack
i2c_stop
printf
putchar
fdevopen
i2c_init
__do_copy_data
__do_clear_bss
