   1               		.file	"ir_heat.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  87               	.global	__vector_9
  89               	__vector_9:
   1:ir_heat.c     **** // ***********************************************************
   2:ir_heat.c     **** // Project:
   3:ir_heat.c     **** // Author:
   4:ir_heat.c     **** // Module description:
   5:ir_heat.c     **** // ***********************************************************
   6:ir_heat.c     **** 
   7:ir_heat.c     **** #ifndef F_CPU
   8:ir_heat.c     **** #define F_CPU 1000000UL
   9:ir_heat.c     **** #endif
  10:ir_heat.c     **** 
  11:ir_heat.c     **** #include <avr\io.h>              // Most basic include files
  12:ir_heat.c     **** #include <avr\interrupt.h>       // Add the necessary ones
  13:ir_heat.c     **** //#include <avr\signal.h>          // here
  14:ir_heat.c     **** #include <avr\wdt.h>
  15:ir_heat.c     **** 
  16:ir_heat.c     **** #include <stdio.h>
  17:ir_heat.c     **** #include <string.h>
  18:ir_heat.c     **** #include <stdlib.h>
  19:ir_heat.c     **** #include	<util/delay.h>
  20:ir_heat.c     **** 
  21:ir_heat.c     **** #include "i2c_mstr.h"
  22:ir_heat.c     **** #include "ir_heat.h"
  23:ir_heat.c     **** 
  24:ir_heat.c     **** #define 	MLX90614_WRITE	(0x5A<<1)
  25:ir_heat.c     **** #define 	MLX90614_READ	(MLX90614_WRITE+1)
  26:ir_heat.c     **** #define	ADR_T_A			0x06
  27:ir_heat.c     **** #define	ADR_T_OBJ1		0x07
  28:ir_heat.c     **** #define	ADR_T_OBJ2		0x08
  29:ir_heat.c     **** #define	DEFAULT_TEMP	150
  30:ir_heat.c     **** 
  31:ir_heat.c     **** 
  32:ir_heat.c     **** #define __STDIO_FDEVOPEN_COMPAT_12						
  33:ir_heat.c     **** // Buffer sizes must be 2^n
  34:ir_heat.c     **** //
  35:ir_heat.c     **** #define TBUFSIZE			32
  36:ir_heat.c     **** #define RBUFSIZE			32
  37:ir_heat.c     **** 
  38:ir_heat.c     **** #define TMASK				(TBUFSIZE-1)
  39:ir_heat.c     **** #define RMASK				(RBUFSIZE-1)
  40:ir_heat.c     **** 
  41:ir_heat.c     **** #define FLASH_LED			PC3
  42:ir_heat.c     **** #define STATUS_LED1		PD4
  43:ir_heat.c     **** #define STATUS_LED2		PD3
  44:ir_heat.c     **** #define RELAIS				PB6
  45:ir_heat.c     **** #define BUZZER				PB7
  46:ir_heat.c     **** #define SWITCH				PD2
  47:ir_heat.c     **** 
  48:ir_heat.c     **** #define RELAIS_ON			PORTB |= (1<<RELAIS)
  49:ir_heat.c     **** #define RELAIS_OFF		PORTB &=~(1<<RELAIS)
  50:ir_heat.c     **** 
  51:ir_heat.c     **** #define BUZZER_ON			PORTB |= (1<<BUZZER)
  52:ir_heat.c     **** #define BUZZER_OFF		PORTB &=~(1<<BUZZER)
  53:ir_heat.c     **** 
  54:ir_heat.c     **** #define STATUS_LED1_ON	PORTD |= (1<<STATUS_LED1)
  55:ir_heat.c     **** #define STATUS_LED1_OFF	PORTD &=~(1<<STATUS_LED1)
  56:ir_heat.c     **** 
  57:ir_heat.c     **** #define FLASH_LED_ON		PORTC |= (1<<FLASH_LED)
  58:ir_heat.c     **** #define FLASH_LED_OFF	PORTC &=~(1<<FLASH_LED)
  59:ir_heat.c     **** 
  60:ir_heat.c     **** #define STATUS_LED2_ON	PORTD |= (1<<STATUS_LED2)
  61:ir_heat.c     **** #define STATUS_LED2_OFF	PORTD &=~(1<<STATUS_LED2)
  62:ir_heat.c     **** 
  63:ir_heat.c     **** #define OFF_COUNTER		2
  64:ir_heat.c     **** 
  65:ir_heat.c     **** #define TIMER1_STOP		TCCR1B = 0
  66:ir_heat.c     **** #define TIMER1_RUN		TCCR1B = (0<<CS12) | (1<<CS11) | (0<<CS10)
  67:ir_heat.c     **** 
  68:ir_heat.c     **** #define	MODE_OFF				0
  69:ir_heat.c     **** #define	MODE_ON				1
  70:ir_heat.c     **** #define	MODE_ON_NO_PROT	2
  71:ir_heat.c     **** #define	MODE_TEMP_PROT		3
  72:ir_heat.c     **** 
  73:ir_heat.c     **** #define	BEEP_SHORT			1
  74:ir_heat.c     **** #define	BEEP_2SHORT			2
  75:ir_heat.c     **** #define	BEEP_LONG			3
  76:ir_heat.c     **** #define	BEEP_XLONG			4
  77:ir_heat.c     **** #define	BEEP_2LONG			5
  78:ir_heat.c     **** #define	BEEP_SHORT_LONG	6
  79:ir_heat.c     **** 
  80:ir_heat.c     **** // Define here the global static variables
  81:ir_heat.c     **** //
  82:ir_heat.c     **** volatile unsigned char tbuf[TBUFSIZE];  // TX buffer
  83:ir_heat.c     **** volatile unsigned char rbuf[RBUFSIZE];  // RX buffer
  84:ir_heat.c     **** 
  85:ir_heat.c     **** volatile unsigned char t_in;            // TX buffer in index
  86:ir_heat.c     **** volatile unsigned char t_out;           // TX buffer out index
  87:ir_heat.c     **** 
  88:ir_heat.c     **** volatile unsigned char r_in;            // RX buffer in index
  89:ir_heat.c     **** volatile unsigned char r_out;           // RX buffer out index
  90:ir_heat.c     **** 
  91:ir_heat.c     **** int8_t	interval = -12;
  92:ir_heat.c     **** int16_t 	t_array[6];
  93:ir_heat.c     **** uint8_t	off_counter = 0;
  94:ir_heat.c     **** uint8_t	mode;
  95:ir_heat.c     **** int16_t	slope2;
  96:ir_heat.c     **** uint8_t	flash_button = 0;
  97:ir_heat.c     **** uint8_t	flash_LED = 0;
  98:ir_heat.c     **** 
  99:ir_heat.c     **** /*
 100:ir_heat.c     **** uint16_t	t_la_threshold_up 	=  300;
 101:ir_heat.c     **** uint16_t	t_abs_threshold_up 	=  270;
 102:ir_heat.c     **** uint16_t	t_la_threshold_down 	=  250;
 103:ir_heat.c     **** uint16_t	t_abs_threshold_down	=  250;
 104:ir_heat.c     **** */
 105:ir_heat.c     **** 
 106:ir_heat.c     **** 
 107:ir_heat.c     **** // Clock Timer
 108:ir_heat.c     **** SIGNAL(SIG_OVERFLOW2) {
  90               	ush r0
  91               		clr __zero_reg__
  92               		push r24
  93 0000 1F92      	/* prologue: Signal */
  94 0002 0F92      	/* frame size = 0 */
  96 0006 0F92      	.LM1:
  97 0008 1124      		lds r24,interval
  98 000a 8F93      		subi r24,lo8(-(1))
  99               		sts interval,r24
 100               	/* epilogue start */
 109:ir_heat.c     **** 	interval++;
 101               	0,110,.LM2-.LFBB1
 102               	.LM2:
 103 000c 8091 0000 		pop r24
 104 0010 8F5F      		pop r0
 105 0012 8093 0000 		out __SREG__,r0
 106               		pop r0
 110:ir_heat.c     **** }
 107               	_zero_reg__
 108               		reti
 110 0018 0F90      	.Lscope1:
 112 001c 0F90      	.global	__vector_13
 114 0020 1895      	__vector_13:
 116               	.LM3:
 117               	.LFBB2:
 118               		push __zero_reg__
 119               		push r0
 120               		in r0,__SREG__
 111:ir_heat.c     **** 
 112:ir_heat.c     **** SIGNAL(SIG_OVERFLOW1) {
 121               	__zero_reg__
 122               	/* prologue: Signal */
 123               	/* frame size = 0 */
 125 0024 0F92      	.LM4:
 126 0026 0FB6      		sts 129,__zero_reg__
 128 002a 1124      	.LM5:
 129               		sts 133,__zero_reg__
 113:ir_heat.c     **** 	TIMER1_STOP;
 131               	 132,__zero_reg__
 132               	/* epilogue start */
 114:ir_heat.c     **** 	TCNT1H = 0;
 134               	7:
 135               		pop r0
 136 0030 1092 8500 		out __SREG__,r0
 115:ir_heat.c     **** 	TCNT1L = 0;
 137               	p r0
 138               		pop __zero_reg__
 139 0034 1092 8400 		reti
 116:ir_heat.c     **** }
 141               	ope2:
 143 0038 0F90      	.global	__vector_16
 145 003c 0F90      	__vector_16:
 147 0040 1895      	.LM8:
 148               	.LFBB3:
 149               		push __zero_reg__
 150               		push r0
 151               		in r0,__SREG__
 152               		push r0
 153               		clr __zero_reg__
 117:ir_heat.c     **** 
 118:ir_heat.c     **** 
 119:ir_heat.c     **** // LED Flasher
 120:ir_heat.c     **** SIGNAL(SIG_OVERFLOW0) {
 154               	sh r19
 155               		push r20
 156               		push r24
 157 0042 1F92      		push r25
 158 0044 0F92      		push r30
 159 0046 0FB6      		push r31
 160 0048 0F92      	/* prologue: Signal */
 161 004a 1124      	/* frame size = 0 */
 163 004e 3F93      	.LM9:
 164 0050 4F93      		lds r24,c1.1730
 165 0052 8F93      		mov r18,r24
 166 0054 9F93      		subi r18,lo8(-(1))
 167 0056 EF93      		sts c1.1730,r18
 169               	.LM10:
 170               		lds r24,c2.1731
 121:ir_heat.c     **** 	static uint8_t	c1 = 0;
 122:ir_heat.c     **** 	static uint8_t c2 = 0;
 123:ir_heat.c     **** 	uint8_t slow=0;
 124:ir_heat.c     **** 	c1++;
 171               	i r19,lo8(-(1))
 172               		sts c2.1731,r19
 174 005e 282F      	.LM11:
 175 0060 2F5F      		lds r20,mode
 176 0062 2093 0000 		cpi r20,lo8(3)
 125:ir_heat.c     **** 	c2++;
 177               	.L6
 179 0066 8091 0000 	.LM12:
 180 006a 382F      		mov r24,r18
 181 006c 3F5F      		ldi r25,lo8(0)
 182 006e 3093 0000 		sbiw r24,7
 126:ir_heat.c     **** 	
 127:ir_heat.c     **** 	// Tasten LED
 128:ir_heat.c     **** 	if (mode==MODE_TEMP_PROT) {
 183               	.L6
 185 0072 4091 0000 	.LM13:
 186 0076 4330      		ldi r30,lo8(40)
 187 0078 01F4      		ldi r31,hi8(40)
 129:ir_heat.c     **** 		if(c1 > (6<<slow)) {
 188               	24,Z
 189               		ori r24,lo8(8)
 190 007a 822F      		st Z,r24
 191 007c 90E0      	.L6:
 193 0080 04F0      	.LM14:
 130:ir_heat.c     **** 			FLASH_LED_ON;
 194               	24,r18
 195               		ldi r25,lo8(0)
 196 0082 E8E2      		sbiw r24,11
 197 0084 F0E0      		brlt .L7
 199 0088 8860      	.LM15:
 200 008a 8083      		sts c1.1730,__zero_reg__
 131:ir_heat.c     **** 		}
 132:ir_heat.c     **** 	}
 133:ir_heat.c     **** 	if(c1 > (10<<slow)) {
 202               	ldi r30,lo8(40)
 203               		ldi r31,hi8(40)
 204 008c 822F      		ld r24,Z
 205 008e 90E0      		andi r24,lo8(-9)
 206 0090 0B97      		st Z,r24
 207 0092 04F0      	.L7:
 134:ir_heat.c     **** 		c1 = 0;
 208               	n	68,0,139,.LM17-.LFBB3
 209               	.LM17:
 210 0094 1092 0000 		cpi r20,lo8(2)
 135:ir_heat.c     **** 		FLASH_LED_OFF;
 211               	ne .L8
 213 0098 E8E2      	.LM18:
 214 009a F0E0      		cpi r19,lo8(121)
 215 009c 8081      		brlo .L8
 217 00a0 8083      	.LM19:
 218               		ldi r30,lo8(43)
 136:ir_heat.c     **** 	}
 137:ir_heat.c     **** 	
 138:ir_heat.c     **** 	// Status LED
 139:ir_heat.c     **** 	if (mode==MODE_ON_NO_PROT) {
 219               	,hi8(43)
 220               		ld r24,Z
 221 00a2 4230      		andi r24,lo8(-17)
 222 00a4 01F4      		st Z,r24
 140:ir_heat.c     **** 		if(c2 > 120) {
 223               	
 225 00a6 3937      	.LM20:
 226 00a8 00F0      		cpi r19,lo8(-120)
 141:ir_heat.c     **** 			STATUS_LED1_OFF;	// rot
 227               	lo .L10
 229 00aa EBE2      	.LM21:
 230 00ac F0E0      		sts c2.1731,__zero_reg__
 232 00b0 8F7E      	.LM22:
 233 00b2 8083      		ldi r30,lo8(43)
 234               		ldi r31,hi8(43)
 142:ir_heat.c     **** 		}
 143:ir_heat.c     **** 	}
 144:ir_heat.c     **** 	if(c2 > 135) {
 235               	Z
 236               		ori r24,lo8(16)
 237 00b4 3838      		st Z,r24
 238 00b6 00F0      	.L10:
 145:ir_heat.c     **** 		c2 = 0;
 239               	pilogue start */
 241 00b8 1092 0000 	.LM23:
 146:ir_heat.c     **** 		STATUS_LED1_ON; 		// orange
 242               	p r31
 243               		pop r30
 244 00bc EBE2      		pop r25
 245 00be F0E0      		pop r24
 246 00c0 8081      		pop r20
 247 00c2 8061      		pop r19
 248 00c4 8083      		pop r18
 249               		pop r0
 250               		out __SREG__,r0
 147:ir_heat.c     **** 	}	
 148:ir_heat.c     **** }
 251               	pop __zero_reg__
 252               		reti
 258 00d0 3F91      	.Lscope3:
 260 00d4 0F90      	.global	__vector_18
 262 00d8 0F90      	__vector_18:
 264 00dc 1895      	.LM24:
 265               	.LFBB4:
 266               		push __zero_reg__
 267               		push r0
 268               		in r0,__SREG__
 269               		push r0
 270               		clr __zero_reg__
 271               		push r24
 272               		push r30
 273               		push r31
 274               	/* prologue: Signal */
 149:ir_heat.c     **** 
 150:ir_heat.c     **** 
 151:ir_heat.c     **** 
 152:ir_heat.c     **** //*******************************************
 153:ir_heat.c     **** //
 154:ir_heat.c     **** // Taster IQR und Entprellung
 155:ir_heat.c     **** //
 156:ir_heat.c     **** SIGNAL(SIG_INTERRUPT0) {
 157:ir_heat.c     **** 	static uint8_t running = 0;
 158:ir_heat.c     **** 	
 159:ir_heat.c     **** 	if(running | TCNT1H | TCNT1L){
 160:ir_heat.c     **** //		printf("X");
 161:ir_heat.c     **** 		return;
 162:ir_heat.c     **** 	}
 163:ir_heat.c     **** 	running = 1;
 164:ir_heat.c     **** 	wdt_reset();
 165:ir_heat.c     **** 	
 166:ir_heat.c     **** 	uint16_t i;
 167:ir_heat.c     **** 	uint16_t c = 0;
 168:ir_heat.c     **** 	EIMSK = 0;
 169:ir_heat.c     **** 	sei();
 170:ir_heat.c     **** 	//printf("In");
 171:ir_heat.c     **** 	for(i=0;i<1000;i++) if((PIND & (1<<SWITCH))) c++;
 172:ir_heat.c     **** 	//printf(" %i ", c);
 173:ir_heat.c     **** 
 174:ir_heat.c     **** 	if(c < 200) {
 175:ir_heat.c     **** 		TCNT1L = 1;
 176:ir_heat.c     **** 		TIMER1_RUN;
 177:ir_heat.c     **** 		switch(mode) {
 178:ir_heat.c     **** 		case MODE_OFF:
 179:ir_heat.c     **** 			mode = MODE_ON;
 180:ir_heat.c     **** 			set_relais(1);
 181:ir_heat.c     **** 			STATUS_LED1_ON;			// orange
 182:ir_heat.c     **** 			STATUS_LED2_ON;
 183:ir_heat.c     **** 			c = 0;
 184:ir_heat.c     **** 			while((!(PIND & (1<<SWITCH))) && (c < 300)) {
 185:ir_heat.c     **** 				c++;
 186:ir_heat.c     **** 				_delay_ms (10);
 187:ir_heat.c     **** 			}
 188:ir_heat.c     **** 			//printf("c: %i", c);
 189:ir_heat.c     **** 
 190:ir_heat.c     **** 			if(c < 300) {
 191:ir_heat.c     **** 				// normal einnschalten
 192:ir_heat.c     **** 				mode = MODE_ON;
 193:ir_heat.c     **** 			}
 194:ir_heat.c     **** 			else {
 195:ir_heat.c     **** 				// einschalten, aber ohne Hitzeschutz
 196:ir_heat.c     **** 				mode = MODE_ON_NO_PROT;
 197:ir_heat.c     **** 				printf("Temperature Protection Off!\n");
 198:ir_heat.c     **** 				STATUS_LED1_OFF;		// rot
 199:ir_heat.c     **** 				STATUS_LED2_ON;
 200:ir_heat.c     **** 				beep(BEEP_SHORT_LONG);
 201:ir_heat.c     **** 			}
 202:ir_heat.c     **** 			break;
 203:ir_heat.c     **** 		case MODE_ON:
 204:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 205:ir_heat.c     **** 		case MODE_TEMP_PROT:
 206:ir_heat.c     **** 		default:
 207:ir_heat.c     **** 			printf("\nxXx\n");
 208:ir_heat.c     **** 			mode = MODE_OFF;
 209:ir_heat.c     **** 		}
 210:ir_heat.c     **** 	}
 211:ir_heat.c     **** //	printf("Out\n");
 212:ir_heat.c     **** 	EIFR 		= (1<<INTF0);
 213:ir_heat.c     **** 	EIMSK 	= (1<<INT0);
 214:ir_heat.c     **** 	running 	= 0;
 215:ir_heat.c     **** 	//printf("Exit\n");
 216:ir_heat.c     **** }
 217:ir_heat.c     **** 
 218:ir_heat.c     **** 
 219:ir_heat.c     **** 
 220:ir_heat.c     **** SIGNAL(SIG_USART_RECV) {
 275               	tabn	68,0,225,.LM25-.LFBB4
 276               	.LM25:
 277               		lds r24,198
 279 00e0 0F92      	.LM26:
 280 00e2 0FB6      		lds r30,r_in
 281 00e4 0F92      		ldi r31,lo8(0)
 282 00e6 1124      		andi r30,lo8(31)
 283 00e8 8F93      		andi r31,hi8(31)
 284 00ea EF93      		subi r30,lo8(-(rbuf))
 285 00ec FF93      		sbci r31,hi8(-(rbuf))
 286               		st Z,r24
 221:ir_heat.c     **** //******************
 222:ir_heat.c     **** // RX interrupt handler
 223:ir_heat.c     **** //
 224:ir_heat.c     **** 	char c;	
 225:ir_heat.c     **** 	c = UDR0;							// Get received char
 288               	24,r_in
 289               		subi r24,lo8(-(1))
 290 00ee 8091 C600 		sts r_in,r24
 226:ir_heat.c     **** 	rbuf[r_in & RMASK] = c;
 291               	epilogue start */
 293 00f2 E091 0000 	.LM28:
 294 00f6 F0E0      		pop r31
 295 00f8 EF71      		pop r30
 296 00fa F070      		pop r24
 297 00fc E050      		pop r0
 298 00fe F040      		out __SREG__,r0
 299 0100 8083      		pop r0
 227:ir_heat.c     **** 	r_in++;
 300               	ro_reg__
 301               		reti
 228:ir_heat.c     **** }
 306               	e4:
 308 010c FF91      	.global	__vector_19
 310 0110 8F91      	__vector_19:
 312 0114 0FBE      	.LM29:
 313 0116 0F90      	.LFBB5:
 314 0118 1F90      		push __zero_reg__
 315 011a 1895      		push r0
 316               		in r0,__SREG__
 317               		push r0
 318               		clr __zero_reg__
 319               		push r24
 320               		push r25
 321               		push r30
 322               		push r31
 323               	/* prologue: Signal */
 324               	/* frame size = 0 */
 229:ir_heat.c     **** 
 230:ir_heat.c     **** SIGNAL(SIG_USART_DATA) {
 325               	M30-.LFBB5
 326               	.LM30:
 327               		lds r25,t_in
 328 011c 1F92      		lds r24,t_out
 329 011e 0F92      		cp r25,r24
 330 0120 0FB6      		breq .L14
 332 0124 1124      	.LM31:
 333 0126 8F93      		lds r30,t_out
 334 0128 9F93      		ldi r31,lo8(0)
 335 012a EF93      		andi r30,lo8(31)
 336 012c FF93      		andi r31,hi8(31)
 337               		subi r30,lo8(-(tbuf))
 338               		sbci r31,hi8(-(tbuf))
 231:ir_heat.c     **** //*******************
 232:ir_heat.c     **** // Data register empty interrupt handler.
 233:ir_heat.c     **** // Indicates that next char can be transmitted
 234:ir_heat.c     **** //
 235:ir_heat.c     **** 	if(t_in != t_out) {
 339               	 198,r24
 341 012e 9091 0000 	.LM32:
 342 0132 8091 0000 		lds r24,t_out
 343 0136 9817      		subi r24,lo8(-(1))
 344 0138 01F0      		sts t_out,r24
 236:ir_heat.c     **** 		UDR0 = tbuf[t_out & TMASK];
 345               	.L16
 346               	.L14:
 348 013e F0E0      	.LM33:
 349 0140 EF71      		ldi r30,lo8(193)
 350 0142 F070      		ldi r31,hi8(193)
 351 0144 E050      		ld r24,Z
 352 0146 F040      		andi r24,lo8(-33)
 353 0148 8081      		st Z,r24
 354 014a 8093 C600 	.L16:
 237:ir_heat.c     **** 		t_out++;	
 355               	e start */
 357 014e 8091 0000 	.LM34:
 358 0152 8F5F      		pop r31
 359 0154 8093 0000 		pop r30
 360 0158 00C0      		pop r25
 361               		pop r24
 238:ir_heat.c     **** 	}
 239:ir_heat.c     **** 	else {
 240:ir_heat.c     **** 		UCSR0B &= ~(1<<UDRIE0);
 362               	
 363               		out __SREG__,r0
 364 015a E1EC      		pop r0
 365 015c F0E0      		pop __zero_reg__
 366 015e 8081      		reti
 368 0162 8083      	.Lscope5:
 370               	.global	tbuflen
 241:ir_heat.c     **** 	}
 242:ir_heat.c     **** }
 371               	buflen, @function
 372               	tbuflen:
 374 0166 EF91      	.LM35:
 375 0168 9F91      	.LFBB6:
 376 016a 8F91      	/* prologue: function */
 377 016c 0F90      	/* frame size = 0 */
 379 0170 0F90      	.LM36:
 380 0172 1F90      		lds r24,t_in
 381 0174 1895      		lds r25,t_out
 383               	.LM37:
 384               		sub r24,r25
 385               	/* epilogue start */
 386               		ret
 243:ir_heat.c     **** 
 244:ir_heat.c     **** char tbuflen(void) {
 388               		"UART_putchar:F(0,1)",36,0,0,UART_putchar
 391               	.global	UART_putchar
 245:ir_heat.c     **** //****************
 246:ir_heat.c     **** // Retrieve pending chars in TX buffer
 247:ir_heat.c     **** //
 248:ir_heat.c     **** 	return(t_in - t_out);
 393               	putchar:
 395 0176 8091 0000 	.LM38:
 396 017a 9091 0000 	.LFBB7:
 249:ir_heat.c     **** }
 397               	h r17
 398               		push r28
 399 017e 891B      		push r29
 400               	/* prologue: function */
 401 0180 0895      	/* frame size = 0 */
 402               		mov r17,r24
 404               	.LM39:
 405               		ldi r28,lo8(32)
 406               		ldi r29,hi8(32)
 407               	.L20:
 408               		call tbuflen
 409               		movw r18,r28
 250:ir_heat.c     **** 
 251:ir_heat.c     **** int UART_putchar(char c, FILE *stream) {
 410               		sbc r19,__zero_reg__
 411               		cpi r18,3
 412               		cpc r19,__zero_reg__
 413 0182 1F93      		brlt .L20
 415 0186 DF93      	.LM40:
 416               		lds r30,t_in
 417               		ldi r31,lo8(0)
 418 0188 182F      		andi r30,lo8(31)
 252:ir_heat.c     **** //*********************
 253:ir_heat.c     **** // Fills the transmit buffer, if it is full wait
 254:ir_heat.c     **** //
 255:ir_heat.c     **** 	while((TBUFSIZE - tbuflen()) <= 2);  // Wait...
 419               	,hi8(31)
 420               		subi r30,lo8(-(tbuf))
 421 018a C0E2      		sbci r31,hi8(-(tbuf))
 422 018c D0E0      		st Z,r17
 424 018e 0E94 0000 	.LM41:
 425 0192 9E01      		lds r24,t_in
 426 0194 281B      		subi r24,lo8(-(1))
 427 0196 3109      		sts t_in,r24
 429 019a 3105      	.LM42:
 430 019c 04F0      		ldi r30,lo8(193)
 256:ir_heat.c     **** 	
 257:ir_heat.c     **** 	// Add data to the transmit buffer, enable TXCIE
 258:ir_heat.c     **** 	//
 259:ir_heat.c     **** 	tbuf[t_in & TMASK] = c;
 431               	(193)
 432               		ld r24,Z
 433 019e E091 0000 		ori r24,lo8(32)
 434 01a2 F0E0      		st Z,r24
 436 01a6 F070      	.LM43:
 437 01a8 E050      		ldi r24,lo8(0)
 438 01aa F040      		ldi r25,hi8(0)
 439 01ac 1083      	/* epilogue start */
 260:ir_heat.c     **** 	t_in++;	
 440               		pop r28
 441               		pop r17
 442 01ae 8091 0000 		ret
 444 01b4 8093 0000 	.Lscope7:
 261:ir_heat.c     **** 	UCSR0B |= (1<<UDRIE0);			// Enable UDR empty interrupt	
 445               	bs	"rbuflen:F(0,2)",36,0,0,rbuflen
 446               	.global	rbuflen
 448 01ba F0E0      	rbuflen:
 450 01be 8062      	.LM44:
 451 01c0 8083      	.LFBB8:
 262:ir_heat.c     **** 	return(0);
 263:ir_heat.c     **** }
 452               	ogue: function */
 453               	/* frame size = 0 */
 455 01c4 90E0      	.LM45:
 456               		lds r24,r_in
 457 01c6 DF91      		lds r25,r_out
 459 01ca 1F91      	.LM46:
 460 01cc 0895      		sub r24,r25
 461               	/* epilogue start */
 462               		ret
 464               	.Lscope8:
 264:ir_heat.c     **** 
 265:ir_heat.c     **** char rbuflen(void) {
 467               	tchar
 469               	UART_getchar:
 471               	.LM47:
 266:ir_heat.c     **** // ***************
 267:ir_heat.c     **** // Retrive pending chars in RX buffer
 268:ir_heat.c     **** //
 269:ir_heat.c     **** 	return(r_in - r_out);
 472               	9:
 473               	/* prologue: function */
 474 01ce 8091 0000 	/* frame size = 0 */
 475 01d2 9091 0000 	.L26:
 270:ir_heat.c     **** }
 476               	abn	68,0,278,.LM48-.LFBB9
 477               	.LM48:
 478 01d6 891B      		call rbuflen
 479               		tst r24
 480 01d8 0895      		breq .L26
 482               	.LM49:
 483               		lds r30,r_out
 484               		ldi r31,lo8(0)
 485               		andi r30,lo8(31)
 486               		andi r31,hi8(31)
 487               		subi r30,lo8(-(rbuf))
 271:ir_heat.c     **** 
 272:ir_heat.c     **** int UART_getchar(FILE *stream) {
 488               	8(-(rbuf))
 489               		ld r24,Z
 491               	.LM50:
 492               		lds r25,r_out
 493               		subi r25,lo8(-(1))
 273:ir_heat.c     **** //*******************
 274:ir_heat.c     **** // Retieves character from UART. This function is to be passed
 275:ir_heat.c     **** // to fdevopen
 276:ir_heat.c     **** //
 277:ir_heat.c     **** 	unsigned char c;
 278:ir_heat.c     **** 	while(rbuflen() == 0);	  // Wait...
 494               	_out,r25
 496 01da 0E94 0000 	.LM51:
 497 01de 8823      		ldi r25,lo8(0)
 498 01e0 01F0      	/* epilogue start */
 279:ir_heat.c     **** 	c = rbuf[r_out & RMASK];
 503 01e8 EF71      	.Lscope9:
 506 01ee F040      	.global	exp_slope
 280:ir_heat.c     **** 	r_out++;	
 508               	:
 510 01f2 9091 0000 	.LM52:
 511 01f6 9F5F      	.LFBB10:
 512 01f8 9093 0000 	/* prologue: function */
 281:ir_heat.c     **** 	return(c);
 282:ir_heat.c     **** }
 513               	ame size = 0 */
 515 01fc 90E0      	.LM53:
 516               		clr r18
 517 01fe 0895      		clr r19
 518               		sub r18,r24
 519               		sbc r19,r25
 520               		brpl .L30
 521               		subi r18,lo8(-(15))
 522               		sbci r19,hi8(-(15))
 523               	.L30:
 524               		movw r24,r18
 525               		asr r25
 526               		ror r24
 527               		asr r25
 283:ir_heat.c     **** 
 284:ir_heat.c     **** void UART_first_init(void) {
 285:ir_heat.c     **** //***********************
 286:ir_heat.c     **** // The function fdevopen(..) must contain as parameters the
 287:ir_heat.c     **** // corresponding  ..putchar() and  ..getchar() functions, defined before.
 288:ir_heat.c     **** //
 289:ir_heat.c     **** 	UBRR0 = 12;										 		// 4800 BPS
 290:ir_heat.c     **** 	
 291:ir_heat.c     **** 	UCSR0B = (1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0);	// 8 Databits, receive and transmit enabled, receive a
 292:ir_heat.c     **** 	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
 293:ir_heat.c     **** 	
 294:ir_heat.c     **** 	fdevopen(UART_putchar, UART_getchar);
 295:ir_heat.c     **** 	sei();											 		// Global interrupt enable
 296:ir_heat.c     **** }
 297:ir_heat.c     **** 
 298:ir_heat.c     **** 
 299:ir_heat.c     **** 
 300:ir_heat.c     **** 
 301:ir_heat.c     **** int16_t exp_slope(int16_t temp) {
 528               	25
 529               		ror r24
 530               		asr r25
 531               		ror r24
 532               		movw r18,r24
 533               		lsl r18
 534               		rol r19
 535 0200 2227      		lsl r24
 536 0202 3327      		rol r25
 537 0204 281B      		lsl r24
 538 0206 390B      		rol r25
 539 0208 02F4      		lsl r24
 540 020a 215F      		rol r25
 541 020c 3F4F      		add r18,r24
 542               		adc r19,r25
 543 020e C901      		subi r18,lo8(-(320))
 544 0210 9595      		sbci r19,hi8(-(320))
 546 0214 9595      	.LM54:
 547 0216 8795      		mov r24,r18
 548 0218 9595      		mov r25,r19
 549 021a 8795      	/* epilogue start */
 550 021c 9595      		ret
 552 0220 9C01      	.Lscope10:
 554 0224 331F      	.global	get_slope2
 556 0228 991F      	get_slope2:
 558 022c 991F      	.LM55:
 559 022e 880F      	.LFBB11:
 560 0230 991F      	/* prologue: function */
 561 0232 280F      	/* frame size = 0 */
 563 0236 205C      	.LM56:
 564 0238 3E4F      		lds r24,t_array+10
 302:ir_heat.c     **** 	return 10 * (-temp/16 + 32);
 303:ir_heat.c     **** }
 565               	ray+4
 566               		lds r19,(t_array+4)+1
 567 023a 822F      		sub r24,r18
 568 023c 932F      		sbc r25,r19
 569               		lsl r24
 570 023e 0895      		rol r25
 571               		lsl r24
 572               		rol r25
 573               		lsl r24
 574               		rol r25
 575               		lds r18,last_slope.1889
 576               		lds r19,(last_slope.1889)+1
 304:ir_heat.c     **** 
 305:ir_heat.c     **** 
 306:ir_heat.c     **** int16_t get_slope2() {
 577               	
 578               		adc r25,r19
 579               		lsl r24
 580               		rol r25
 581               		ldi r22,lo8(3)
 307:ir_heat.c     **** 	static int16_t last_slope = 0;
 308:ir_heat.c     **** //	last_slope = (200*(t_array[5]-t_array[2]) / 16 +  2*last_slope) / 3;
 309:ir_heat.c     **** 	last_slope = (16*(t_array[5]-t_array[2]) +  2*last_slope) / 3;
 582               	 r23,hi8(3)
 583               		call __divmodhi4
 584 0240 8091 0000 		mov r24,r22
 585 0244 9091 0000 		mov r25,r23
 586 0248 2091 0000 		sts last_slope.1889,r22
 587 024c 3091 0000 		sts last_slope.1889+1,r23
 588 0250 821B      	/* epilogue start */
 590 0254 880F      	.LM57:
 591 0256 991F      		ret
 596 0260 2091 0000 	.Lscope11:
 598 0268 820F      	.global	add_value
 600 026c 880F      	add_value:
 602 0270 63E0      	.LM58:
 603 0272 70E0      	.LFBB12:
 604 0274 0E94 0000 	/* prologue: function */
 605 0278 862F      	/* frame size = 0 */
 606 027a 972F      		mov r20,r24
 607 027c 6093 0000 		mov r21,r25
 609               	.LM59:
 310:ir_heat.c     **** 	return last_slope;
 311:ir_heat.c     **** }
 610               	_array)+1
 611               		or r24,r25
 612 0284 0895      		brne .L35
 614               	.LM60:
 615               		ldi r30,lo8(t_array+10)
 616               		ldi r31,hi8(t_array+10)
 617               		st Z,r20
 618               		std Z+1,r21
 619               		movw r26,r30
 620               		sbiw r26,2
 621               		st X,r20
 312:ir_heat.c     **** 
 313:ir_heat.c     **** 
 314:ir_heat.c     **** 
 315:ir_heat.c     **** 
 316:ir_heat.c     **** //*********************************************
 317:ir_heat.c     **** //
 318:ir_heat.c     **** // Gibt den Temperatur Ringspeicher
 319:ir_heat.c     **** // über den UART aus
 320:ir_heat.c     **** //
 321:ir_heat.c     **** void print_array(){
 322:ir_heat.c     **** 	uint8_t i;
 323:ir_heat.c     ****   	printf("Array:");
 324:ir_heat.c     **** 	for(i=0;i<6;i++) {
 325:ir_heat.c     ****    	printf(" %i", t_array[i]);
 326:ir_heat.c     **** 	}
 327:ir_heat.c     ****   	printf("\n");
 328:ir_heat.c     **** }
 329:ir_heat.c     **** 
 330:ir_heat.c     **** 
 331:ir_heat.c     **** 
 332:ir_heat.c     **** //*********************************************
 333:ir_heat.c     **** //
 334:ir_heat.c     **** // Fügt einen Meßwert zum Ringspeicher hinzu
 335:ir_heat.c     **** // Der Ringspeicher enthält die letzten 6 Werte
 336:ir_heat.c     **** // t_array[5] ist der neuste Wert
 337:ir_heat.c     **** //
 338:ir_heat.c     **** void add_value(uint16_t value) {
 622               		st X,r21
 623               		movw r26,r30
 624               		sbiw r26,4
 625               		st X,r20
 626               		adiw r26,1
 627 0286 482F      		st X,r21
 628 0288 592F      		movw r26,r30
 339:ir_heat.c     **** 	uint8_t i;
 340:ir_heat.c     **** 	if(t_array[0]==0) {
 629               	26,6
 630               		st X,r20
 631 028a 8091 0000 		adiw r26,1
 632 028e 9091 0000 		st X,r21
 633 0292 892B      		movw r26,r30
 634 0294 01F4      		sbiw r26,8
 341:ir_heat.c     **** 		t_array[0]=t_array[1]=t_array[2]=t_array[3]=t_array[4]=t_array[5]=value;
 635               	r20
 636               		adiw r26,1
 637 0296 E0E0      		st X,r21
 638 0298 F0E0      		sbiw r30,10
 639 029a 4083      		st Z,r20
 640 029c 5183      		std Z+1,r21
 641 029e DF01      		ret
 642 02a0 1297      	.L35:
 643 02a2 4C93      		ldi r30,lo8(t_array)
 644 02a4 1196      		ldi r31,hi8(t_array)
 646 02a8 DF01      	.LM61:
 647 02aa 1497      		ldi r18,lo8(t_array+10)
 648 02ac 4C93      		ldi r19,hi8(t_array+10)
 649 02ae 1196      	.L37:
 651 02b2 DF01      	.LM62:
 652 02b4 1697      		ldd r24,Z+2
 653 02b6 4C93      		ldd r25,Z+3
 654 02b8 1196      		st Z+,r24
 655 02ba 5C93      		st Z+,r25
 657 02be 1897      	.LM63:
 658 02c0 4C93      		cp r30,r18
 659 02c2 1196      		cpc r31,r19
 660 02c4 5C93      		brne .L37
 662 02c8 4083      	.LM64:
 663 02ca 5183      		mov r18,r20
 664 02cc 0895      		mov r19,r21
 665               		sts (t_array+10)+1,r19
 666 02ce E0E0      		sts t_array+10,r18
 342:ir_heat.c     **** 	}
 343:ir_heat.c     **** 	else {
 344:ir_heat.c     **** 		for(i=0;i<5;i++) {
 668               	5,(t_array+8)+1
 669               		sub r18,r24
 670 02d2 20E0      		sbc r19,r25
 671 02d4 30E0      		movw r24,r18
 672               		lsl r24
 345:ir_heat.c     **** 			t_array[i]=t_array[i+1];
 673               	r25
 674               		lsl r18
 675 02d6 8281      		rol r19
 676 02d8 9381      		lsl r18
 677 02da 8193      		rol r19
 678 02dc 9193      		lsl r18
 679               		rol r19
 680               		add r24,r18
 681 02de E217      		adc r25,r19
 682 02e0 F307      		lds r22,slope2
 683 02e2 01F4      		lds r23,(slope2)+1
 346:ir_heat.c     **** 		}
 347:ir_heat.c     **** 		t_array[5] = value;
 684               	22
 685               		lsl r18
 686 02e4 242F      		rol r19
 687 02e6 352F      		movw r20,r18
 688 02e8 3093 0000 		lsl r20
 689 02ec 2093 0000 		rol r21
 348:ir_heat.c     **** 		slope2 = (10*(t_array[5]-t_array[4]) + 19*slope2) / 20;
 690               	20
 691               		rol r21
 692 02f0 8091 0000 		lsl r20
 693 02f4 9091 0000 		rol r21
 694 02f8 281B      		add r18,r20
 695 02fa 390B      		adc r19,r21
 696 02fc C901      		add r18,r22
 697 02fe 880F      		adc r19,r23
 698 0300 991F      		add r24,r18
 699 0302 220F      		adc r25,r19
 700 0304 331F      		ldi r22,lo8(20)
 701 0306 220F      		ldi r23,hi8(20)
 702 0308 331F      		call __divmodhi4
 703 030a 220F      		sts (slope2)+1,r23
 704 030c 331F      		sts slope2,r22
 705 030e 820F      		ret
 707 0312 6091 0000 	.Lscope12:
 709 031a 9B01      	.global	get_slope
 711 031e 331F      	get_slope:
 713 0322 440F      	.LM66:
 714 0324 551F      	.LFBB13:
 715 0326 440F      	/* prologue: function */
 716 0328 551F      	/* frame size = 0 */
 718 032c 551F      	.LM67:
 719 032e 240F      		ldi r26,lo8(t_array+8)
 720 0330 351F      		ldi r27,hi8(t_array+8)
 721 0332 260F      		movw r30,r26
 722 0334 371F      		ld r18,Z+
 723 0336 820F      		ld r19,Z+
 724 0338 931F      		lds r24,t_array+2
 725 033a 64E1      		lds r25,(t_array+2)+1
 726 033c 70E0      		sub r18,r24
 727 033e 0E94 0000 		sbc r19,r25
 728 0342 7093 0000 		movw r24,r18
 729 0346 6093 0000 		lsl r24
 730 034a 0895      		rol r25
 731               		lsl r24
 732               		rol r25
 733               		add r24,r18
 734               		adc r25,r19
 735               		sbiw r26,8
 736               		ld r20,Z
 349:ir_heat.c     **** 	}
 350:ir_heat.c     **** }
 351:ir_heat.c     **** 
 352:ir_heat.c     **** 
 353:ir_heat.c     **** 
 354:ir_heat.c     **** //********************************************
 355:ir_heat.c     **** //
 356:ir_heat.c     **** // Gibt die gemittelte Steigung
 357:ir_heat.c     **** // über die letzten 4 Sekunden zurück
 358:ir_heat.c     **** //
 359:ir_heat.c     **** int16_t get_slope() {
 737               	sub r20,r18
 738               		sbc r21,r19
 739               		movw r18,r20
 740               		lsl r18
 741               		rol r19
 742               		add r18,r20
 743               		adc r19,r21
 744 034c A0E0      		add r24,r18
 745 034e B0E0      		adc r25,r19
 746 0350 FD01      		adiw r26,6
 747 0352 2191      		ld r20,X+
 748 0354 3191      		ld r21,X
 749 0356 8091 0000 		sbiw r26,6+1
 750 035a 9091 0000 		adiw r26,4
 751 035e 281B      		ld r18,X+
 752 0360 390B      		ld r19,X
 753 0362 C901      		sbiw r26,4+1
 754 0364 880F      		sub r20,r18
 755 0366 991F      		sbc r21,r19
 756 0368 880F      		movw r18,r20
 757 036a 991F      		lsl r18
 758 036c 820F      		rol r19
 759 036e 931F      		add r18,r20
 760 0370 1897      		adc r19,r21
 761 0372 4081      		movw r20,r18
 762 0374 5181      		lsl r20
 763 0376 2D91      		rol r21
 764 0378 3C91      		lsl r20
 765 037a 1197      		rol r21
 766 037c 421B      		add r18,r20
 767 037e 530B      		adc r19,r21
 768 0380 9A01      		add r24,r18
 769 0382 220F      		adc r25,r19
 770 0384 331F      		ldi r22,lo8(9)
 771 0386 240F      		ldi r23,hi8(9)
 772 0388 351F      		call __divmodhi4
 773 038a 820F      		mov r24,r22
 774 038c 931F      		mov r25,r23
 775 038e 1696      	/* epilogue start */
 777 0392 5C91      	.LM68:
 778 0394 1797      		ret
 780 0398 2D91      	.Lscope13:
 782 039c 1597      	.global	get_last_slope
 784 03a0 530B      	get_last_slope:
 786 03a4 220F      	.LM69:
 787 03a6 331F      	.LFBB14:
 788 03a8 240F      	/* prologue: function */
 789 03aa 351F      	/* frame size = 0 */
 791 03ae 440F      	.LM70:
 792 03b0 551F      		lds r18,t_array+10
 793 03b2 440F      		lds r19,(t_array+10)+1
 794 03b4 551F      		lds r24,t_array+8
 795 03b6 240F      		lds r25,(t_array+8)+1
 796 03b8 351F      		sub r18,r24
 797 03ba 820F      		sbc r19,r25
 799 03be 69E0      	.LM71:
 800 03c0 70E0      		mov r24,r18
 801 03c2 0E94 0000 		mov r25,r19
 802 03c6 862F      	/* epilogue start */
 803 03c8 972F      		ret
 360:ir_heat.c     **** 	int16_t s1, s2, s3;
 361:ir_heat.c     **** 
 362:ir_heat.c     **** 	s1 = t_array[5] - t_array[0];
 363:ir_heat.c     **** 	s2 = t_array[4] - t_array[1];
 364:ir_heat.c     **** 	s3 = t_array[3] - t_array[2];
 365:ir_heat.c     **** 	
 366:ir_heat.c     **** 	return ((3*s1+5*s2+15*s3)/9);
 367:ir_heat.c     **** }
 805               	:P(4,4)",64,0,0,24
 806               	.global	_beep
 808               	_beep:
 810               	.LM72:
 811               	.LFBB15:
 812               	/* prologue: function */
 813               	/* frame size = 0 */
 368:ir_heat.c     **** 
 369:ir_heat.c     **** 
 370:ir_heat.c     **** 
 371:ir_heat.c     **** //********************************************
 372:ir_heat.c     **** //
 373:ir_heat.c     **** // Gibt die aktuelle Steigung der Temperatur zurück
 374:ir_heat.c     **** // in 0.1°C in 4s
 375:ir_heat.c     **** //
 376:ir_heat.c     **** int16_t	get_last_slope() {
 814               	8,0,417,.LM73-.LFBB15
 815               	.LM73:
 816               		ldi r30,lo8(37)
 817               		ldi r31,hi8(37)
 818               		ld r18,Z
 819               		ori r18,lo8(-128)
 820               		st Z,r18
 822 03d0 3091 0000 	.LM74:
 823 03d4 8091 0000 		ldi r22,lo8(20)
 824 03d8 9091 0000 		ldi r23,hi8(20)
 825 03dc 281B      		call __udivmodhi4
 826 03de 390B      		mov r24,r22
 377:ir_heat.c     ****     return (t_array[5] - t_array[4]);
 378:ir_heat.c     **** }
 827               		sbiw r24,0
 828               		breq .L45
 829 03e0 822F      		ldi r18,lo8(0)
 830 03e2 932F      		ldi r19,hi8(0)
 831               	.LBB36:
 832 03e4 0895      	.LBB37:
 833               	.LBB38:
 834               	.LBB39:
 836               	.Ltext1:
 838               	.LM75:
 839               		ldi r20,lo8(5000)
 379:ir_heat.c     **** 
 380:ir_heat.c     **** 
 381:ir_heat.c     **** 
 382:ir_heat.c     **** //********************************************
 383:ir_heat.c     **** //
 384:ir_heat.c     **** // Liest die vom MLX90614 gemessene Temperatur aus
 385:ir_heat.c     **** // Rückgabe in 0.1°C, also 215 = 21.5°C
 386:ir_heat.c     **** //
 387:ir_heat.c     **** uint16_t get_temperature(uint8_t adr) {
 388:ir_heat.c     **** 	uint16_t raw;
 389:ir_heat.c     **** 	uint8_t 	ret;
 390:ir_heat.c     **** 	uint8_t 	lo, hi, pec;
 391:ir_heat.c     **** 	uint8_t	pec_read[6];
 392:ir_heat.c     **** 
 393:ir_heat.c     **** 	if(i2c_start(MLX90614_WRITE)) return DEFAULT_TEMP;
 394:ir_heat.c     **** 	if(i2c_write(adr)) return DEFAULT_TEMP;
 395:ir_heat.c     **** 	
 396:ir_heat.c     **** 	ret = i2c_rep_start(MLX90614_READ);
 397:ir_heat.c     **** 	if(ret) {
 398:ir_heat.c     **** 		i2c_rep_start(MLX90614_READ);
 399:ir_heat.c     ****    }
 400:ir_heat.c     **** 
 401:ir_heat.c     **** 	lo = i2c_read_ack();
 402:ir_heat.c     **** 	hi = i2c_read_ack();
 403:ir_heat.c     **** 	raw = (uint16_t)(hi<<8)+lo;
 404:ir_heat.c     **** 	pec = i2c_read_ack();
 405:ir_heat.c     **** 	
 406:ir_heat.c     **** 	i2c_stop();
 407:ir_heat.c     **** 	
 408:ir_heat.c     **** 	if(raw & 0x8000) return DEFAULT_TEMP;
 409:ir_heat.c     **** 	
 410:ir_heat.c     **** 	return (raw / 5 - 2731); 					// 1 = 0.1°C
 411:ir_heat.c     **** }
 412:ir_heat.c     **** 
 413:ir_heat.c     **** 
 414:ir_heat.c     **** 
 415:ir_heat.c     **** void _beep(uint16_t duration_ms){
 840               	5000)
 841               	.L46:
 842               		movw r30,r20
 843               	/* #APP */
 844               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 416:ir_heat.c     **** 	uint16_t i;
 417:ir_heat.c     **** 	BUZZER_ON;
 845               	biw r30,1
 846               		brne 1b
 847 03e6 E5E2      	 ;  0 "" 2
 848 03e8 F0E0      	/* #NOAPP */
 849 03ea 2081      	.LBE39:
 850 03ec 2068      	.LBE38:
 851 03ee 2083      	.LBE37:
 418:ir_heat.c     **** 	for(i=0;i<(duration_ms/20);i++) _delay_ms(20);
 852               	
 854 03f0 64E1      	.Ltext2:
 856 03f4 0E94 0000 	.LM76:
 857 03f8 862F      		subi r18,lo8(-(1))
 858 03fa 972F      		sbci r19,hi8(-(1))
 859 03fc 0097      		cp r18,r24
 860 03fe 01F0      		cpc r19,r25
 861 0400 20E0      		brlo .L46
 862 0402 30E0      	.L45:
 864               	.LM77:
 865               		ldi r30,lo8(37)
 866               		ldi r31,hi8(37)
 867               		ld r24,Z
 868               		andi r24,lo8(127)
   1:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   5:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   8:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  11:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      distribution.
  15:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  16:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  20:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  32:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  34:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  37:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  39:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \file */
  40:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \code
  42:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \endcode
  44:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  45:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  53:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  60:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  62:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  63:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  64:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #endif
  68:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  69:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  71:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     register.
  76:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  77:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     can be achieved.
  79:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  80:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
  81:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
  83:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	);
  89:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** }
  90:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  91:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  93:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     counter register pair.
  98:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  99:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****  */
 102:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
 103:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
 105:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 869               	logue start */
 871 0404 48E8      	.LM78:
 872 0406 53E1      		ret
 877 040a 3197      	.Lscope15:
 880               	.global	beep
 882               	beep:
 884               	.LM79:
 885               	.LFBB16:
 886               	/* prologue: function */
 887               	/* frame size = 0 */
 889 040e 2F5F      	.LM80:
 890 0410 3F4F      	/* #APP */
 891 0412 2817      	 ;  424 "ir_heat.c" 1
 892 0414 3907      		cli
 893 0416 00F0      	 ;  0 "" 2
 419:ir_heat.c     **** 	BUZZER_OFF;
 895               	 1
 896               		wdr
 897 0418 E5E2      	 ;  0 "" 2
 899 041c 8081      	.LM82:
 900 041e 8F77      	/* #NOAPP */
 901 0420 8083      		cpi r24,lo8(3)
 902               		breq .L53
 420:ir_heat.c     **** }
 903               	,lo8(4)
 904               		brsh .L56
 905 0422 0895      		cpi r24,lo8(1)
 906               		breq .L51
 907               		cpi r24,lo8(2)
 908               		brne .L50
 909               		rjmp .L58
 910               	.L56:
 911               		cpi r24,lo8(4)
 912               		breq .L54
 913               		cpi r24,lo8(6)
 914               		brne .L50
 915               		rjmp .L59
 421:ir_heat.c     **** 
 422:ir_heat.c     **** 
 423:ir_heat.c     **** void	beep(uint8_t type){
 916               		68,0,428,.LM83-.LFBB16
 917               	.LM83:
 918               		ldi r24,lo8(120)
 919               		ldi r25,hi8(120)
 920               		call _beep
 424:ir_heat.c     **** 	cli();
 921               	 .L50
 922               	.L53:
 924               	.LM84:
 925 0424 F894      		ldi r24,lo8(350)
 926               		ldi r25,hi8(350)
 425:ir_heat.c     **** 	wdt_reset();
 927               	_beep
 928               		rjmp .L50
 929               	.L54:
 931               	.LM85:
 426:ir_heat.c     **** 	switch(type){
 932               	r24,lo8(850)
 933               		ldi r25,hi8(850)
 934               		call _beep
 935 0428 8330      		rjmp .L50
 936 042a 01F0      	.L58:
 938 042e 00F4      	.LM86:
 939 0430 8130      		ldi r24,lo8(80)
 940 0432 01F0      		ldi r25,hi8(80)
 941 0434 8230      		call _beep
 942 0436 01F4      	.LBB40:
 943 0438 00C0      	.LBB41:
 944               	.LBB42:
 945 043a 8430      	.LBB43:
 947 043e 8630      	.Ltext3:
 949 0442 00C0      	.LM87:
 950               		ldi r24,lo8(20000)
 427:ir_heat.c     **** 	case BEEP_SHORT:
 428:ir_heat.c     **** 		_beep(120);
 951               	
 952               	/* #APP */
 953 0444 88E7      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 954 0446 90E0      		1: sbiw r24,1
 955 0448 0E94 0000 		brne 1b
 956 044c 00C0      	 ;  0 "" 2
 957               	/* #NOAPP */
 429:ir_heat.c     **** 		break;
 430:ir_heat.c     **** 	case BEEP_LONG:
 431:ir_heat.c     **** 		_beep(350);
 958               	:
 959               	.LBE42:
 960 044e 8EE5      	.LBE41:
 961 0450 91E0      	.LBE40:
 963 0456 00C0      	.Ltext4:
 432:ir_heat.c     **** 		break;
 433:ir_heat.c     **** 	case BEEP_XLONG:
 434:ir_heat.c     **** 		_beep(850);
 965               		ldi r24,lo8(80)
 966               		ldi r25,hi8(80)
 967 0458 82E5      		call _beep
 968 045a 93E0      		rjmp .L50
 969 045c 0E94 0000 	.L59:
 971               	.LM89:
 435:ir_heat.c     **** 		break;
 436:ir_heat.c     **** 	case BEEP_2SHORT:
 437:ir_heat.c     **** 		_beep(80);
 972               	4,lo8(100)
 973               		ldi r25,hi8(100)
 974 0462 80E5      		call _beep
 975 0464 90E0      	.LBB44:
 976 0466 0E94 0000 	.LBB45:
 977               	.LBB46:
 978               	.LBB47:
 980               	.Ltext5:
 982               	.LM90:
 983               		ldi r24,lo8(-20536)
 984               		ldi r25,hi8(-20536)
 985 046a 80E2      	/* #APP */
 986 046c 9EE4      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 987               		1: sbiw r24,1
 988               		brne 1b
 989 046e 0197      	 ;  0 "" 2
 990 0470 01F4      	/* #NOAPP */
 991               	.LBE47:
 992               	.LBE46:
 993               	.LBE45:
 994               	.LBE44:
 996               	.Ltext6:
 998               	.LM91:
 438:ir_heat.c     **** 		_delay_ms(80);
 439:ir_heat.c     **** 		_beep(80);
 999               	hi8(350)
 1000               		call _beep
 1001 0472 80E5      	.L50:
 1003 0476 0E94 0000 	.LM92:
 1004 047a 00C0      	/* #APP */
 1005               	 ;  446 "ir_heat.c" 1
 440:ir_heat.c     **** 		break;
 441:ir_heat.c     **** 	case BEEP_SHORT_LONG:
 442:ir_heat.c     **** 		_beep(100);
 1006               	  0 "" 2
 1007               	/* epilogue start */
 1009 047e 90E0      	.LM93:
 1010 0480 0E94 0000 	/* #NOAPP */
 1011               		ret
 1013               	.Lscope16:
 1014               		.data
 1015               	.LC0:
 1016               		.string	">>> Relais ON"
 1017               	.LC1:
 1018               		.string	">>> Relais OFF"
 1019 0484 88EC      		.text
 1022               	.global	set_relais
 1024 048a 01F4      	set_relais:
 1026               	.LM94:
 1027               	.LFBB17:
 1028               		push r17
 1029               	/* prologue: function */
 1030               	/* frame size = 0 */
 1031               		mov r17,r24
 443:ir_heat.c     **** 		_delay_ms(180);
 444:ir_heat.c     **** 		_beep(350);		
 1034               	.LM96:
 1035 048c 8EE5      		lds r24,last.2001
 1036 048e 91E0      		cp r17,r24
 1037 0490 0E94 0000 		breq .L62
 1038               		ldi r24,lo8(.LC0)
 445:ir_heat.c     **** 	}
 446:ir_heat.c     **** 	sei();	
 1039               	25,hi8(.LC0)
 1040               		call puts
 1041               	.L62:
 1043 0494 7894      	.LM97:
 1044               		ldi r30,lo8(37)
 1045               		ldi r31,hi8(37)
 447:ir_heat.c     **** }
 1046               	,Z
 1047               		ori r24,lo8(64)
 1048               		st Z,r24
 1049 0496 0895      		rjmp .L63
 1050               	.L61:
 1052               	.LM98:
 1053               		lds r24,last.2001
 1054 0000 3E3E 3E20 		tst r24
 1054      5265 6C61 
 1054      6973 204F 
 1054      4E00 
 1055               		breq .L64
 1056 000e 3E3E 3E20 		ldi r24,lo8(.LC1)
 1056      5265 6C61 
 1056      6973 204F 
 1056      4646 00
 1057               		ldi r25,hi8(.LC1)
 1058               		call puts
 1059               	.L64:
 1061               	.LM99:
 1062               		ldi r30,lo8(37)
 448:ir_heat.c     **** 
 449:ir_heat.c     **** 
 450:ir_heat.c     **** 
 451:ir_heat.c     **** //***************************************************
 452:ir_heat.c     **** //
 453:ir_heat.c     **** // Relais Ein- und Ausschalen
 454:ir_heat.c     **** //
 455:ir_heat.c     **** void set_relais(uint8_t on) {
 1063               		ld r24,Z
 1064               		andi r24,lo8(-65)
 1065               		st Z,r24
 1066 0498 1F93      	.L63:
 1068               	.LM100:
 1069 049a 182F      		sts last.2001,r17
 456:ir_heat.c     **** 	static uint8_t last = 0;
 457:ir_heat.c     **** 	if(on) {
 1070               	ogue start */
 1072 049c 8823      	.LM101:
 1073 049e 01F0      		pop r17
 458:ir_heat.c     **** 		if(on != last) printf(">>> Relais ON\n");
 1074               	
 1079 04a8 80E0      	.Lscope17:
 1080 04aa 90E0      		.data
 1081 04ac 0E94 0000 	.LC2:
 1082               		.string	"Temperature Protection Off!"
 459:ir_heat.c     **** 		RELAIS_ON;
 1083               	string	"\nxXx"
 1084               		.text
 1086 04b2 F0E0      	.global	__vector_1
 1088 04b6 8064      	__vector_1:
 1090 04ba 00C0      	.LM102:
 1091               	.LFBB18:
 460:ir_heat.c     **** 	}
 461:ir_heat.c     **** 	else {
 462:ir_heat.c     **** 		if(on != last) printf(">>> Relais OFF\n");
 1092               	ero_reg__
 1093               		push r0
 1094 04bc 8091 0000 		in r0,__SREG__
 1095 04c0 8823      		push r0
 1096 04c2 01F0      		clr __zero_reg__
 1097 04c4 80E0      		push r18
 1098 04c6 90E0      		push r19
 1099 04c8 0E94 0000 		push r20
 1100               		push r21
 463:ir_heat.c     **** 		RELAIS_OFF;
 1101               	
 1102               		push r23
 1103 04cc E5E2      		push r24
 1104 04ce F0E0      		push r25
 1105 04d0 8081      		push r26
 1106 04d2 8F7B      		push r27
 1107 04d4 8083      		push r30
 1108               		push r31
 464:ir_heat.c     **** 	}
 465:ir_heat.c     **** 	last = on;
 1109               	ogue: Signal */
 1110               	/* frame size = 0 */
 1112               	.LM103:
 466:ir_heat.c     **** }
 1113               	 r24,133
 1114               		lds r18,132
 1115 04da 1F91      		lds r25,running.1757
 1116 04dc 0895      		or r24,r25
 1117               		or r24,r18
 1118               		breq .+2
 1119               		rjmp .L77
 1121               	.LM104:
 1122               		ldi r24,lo8(1)
 1123               		sts running.1757,r24
 1125               	.LM105:
 1126 0039 0A78 5878 	/* #APP */
 1126      00
 1127               	 ;  164 "ir_heat.c" 1
 1128               		wdr
 1129               	 ;  0 "" 2
 1131               	.LM106:
 1132               	/* #NOAPP */
 1133               		out 61-32,__zero_reg__
 1135 04de 1F92      	.LM107:
 1136 04e0 0F92      	/* #APP */
 1137 04e2 0FB6      	 ;  169 "ir_heat.c" 1
 1138 04e4 0F92      		sei
 1139 04e6 1124      	 ;  0 "" 2
 1140 04e8 2F93      	/* #NOAPP */
 1141 04ea 3F93      		ldi r18,lo8(0)
 1142 04ec 4F93      		ldi r19,hi8(0)
 1143 04ee 5F93      		ldi r20,lo8(0)
 1144 04f0 6F93      		ldi r21,hi8(0)
 1146 04f4 8F93      	.LM108:
 1147 04f6 9F93      		ldi r30,lo8(41)
 1148 04f8 AF93      		ldi r31,hi8(41)
 1149 04fa BF93      	.L69:
 1150 04fc EF93      		ld r24,Z
 1151 04fe FF93      		sbrs r24,2
 1152               		rjmp .L68
 1153               		subi r20,lo8(-(1))
 1154               		sbci r21,hi8(-(1))
 1155               	.L68:
 1156 0500 8091 8500 		subi r18,lo8(-(1))
 1157 0504 2091 8400 		sbci r19,hi8(-(1))
 1158 0508 9091 0000 		ldi r24,hi8(1000)
 1159 050c 892B      		cpi r18,lo8(1000)
 1160 050e 822B      		cpc r19,r24
 1161 0510 01F0      		brne .L69
 1163               	.LM109:
 1164               		cpi r20,200
 1165 0514 81E0      		cpc r21,__zero_reg__
 1166 0516 8093 0000 		brlo .+2
 1167               		rjmp .L70
 1169               	.LM110:
 1170               		ldi r24,lo8(1)
 1171 051a A895      		sts 132,r24
 1173               	.LM111:
 1174               		ldi r24,lo8(2)
 1175               		sts 129,r24
 1177               	.LM112:
 1178               		lds r24,mode
 1179               		tst r24
 1180               		breq .+2
 1181 051e 7894      		rjmp .L80
 1183               	.LM113:
 1184 0520 20E0      		ldi r24,lo8(1)
 1185 0522 30E0      		sts mode,r24
 1187 0526 50E0      	.LM114:
 1188               		call set_relais
 1190 0528 E9E2      	.LM115:
 1191 052a F0E0      		ldi r30,lo8(43)
 1192               		ldi r31,hi8(43)
 1193 052c 8081      		ld r24,Z
 1194 052e 82FF      		ori r24,lo8(16)
 1195 0530 00C0      		st Z,r24
 1197 0534 5F4F      	.LM116:
 1198               		ld r24,Z
 1199 0536 2F5F      		ori r24,lo8(8)
 1200 0538 3F4F      		st Z,r24
 1202 053c 283E      	.LM117:
 1203 053e 3807      		sbic 41-32,2
 1204 0540 01F4      		rjmp .L73
 1205               		ldi r18,lo8(0)
 1206               		ldi r19,hi8(0)
 1207 0542 483C      	.LBB48:
 1208 0544 5105      	.LBB49:
 1209 0546 00F0      	.LBB50:
 1210 0548 00C0      	.LBB51:
 1212               	.Ltext7:
 1214 054c 8093 8400 	.LM118:
 1215               		ldi r20,lo8(2500)
 1216               		ldi r21,hi8(2500)
 1217 0550 82E0      	.LBE51:
 1218 0552 8093 8100 	.LBE50:
 1219               	.LBE49:
 1220               	.LBE48:
 1222 055a 8823      	.Ltext8:
 1224 055e 00C0      	.LM119:
 1225               		ldi r30,lo8(41)
 1226               		ldi r31,hi8(41)
 1227 0560 81E0      	.L75:
 1229               	.LM120:
 1230               		subi r18,lo8(-(1))
 1231 0566 0E94 0000 		sbci r19,hi8(-(1))
 1232               	.LBB55:
 1233               	.LBB54:
 1234 056a EBE2      	.LBB53:
 1235 056c F0E0      	.LBB52:
 1237 0570 8061      	.Ltext9:
 1239               	.LM121:
 1240               		movw r24,r20
 1241 0574 8081      	/* #APP */
 1242 0576 8860      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1243 0578 8083      		1: sbiw r24,1
 1244               		brne 1b
 1245               	 ;  0 "" 2
 1246 057a 4A99      	/* #NOAPP */
 1247 057c 00C0      	.LBE52:
 1248 057e 20E0      	.LBE53:
 1249 0580 30E0      	.LBE54:
 1250               	.LBE55:
 1252               	.Ltext10:
 1254               	.LM122:
 1255               		ld r24,Z
 1256               		sbrc r24,2
 1257               		rjmp .L74
 1258 0582 44EC      		ldi r24,hi8(300)
 1259 0584 59E0      		cpi r18,lo8(300)
 1260               		cpc r19,r24
 1261               		brne .L75
 1262               		rjmp .L76
 1263               	.L74:
 1265               	.LM123:
 1266               		subi r18,lo8(300)
 1267               		sbci r19,hi8(300)
 1268 0586 E9E2      		brsh .L76
 1269 0588 F0E0      	.L73:
 1271               	.LM124:
 1272               		ldi r24,lo8(1)
 1273 058a 2F5F      		sts mode,r24
 1274 058c 3F4F      		rjmp .L70
 1275               	.L76:
 1277               	.LM125:
 1278               		ldi r24,lo8(2)
 1279               		sts mode,r24
 1281               	.LM126:
 1282               		ldi r24,lo8(.LC2)
 1283 058e CA01      		ldi r25,hi8(.LC2)
 1284               		call puts
 1286 0590 0197      	.LM127:
 1287 0592 01F4      		ldi r30,lo8(43)
 1288               		ldi r31,hi8(43)
 1289               		ld r24,Z
 1290               		andi r24,lo8(-17)
 1291               		st Z,r24
 1293               	.LM128:
 1294               		ld r24,Z
 1295               		ori r24,lo8(8)
 1296               		st Z,r24
 1298 0594 8081      	.LM129:
 1299 0596 82FD      		ldi r24,lo8(6)
 1300 0598 00C0      		call beep
 1301 059a 81E0      		rjmp .L70
 1302 059c 2C32      	.L80:
 1304 05a0 01F4      	.LM130:
 1305 05a2 00C0      		ldi r24,lo8(.LC3)
 1306               		ldi r25,hi8(.LC3)
 1307               		call puts
 1309 05a4 2C52      	.LM131:
 1310 05a6 3140      		sts mode,__zero_reg__
 1311 05a8 00F4      	.L70:
 1313               	.LM132:
 1314               		ldi r24,lo8(1)
 1315 05aa 81E0      		out 60-32,r24
 1317 05b0 00C0      	.LM133:
 1318               		out 61-32,r24
 1320               	.LM134:
 1321 05b2 82E0      		sts running.1757,__zero_reg__
 1322 05b4 8093 0000 	.L77:
 1323               	/* epilogue start */
 1325 05b8 80E0      	.LM135:
 1326 05ba 90E0      		pop r31
 1327 05bc 0E94 0000 		pop r30
 1328               		pop r27
 1329               		pop r26
 1330 05c0 EBE2      		pop r25
 1331 05c2 F0E0      		pop r24
 1332 05c4 8081      		pop r23
 1333 05c6 8F7E      		pop r22
 1334 05c8 8083      		pop r21
 1335               		pop r20
 1336               		pop r19
 1337 05ca 8081      		pop r18
 1338 05cc 8860      		pop r0
 1339 05ce 8083      		out __SREG__,r0
 1340               		pop r0
 1341               		pop __zero_reg__
 1342 05d0 86E0      		reti
 1349 05da 90E0      	.Lscope18:
 1352               	.global	get_temperature
 1354               	get_temperature:
 1356               	.LM136:
 1357 05e4 81E0      	.LFBB19:
 1358 05e6 8CBB      		push r17
 1359               		push r28
 1360               		push r29
 1361 05e8 8DBB      	/* prologue: function */
 1362               	/* frame size = 0 */
 1363               		mov r17,r24
 1365               	.LM137:
 1366               		ldi r24,lo8(-76)
 1367               		call i2c_start
 1368               		tst r24
 1369 05ee FF91      		brne .L82
 1371 05f2 BF91      	.LM138:
 1372 05f4 AF91      		mov r24,r17
 1373 05f6 9F91      		call i2c_write
 1374 05f8 8F91      		tst r24
 1375 05fa 7F91      		brne .L82
 1377 05fe 5F91      	.LM139:
 1378 0600 4F91      		ldi r24,lo8(-75)
 1379 0602 3F91      		call i2c_rep_start
 1381 0606 0F90      	.LM140:
 1382 0608 0FBE      		tst r24
 1383 060a 0F90      		breq .L83
 1385 060e 1895      	.LM141:
 1386               		ldi r24,lo8(-75)
 1387               		call i2c_rep_start
 1388               	.L83:
 1390               	.LM142:
 1391               		call i2c_read_ack
 1392               		mov r17,r24
 1394               	.LM143:
 1395               		call i2c_read_ack
 1397               	.LM144:
 1398               		mov r19,r24
 1399               		ldi r18,lo8(0)
 1400               		movw r28,r18
 1401 0610 1F93      		add r28,r17
 1402 0612 CF93      		adc r29,__zero_reg__
 1404               	.LM145:
 1405               		call i2c_read_ack
 1407               	.LM146:
 1408               		call i2c_stop
 1410 061a 0E94 0000 	.LM147:
 1411 061e 8823      		tst r29
 1412 0620 01F4      		brlt .L82
 1414               	.LM148:
 1415 0622 812F      		movw r24,r28
 1416 0624 0E94 0000 		ldi r22,lo8(5)
 1417 0628 8823      		ldi r23,hi8(5)
 1418 062a 01F4      		call __udivmodhi4
 1419               		subi r22,lo8(-(-2731))
 1420               		sbci r23,hi8(-(-2731))
 1421 062c 85EB      		rjmp .L84
 1422 062e 0E94 0000 	.L82:
 1423               		ldi r22,lo8(150)
 1424               		ldi r23,hi8(150)
 1425 0632 8823      	.L84:
 1427               	.LM149:
 1428               		mov r24,r22
 1429 0636 85EB      		mov r25,r23
 1430 0638 0E94 0000 	/* epilogue start */
 1431               		pop r29
 1432               		pop r28
 1433               		pop r17
 1434 063c 0E94 0000 		ret
 1440               	.Lscope19:
 1441 0646 382F      		.data
 1442 0648 20E0      	.LC4:
 1443 064a E901      		.string	"Array:"
 1444 064c C10F      	.LC5:
 1445 064e D11D      		.string	" %i"
 1446               		.text
 1448 0650 0E94 0000 	.global	print_array
 1450               	print_array:
 1452               	.LM150:
 1453               	.LFBB20:
 1454 0658 DD23      		push r12
 1455 065a 04F0      		push r13
 1456               		push r14
 1457               		push r15
 1458 065c CE01      		push r16
 1459 065e 65E0      		push r17
 1460 0660 70E0      	/* prologue: function */
 1461 0662 0E94 0000 	/* frame size = 0 */
 1463 0668 7A40      	.LM151:
 1464 066a 00C0      		rcall .
 1465               		ldi r24,lo8(.LC4)
 1466 066c 66E9      		ldi r25,hi8(.LC4)
 1467 066e 70E0      		in r26,__SP_L__
 1468               		in r27,__SP_H__
 1469               		adiw r26,1+1
 1470               		st X,r25
 1471 0670 862F      		st -X,r24
 1472 0672 972F      		sbiw r26,1
 1473               		call printf
 1475 0676 CF91      	.LM152:
 1476 0678 1F91      		rcall .
 1477 067a 0895      		in r30,__SP_L__
 1478               		in r31,__SP_H__
 1479               		adiw r30,1
 1480               		mov __tmp_reg__,r31
 1481               		ldi r31,lo8(.LC5)
 1482               		mov r14,r31
 1483               		ldi r31,hi8(.LC5)
 1484               		mov r15,r31
 1485               		mov r31,__tmp_reg__
 1486 003e 4172 7261 		std Z+1,r15
 1486      793A 00
 1487               		st Z,r14
 1488 0045 2025 6900 		mov __tmp_reg__,r31
 1489               		ldi r31,lo8(t_array)
 1490               		mov r12,r31
 1491               		ldi r31,hi8(t_array)
 1492               		mov r13,r31
 1493               		mov r31,__tmp_reg__
 1494               		movw r26,r12
 1495               		ld r24,X+
 1496               		ld r25,X+
 1497 067c CF92      		movw r16,r26
 1498 067e DF92      		std Z+3,r25
 1499 0680 EF92      		std Z+2,r24
 1500 0682 FF92      		call printf
 1501 0684 0F93      		in r30,__SP_L__
 1502 0686 1F93      		in r31,__SP_H__
 1503               		adiw r30,1
 1504               		std Z+1,r15
 1505               		st Z,r14
 1506               		movw r26,r16
 1507 0688 00D0      		ld r24,X+
 1508 068a 80E0      		ld r25,X
 1509 068c 90E0      		std Z+3,r25
 1510 068e ADB7      		std Z+2,r24
 1511 0690 BEB7      		call printf
 1512 0692 1296      		in r30,__SP_L__
 1513 0694 9C93      		in r31,__SP_H__
 1514 0696 8E93      		adiw r30,1
 1515 0698 1197      		std Z+1,r15
 1516 069a 0E94 0000 		st Z,r14
 1517               		movw r26,r12
 1518               		adiw r26,4
 1519 069e 00D0      		ld r24,X+
 1520 06a0 EDB7      		ld r25,X
 1521 06a2 FEB7      		sbiw r26,4+1
 1522 06a4 3196      		std Z+3,r25
 1523 06a6 0F2E      		std Z+2,r24
 1524 06a8 F0E0      		call printf
 1525 06aa EF2E      		in r30,__SP_L__
 1526 06ac F0E0      		in r31,__SP_H__
 1527 06ae FF2E      		adiw r30,1
 1528 06b0 F02D      		std Z+1,r15
 1529 06b2 F182      		st Z,r14
 1530 06b4 E082      		movw r26,r12
 1531 06b6 0F2E      		adiw r26,6
 1532 06b8 F0E0      		ld r24,X+
 1533 06ba CF2E      		ld r25,X
 1534 06bc F0E0      		sbiw r26,6+1
 1535 06be DF2E      		std Z+3,r25
 1536 06c0 F02D      		std Z+2,r24
 1537 06c2 D601      		call printf
 1538 06c4 8D91      		in r30,__SP_L__
 1539 06c6 9D91      		in r31,__SP_H__
 1540 06c8 8D01      		adiw r30,1
 1541 06ca 9383      		std Z+1,r15
 1542 06cc 8283      		st Z,r14
 1543 06ce 0E94 0000 		movw r26,r12
 1544 06d2 EDB7      		adiw r26,8
 1545 06d4 FEB7      		ld r24,X+
 1546 06d6 3196      		ld r25,X
 1547 06d8 F182      		sbiw r26,8+1
 1548 06da E082      		std Z+3,r25
 1549 06dc D801      		std Z+2,r24
 1550 06de 8D91      		call printf
 1551 06e0 9C91      		in r30,__SP_L__
 1552 06e2 9383      		in r31,__SP_H__
 1553 06e4 8283      		adiw r30,1
 1554 06e6 0E94 0000 		std Z+1,r15
 1555 06ea EDB7      		st Z,r14
 1556 06ec FEB7      		movw r26,r12
 1557 06ee 3196      		adiw r26,10
 1558 06f0 F182      		ld r24,X+
 1559 06f2 E082      		ld r25,X
 1560 06f4 D601      		sbiw r26,10+1
 1561 06f6 1496      		std Z+3,r25
 1562 06f8 8D91      		std Z+2,r24
 1563 06fa 9C91      		call printf
 1565 06fe 9383      	.LM153:
 1566 0700 8283      		pop __tmp_reg__
 1567 0702 0E94 0000 		pop __tmp_reg__
 1568 0706 EDB7      		pop __tmp_reg__
 1569 0708 FEB7      		pop __tmp_reg__
 1570 070a 3196      		ldi r24,lo8(10)
 1571 070c F182      		ldi r25,hi8(10)
 1572 070e E082      		call putchar
 1573 0710 D601      	/* epilogue start */
 1575 0714 8D91      	.LM154:
 1576 0716 9C91      		pop r17
 1577 0718 1797      		pop r16
 1578 071a 9383      		pop r15
 1579 071c 8283      		pop r14
 1580 071e 0E94 0000 		pop r13
 1581 0722 EDB7      		pop r12
 1582 0724 FEB7      		ret
 1584 0728 F182      	.Lscope20:
 1586 072c D601      	.global	UART_first_init
 1588 0730 8D91      	UART_first_init:
 1590 0734 1997      	.LM155:
 1591 0736 9383      	.LFBB21:
 1592 0738 8283      	/* prologue: function */
 1593 073a 0E94 0000 	/* frame size = 0 */
 1595 0740 FEB7      	.LM156:
 1596 0742 3196      		ldi r24,lo8(12)
 1597 0744 F182      		ldi r25,hi8(12)
 1598 0746 E082      		sts (196)+1,r25
 1599 0748 D601      		sts 196,r24
 1601 074c 8D91      	.LM157:
 1602 074e 9C91      		ldi r24,lo8(-104)
 1603 0750 1B97      		sts 193,r24
 1605 0754 8283      	.LM158:
 1606 0756 0E94 0000 		ldi r24,lo8(6)
 1607               		sts 194,r24
 1609 075a 0F90      	.LM159:
 1610 075c 0F90      		ldi r24,lo8(gs(UART_putchar))
 1611 075e 0F90      		ldi r25,hi8(gs(UART_putchar))
 1612 0760 0F90      		ldi r22,lo8(gs(UART_getchar))
 1613 0762 8AE0      		ldi r23,hi8(gs(UART_getchar))
 1614 0764 90E0      		call fdevopen
 1616               	.LM160:
 1617               	/* #APP */
 1618               	 ;  295 "ir_heat.c" 1
 1619 076a 1F91      		sei
 1620 076c 0F91      	 ;  0 "" 2
 1621 076e FF90      	/* epilogue start */
 1623 0772 DF90      	.LM161:
 1624 0774 CF90      	/* #NOAPP */
 1625 0776 0895      		ret
 1627               	.Lscope21:
 1628               		.data
 1629               	.LC6:
 1630               		.string	"\n\nStart\n"
 1631               	.LC7:
 1632               		.string	"Error Temp=0"
 1633               	.LC8:
 1634               		.string	"Startup %i "
 1635               	.LC9:
 1636               		.string	"Temp: %i, "
 1637               	.LC10:
 1638               		.string	"exp_s: %i, s2: %i, s: %i\n"
 1639 0778 8CE0      	.LC11:
 1640 077a 90E0      		.string	"On-Counter: %i; \n"
 1641 077c 9093 C500 	.LC12:
 1642 0780 8093 C400 		.string	"Off-Counter: %i; \n"
 1643               		.text
 1645 0784 88E9      	.global	main
 1647               	main:
 1649 078a 86E0      	.LM162:
 1650 078c 8093 C200 	.LFBB22:
 1651               		push r2
 1652               		push r3
 1653 0790 80E0      		push r4
 1654 0792 90E0      		push r5
 1655 0794 60E0      		push r6
 1656 0796 70E0      		push r7
 1657 0798 0E94 0000 		push r8
 1658               		push r9
 1659               		push r10
 1660               		push r11
 1661               		push r12
 1662 079c 7894      		push r13
 1663               		push r14
 1664               		push r15
 1665               		push r16
 1666               		push r17
 1667               		push r28
 1668 079e 0895      		push r29
 1669               	/* prologue: function */
 1670               	/* frame size = 0 */
 1672               	.LM163:
 1673 0049 0A0A 5374 		ldi r24,lo8(-64)
 1673      6172 740A 
 1673      00
 1674               		out 36-32,r24
 1676               	.LM164:
 1677 005f 5374 6172 		ldi r24,lo8(8)
 1677      7475 7020 
 1677      2569 2000 
 1678               		out 39-32,r24
 1680               	.LM165:
 1681 0076 6578 705F 		ldi r24,lo8(24)
 1681      733A 2025 
 1681      692C 2073 
 1681      323A 2025 
 1681      692C 2073 
 1682               		out 42-32,r24
 1684               	.LM166:
 1685 00a2 4F66 662D 		ldi r24,lo8(63)
 1685      436F 756E 
 1685      7465 723A 
 1685      2025 693B 
 1685      200A 00
 1686               		out 37-32,r24
 1688               	.LM167:
 1689               		ldi r24,lo8(-9)
 1690               		out 40-32,r24
 467:ir_heat.c     **** 
 468:ir_heat.c     **** 
 469:ir_heat.c     **** 
 470:ir_heat.c     **** 
 471:ir_heat.c     **** // ***********************************************************
 472:ir_heat.c     **** // Main program
 473:ir_heat.c     **** //
 474:ir_heat.c     **** int main(void) {
 1691               	 r24,lo8(-25)
 1692               		movw r30,r16
 1693               		st Z,r24
 1695 07a2 3F92      	.LM169:
 1696 07a4 4F92      		lds r24,100
 1698 07a8 6F92      	.LM170:
 1699 07aa 7F92      	/* #APP */
 1700 07ac 8F92      	 ;  489 "ir_heat.c" 1
 1701 07ae 9F92      		wdr
 1702 07b0 AF92      	 ;  0 "" 2
 1704 07b4 CF92      	.LM171:
 1705 07b6 DF92      	/* #NOAPP */
 1706 07b8 EF92      		ldi r18,lo8(41)
 1707 07ba FF92      		ldi r24,lo8(24)
 1708 07bc 0F93      		ldi r25,hi8(24)
 1709 07be 1F93      	/* #APP */
 1710 07c0 CF93      	 ;  490 "ir_heat.c" 1
 1711 07c2 DF93      		in __tmp_reg__,__SREG__
 1712               		cli
 1713               		wdr
 475:ir_heat.c     ****    // Ausgänge definieren
 476:ir_heat.c     **** 	DDRB = 0x00 | (1<<RELAIS) | (1<<BUZZER);
 1714               	__,__tmp_reg__
 1715               		sts 96,r18
 1716 07c4 80EC      		
 1717 07c6 84B9      	 ;  0 "" 2
 477:ir_heat.c     **** 	DDRC = 0x00 | (1<<FLASH_LED);
 1718               	abn	68,0,493,.LM172-.LFBB22
 1719               	.LM172:
 1720 07c8 88E0      	/* #NOAPP */
 1721 07ca 87B9      		call UART_first_init
 478:ir_heat.c     **** 	DDRD = 0x00 | (1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED);
 1722               	abn	68,0,494,.LM173-.LFBB22
 1723               	.LM173:
 1724 07cc 88E1      		call i2c_init
 479:ir_heat.c     **** 
 480:ir_heat.c     **** 	// Ausgänge ausschalten
 481:ir_heat.c     **** 	PORTB = ~((1<<RELAIS) | (1<<BUZZER));
 1726               	74:
 1727               		sts interval,__zero_reg__
 1729 07d2 85B9      	.LM175:
 482:ir_heat.c     **** 	PORTC = ~(1<<FLASH_LED);
 1730               	 r24,lo8(7)
 1731               		sts 177,r24
 1733 07d6 88B9      	.LM176:
 483:ir_heat.c     **** 	PORTD = ~((1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED));
 1734               	 r25,lo8(1)
 1735               		sts 112,r25
 1737 07da 10E0      	.LM177:
 1738 07dc 87EE      		out 68-32,__zero_reg__
 1740 07e0 8083      	.LM178:
 484:ir_heat.c     **** 
 485:ir_heat.c     **** 	// TWI aus Energiesparmode rausnehmen
 486:ir_heat.c     **** 	PRR != ~(1<<PRTWI);
 1741               	4,lo8(3)
 1742               		out 69-32,r24
 487:ir_heat.c     **** 
 488:ir_heat.c     **** 	// Whatchdog initialisieren
 489:ir_heat.c     **** 	wdt_reset();
 1744               	179:
 1745               		sts 110,r25
 1747               	.LM180:
 1748 07e6 A895      		sts 128,__zero_reg__
 490:ir_heat.c     **** 	wdt_enable(WDTO_8S);
 1750               	:
 1751               		sts 129,__zero_reg__
 1753 07e8 29E2      	.LM182:
 1754 07ea 88E1      		sts 130,__zero_reg__
 1756               	.LM183:
 1757               		sts 111,r25
 1759 07f0 F894      	.LM184:
 1760 07f2 A895      		ldi r24,lo8(2)
 1761 07f4 8093 6000 		sts 105,r24
 1763 07fa 2093 6000 	.LM185:
 1764               		out 61-32,r25
 491:ir_heat.c     **** 	
 492:ir_heat.c     **** 	// UART initialisieren
 493:ir_heat.c     **** 	UART_first_init();
 1766               	,lo8(.LC6)
 1767               		ldi r25,hi8(.LC6)
 1768               		call puts
 494:ir_heat.c     **** 	i2c_init();
 1770               	87:
 1771               		movw r30,r16
 1772 0802 0E94 0000 		ld r24,Z
 495:ir_heat.c     **** 	
 496:ir_heat.c     **** 	interval=0;
 1773               	i r24,lo8(16)
 1774               		st Z,r24
 497:ir_heat.c     **** 	
 498:ir_heat.c     **** 	// Timer 2 initialisieren (RTC)
 499:ir_heat.c     ****    TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);	// clk/256
 1776               	188:
 1777               		ld r24,Z
 1778 080a 87E0      		andi r24,lo8(-9)
 1779 080c 8093 B100 		st Z,r24
 500:ir_heat.c     ****    TIMSK2 = (1<<TOIE2);
 1780               	abn	68,0,521,.LM189-.LFBB22
 1781               	.LM189:
 1782 0810 91E0      		ldi r24,lo8(0)
 1783 0812 9093 7000 		call set_relais
 501:ir_heat.c     **** 
 502:ir_heat.c     ****  	// Timer 0 initialisieren (Blinken)
 503:ir_heat.c     **** 	TCCR0A = 0;
 1784               	abn	68,0,522,.LM190-.LFBB22
 1785               	.LM190:
 1786 0816 14BC      		sts mode,__zero_reg__
 504:ir_heat.c     **** 	TCCR0B = (0<<CS02) | (1<<CS01) | (1<<CS00);
 1787               	tabn	68,0,541,.LM191-.LFBB22
 1788               	.LM191:
 1789 0818 83E0      	/* #APP */
 1790 081a 85BD      	 ;  541 "ir_heat.c" 1
 505:ir_heat.c     **** 	TIMSK0 = (1<<TOIE0);
 1791               	
 1792               	 ;  0 "" 2
 1793 081c 9093 6E00 	/* #NOAPP */
 506:ir_heat.c     **** 	
 507:ir_heat.c     **** 	// Timer 1 initialisieren (Entprellen?)
 508:ir_heat.c     **** 	TCCR1A = 0;
 1794               	di r28,lo8(0)
 1795               		ldi r29,hi8(0)
 1796 0820 1092 8000 		ldi r16,lo8(0)
 509:ir_heat.c     **** 	TIMER1_STOP;
 1797               	r r3
 1798               		dec r3
 1799 0824 1092 8100 		mov __tmp_reg__,r31
 510:ir_heat.c     **** 	TCCR1C = 0;
 1800               	i r31,lo8(3)
 1801               		mov r8,r31
 1802 0828 1092 8200 		mov r31,__tmp_reg__
 511:ir_heat.c     **** 	TIMSK1 = (1<<TOIE1);
 1803               	r r9
 1805 082c 9093 6F00 	.LM192:
 512:ir_heat.c     **** 	
 513:ir_heat.c     **** 	// Interrupt für Taster initialisieren
 514:ir_heat.c     **** 	EICRA = (1<<ISC01);
 1806               	v __tmp_reg__,r31
 1807               		ldi r31,lo8(43)
 1808 0830 82E0      		mov r12,r31
 1809 0832 8093 6900 		clr r13
 515:ir_heat.c     **** 	EIMSK = (1<<INT0);
 1810               	 r31,__tmp_reg__
 1812 0836 9DBB      	.LM193:
 516:ir_heat.c     **** 	
 517:ir_heat.c     **** 
 518:ir_heat.c     **** 	printf("\n\nStart\n\n");
 1813               	r r4
 1814               		clr r5
 1816 083a 90E0      	.LM194:
 1817 083c 0E94 0000 		mov __tmp_reg__,r31
 519:ir_heat.c     **** 	STATUS_LED1_ON;		// grüne LED ein
 1818               	r31,lo8(3)
 1819               		mov r2,r31
 1820 0840 F801      		mov r31,__tmp_reg__
 1821 0842 8081      	.LBB56:
 1822 0844 8061      	.LBB57:
 1823 0846 8083      	.LBB58:
 520:ir_heat.c     **** 	STATUS_LED2_OFF;		// rote LED aus
 1824               	:
 1826 0848 8081      	.Ltext11:
 1828 084c 8083      	.LM195:
 521:ir_heat.c     **** 	set_relais(0);			// Relais aus
 1829               	__tmp_reg__,r31
 1830               		ldi r31,lo8(25000)
 1831 084e 80E0      		mov r6,r31
 1832 0850 0E94 0000 		ldi r31,hi8(25000)
 522:ir_heat.c     **** 	mode = MODE_OFF;
 1833               	 r7,r31
 1834               		mov r31,__tmp_reg__
 1835 0854 1092 0000 	.L109:
 523:ir_heat.c     **** 	
 524:ir_heat.c     **** //	int16_t temp, temp_sum, temp_a;
 525:ir_heat.c     **** //	int16_t	lookahead;
 526:ir_heat.c     **** //	int16_t 	slope, max_slope;
 527:ir_heat.c     **** //	int16_t	slope_raw;
 528:ir_heat.c     **** 	int16_t 	temp, temp_sum = 0;
 529:ir_heat.c     **** 	int16_t	slope_raw, slope = 0, temp_a, max_slope;
 530:ir_heat.c     **** 	uint8_t	count=0;
 531:ir_heat.c     **** 	uint8_t  last_interval = 0xff;
 532:ir_heat.c     **** 	uint8_t	startup = 3;
 533:ir_heat.c     **** 	uint8_t	on_counter = 0;
 534:ir_heat.c     **** 	int16_t	factor;
 535:ir_heat.c     **** 	int16_t	integral = 0;
 536:ir_heat.c     **** 	
 537:ir_heat.c     **** 	int16_t	slope_std = 0;
 538:ir_heat.c     **** 	int16_t	slope_real = 0;
 539:ir_heat.c     **** 		
 540:ir_heat.c     **** 	// Interrupts aktivieren
 541:ir_heat.c     **** 	sei();
 1836               	E59:
 1837               	.LBE58:
 1838               	.LBE57:
 1839               	.LBE56:
 1841               	.Ltext12:
 1843 085a C0E0      	.LM196:
 1844 085c D0E0      		lds r20,interval
 1845 085e 00E0      		cpi r20,lo8(16)
 1846 0860 3324      		brge .+2
 1847 0862 3A94      		rjmp .L91
 1849 0866 F3E0      	.LM197:
 1850 0868 8F2E      	/* #APP */
 1851 086a F02D      	 ;  545 "ir_heat.c" 1
 1852 086c 9924      		wdr
 542:ir_heat.c     **** 
 543:ir_heat.c     ****    while(1) {
 544:ir_heat.c     ****    	if(!(interval < 16)) { 					// Alle 16x (alle 4 Sekunden) Temperatur checken
 545:ir_heat.c     ****    		wdt_reset();                  	// Whatchdog zurücksetzen
 546:ir_heat.c     **** 
 547:ir_heat.c     **** 			temp = temp_sum / count;				// Mittelwert der 16 Messungen ermitteln
 548:ir_heat.c     **** 
 549:ir_heat.c     ****    		interval=0;
 550:ir_heat.c     ****    		count=0;
 551:ir_heat.c     **** 			temp_sum = 0;
 552:ir_heat.c     **** 	      //printf("Temp: %i\n", temp);
 553:ir_heat.c     **** 	      if(temp==0) {
 554:ir_heat.c     **** 	      	// error!
 555:ir_heat.c     **** 	      	printf("Error Temp=0");
 556:ir_heat.c     **** 	      }
 557:ir_heat.c     **** 	      else {
 558:ir_heat.c     **** 				if (startup>0) {
 559:ir_heat.c     **** 					// wird nur beim ersten Durchlauf, direkt nach Startup ausgeführt
 560:ir_heat.c     **** 					printf("Startup %i ", startup);
 561:ir_heat.c     **** 					startup--;
 562:ir_heat.c     **** 					temp = get_temperature(ADR_T_OBJ1);
 563:ir_heat.c     **** 					slope = 0;
 564:ir_heat.c     **** 				}
 565:ir_heat.c     ****    	   	printf("Temp: %i, ", temp);
 566:ir_heat.c     ****    	   	add_value(temp);									// Neue Temperatur zu Array hinzufügen
 567:ir_heat.c     ****    	   	slope_raw = get_slope();						// Aktuelle Steigung ermitteln
 568:ir_heat.c     ****    	   	if (slope_raw < -100) slope_raw = -100;
 569:ir_heat.c     ****    	   	
 570:ir_heat.c     ****    	   	factor = (temp - 620) / -25;					// Fakort ermitteln
 571:ir_heat.c     ****    	   	temp_a = get_temperature(ADR_T_A);
 572:ir_heat.c     ****    	   	//factor = (temp - 900 + 2*temp_a ) / -25;					// Fakort ermitteln
 573:ir_heat.c     ****    	   	if(factor < 0) factor = 0;
 574:ir_heat.c     ****    	   	   	   	
 575:ir_heat.c     **** 				if(slope_raw > factor) { 						// "Steigungsintegral"
 576:ir_heat.c     **** 					integral = 8*(integral + slope_raw) / factor;
 577:ir_heat.c     **** 					if(integral > 2000) integral = 2000;
 578:ir_heat.c     **** 				}
 579:ir_heat.c     **** 				else {
 580:ir_heat.c     **** 					integral = integral / 4;
 581:ir_heat.c     **** 				}
 582:ir_heat.c     **** 				
 583:ir_heat.c     **** //				slope = (31*slope + 10*slope_raw)/32; 		// Steigung dämpfen
 584:ir_heat.c     **** 
 585:ir_heat.c     **** 				
 586:ir_heat.c     **** 				if(slope_raw < -10) slope_raw = -10;
 587:ir_heat.c     **** 				if(slope_raw<0) {									// Fallende Temperaturen werden stärker gewichtet
 588:ir_heat.c     **** 	   	   	slope = (3*slope + 10*slope_raw)/4;		// Negative Steigung wird mit einer Dämpfung von 8 ge
 589:ir_heat.c     **** 				}
 590:ir_heat.c     **** 				else {
 591:ir_heat.c     **** 	   	   	slope = (31*slope + 10*slope_raw)/32;	// Positive Steigung wird mit einer Dämpfung von 16 
 592:ir_heat.c     **** 	   	   }
 593:ir_heat.c     **** 	   	
 594:ir_heat.c     **** 	   		slope_std = exp_slope(temp);
 595:ir_heat.c     **** 	   		slope_real = get_slope2();
 596:ir_heat.c     **** 	   	
 597:ir_heat.c     **** /*
 598:ir_heat.c     ****    	   	printf("slope_raw: %i, slope: %i ", slope_raw, slope);
 599:ir_heat.c     ****      	   	printf("Ambient: %i\n", get_temperature(ADR_T_A));
 600:ir_heat.c     **** */				
 601:ir_heat.c     **** 
 602:ir_heat.c     **** 				// temp_a 150 -> 45
 603:ir_heat.c     **** 				// temp_a 100 -> 60
 604:ir_heat.c     **** //   	   	max_slope = temp_a * -1.3 + 240;
 605:ir_heat.c     **** //   	   	max_slope = max_slope * (600-temp)/50;
 606:ir_heat.c     **** 				max_slope = (float)temp * -0.8 + 360;
 607:ir_heat.c     **** 
 608:ir_heat.c     **** //   	   	printf("sl_raw: %i, sl: %i, s_max: %i, f: %i, int: %i t_a: %i\n", slope_raw, slope, max_s
 609:ir_heat.c     ****    	   	printf("exp_s: %i, s2: %i, s: %i\n", slope_std, slope_real, get_slope());
 610:ir_heat.c     **** 
 611:ir_heat.c     **** //				if((slope > max_slope) || (integral > 500)) {
 612:ir_heat.c     **** 				if(slope_real > slope_std) {
 613:ir_heat.c     **** 					on_counter++;
 614:ir_heat.c     **** 		   		printf("On-Counter: %i; \n", on_counter);
 615:ir_heat.c     **** 	   			if(mode == MODE_ON_NO_PROT){
 616:ir_heat.c     **** 						//on_counter++;
 617:ir_heat.c     **** 	   				if(on_counter==3){
 618:ir_heat.c     **** 	   					beep(BEEP_SHORT);
 619:ir_heat.c     **** 	   					on_counter = 0;
 620:ir_heat.c     **** 	   				}
 621:ir_heat.c     ****   					}
 622:ir_heat.c     ****    				else {
 623:ir_heat.c     ****    					if(get_last_slope() > 0) {
 624:ir_heat.c     **** 							//on_counter++;
 625:ir_heat.c     **** 			   			if(on_counter > 2) {
 626:ir_heat.c     ****    							off_counter = OFF_COUNTER+1;
 627:ir_heat.c     ****    							on_counter = 2;
 628:ir_heat.c     ****    							beep(BEEP_XLONG);
 629:ir_heat.c     **** 		   				}
 630:ir_heat.c     **** 		   				else {
 631:ir_heat.c     **** 	   						beep(BEEP_LONG);
 632:ir_heat.c     ****    						}
 633:ir_heat.c     ****    					}
 634:ir_heat.c     ****    					else {
 635:ir_heat.c     ****    						if(slope_raw<0) on_counter=0;
 636:ir_heat.c     ****    					}
 637:ir_heat.c     ****    				}
 638:ir_heat.c     **** 				}			
 639:ir_heat.c     **** 				else {
 640:ir_heat.c     **** 					on_counter = 0;
 641:ir_heat.c     **** 				}					
 642:ir_heat.c     ****    	   }
 643:ir_heat.c     **** 
 644:ir_heat.c     ****    		if(off_counter) {
 645:ir_heat.c     ****    			// Protection Counter läuft
 646:ir_heat.c     ****   				off_counter--;
 647:ir_heat.c     ****   				if(mode == MODE_ON) mode = MODE_TEMP_PROT;
 648:ir_heat.c     **** 				printf("Off-Counter: %i; \n", off_counter);
 649:ir_heat.c     ****    		}
 650:ir_heat.c     ****    		else {
 651:ir_heat.c     ****    			if(mode == MODE_TEMP_PROT) {
 652:ir_heat.c     ****    				slope = 0;
 653:ir_heat.c     ****    				integral = 0;
 654:ir_heat.c     ****    				mode = MODE_OFF;
 655:ir_heat.c     ****    			}
 656:ir_heat.c     ****    		}
 657:ir_heat.c     **** 		}
 658:ir_heat.c     **** 		else if(interval != last_interval) {
 659:ir_heat.c     **** 			// In jedem Interval 1x die Temperatur abrufen
 660:ir_heat.c     **** 			// und für den Mittelwert aufsummieren
 661:ir_heat.c     ****    		last_interval = interval;
 662:ir_heat.c     ****     		if(count<16) {
 663:ir_heat.c     **** 	   		count++;
 664:ir_heat.c     ****    			// Messwerte für den Mittelwert aufsummieren
 665:ir_heat.c     ****    			temp_sum += get_temperature(ADR_T_OBJ1);
 666:ir_heat.c     ****    		}
 667:ir_heat.c     ****    	}
 668:ir_heat.c     **** 
 669:ir_heat.c     **** 		// Je nach Mode Relais und LEDs setzen
 670:ir_heat.c     **** 		switch(mode) {
 671:ir_heat.c     **** 		case MODE_OFF:
 672:ir_heat.c     **** 			set_relais(0);
 673:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 1853               	n	68,0,547,.LM198-.LFBB22
 1854               	.LM198:
 1855 086e 0F2E      	/* #NOAPP */
 1856 0870 FBE2      		movw r24,r28
 1857 0872 CF2E      		mov r22,r16
 1858 0874 DD24      		ldi r23,lo8(0)
 1859 0876 F02D      		call __divmodhi4
 1860               		mov r24,r22
 1861               		mov r25,r23
 1862 0878 4424      		movw r28,r24
 1864               	.LM199:
 1865               		sts interval,__zero_reg__
 1867 087e F3E0      	.LM200:
 1868 0880 2F2E      		sbiw r28,0
 1869 0882 F02D      		brne .L92
 1871               	.LM201:
 1872               		rcall .
 1873               		ldi r18,lo8(.LC7)
 1874               		ldi r19,hi8(.LC7)
 1875               		in r30,__SP_L__
 1876               		in r31,__SP_H__
 1877               		std Z+2,r19
 1878 0884 0F2E      		std Z+1,r18
 1879 0886 F8EA      		call printf
 1880 0888 6F2E      		pop __tmp_reg__
 1881 088a F1E6      		pop __tmp_reg__
 1882 088c 7F2E      		rjmp .L93
 1883 088e F02D      	.L92:
 1885               	.LM202:
 1886               		tst r8
 1887               		breq .L94
 1889               	.LM203:
 1890               		rcall .
 1891               		rcall .
 1892               		in r30,__SP_L__
 1893 0890 4091 0000 		in r31,__SP_H__
 1894 0894 4031      		adiw r30,1
 1895 0896 04F4      		ldi r24,lo8(.LC8)
 1896 0898 00C0      		ldi r25,hi8(.LC8)
 1897               		std Z+1,r25
 1898               		st Z,r24
 1899               		std Z+2,r8
 1900               		std Z+3,__zero_reg__
 1901 089a A895      		call printf
 1903               	.LM204:
 1904               		dec r8
 1906 089c CE01      	.LM205:
 1907 089e 602F      		pop __tmp_reg__
 1908 08a0 70E0      		pop __tmp_reg__
 1909 08a2 0E94 0000 		pop __tmp_reg__
 1910 08a6 862F      		pop __tmp_reg__
 1911 08a8 972F      		ldi r24,lo8(7)
 1912 08aa EC01      		call get_temperature
 1913               		movw r28,r24
 1914               	.L94:
 1916               	.LM206:
 1917               		rcall .
 1918 08b0 2097      		rcall .
 1919 08b2 01F4      		in r30,__SP_L__
 1920               		in r31,__SP_H__
 1921               		adiw r30,1
 1922 08b4 00D0      		ldi r18,lo8(.LC9)
 1923 08b6 20E0      		ldi r19,hi8(.LC9)
 1924 08b8 30E0      		std Z+1,r19
 1925 08ba EDB7      		st Z,r18
 1926 08bc FEB7      		std Z+3,r29
 1927 08be 3283      		std Z+2,r28
 1928 08c0 2183      		call printf
 1930 08c6 0F90      	.LM207:
 1931 08c8 0F90      		pop __tmp_reg__
 1932 08ca 00C0      		pop __tmp_reg__
 1933               		pop __tmp_reg__
 1934               		pop __tmp_reg__
 1935               		movw r24,r28
 1936 08cc 8820      		call add_value
 1938               	.LM208:
 1939               		call get_slope
 1940 08d0 00D0      		movw r10,r24
 1942 08d4 EDB7      	.LM209:
 1943 08d6 FEB7      		ldi r24,lo8(6)
 1944 08d8 3196      		call get_temperature
 1946 08dc 90E0      	.LM210:
 1947 08de 9183      		movw r24,r28
 1948 08e0 8083      		call exp_slope
 1949 08e2 8282      		movw r14,r24
 1951 08e6 0E94 0000 	.LM211:
 1952               		call get_slope2
 1953               		movw r16,r24
 1955               	.LM212:
 1956               		call get_slope
 1957 08ec 0F90      		in r30,__SP_L__
 1958 08ee 0F90      		in r31,__SP_H__
 1959 08f0 0F90      		sbiw r30,8
 1960 08f2 0F90      		in __tmp_reg__,__SREG__
 1961 08f4 87E0      		cli
 1962 08f6 0E94 0000 		out __SP_H__,r31
 1963 08fa EC01      		out __SREG__,__tmp_reg__
 1964               		out __SP_L__,r30
 1965               		adiw r30,1
 1966               		ldi r18,lo8(.LC10)
 1967 08fc 00D0      		ldi r19,hi8(.LC10)
 1968 08fe 00D0      		std Z+1,r19
 1969 0900 EDB7      		st Z,r18
 1970 0902 FEB7      		std Z+3,r15
 1971 0904 3196      		std Z+2,r14
 1972 0906 20E0      		std Z+5,r17
 1973 0908 30E0      		std Z+4,r16
 1974 090a 3183      		std Z+7,r25
 1975 090c 2083      		std Z+6,r24
 1976 090e D383      		call printf
 1978 0912 0E94 0000 	.LM213:
 1979               		in r24,__SP_L__
 1980               		in r25,__SP_H__
 1981 0916 0F90      		adiw r24,8
 1982 0918 0F90      		in __tmp_reg__,__SREG__
 1983 091a 0F90      		cli
 1984 091c 0F90      		out __SP_H__,r25
 1985 091e CE01      		out __SREG__,__tmp_reg__
 1986 0920 0E94 0000 		out __SP_L__,r24
 1987               		cp r14,r16
 1988               		cpc r15,r17
 1989 0924 0E94 0000 		brge .L95
 1991               	.LM214:
 1992               		inc r9
 1994 092c 0E94 0000 	.LM215:
 1995               		rcall .
 1996               		rcall .
 1997 0930 CE01      		in r30,__SP_L__
 1998 0932 0E94 0000 		in r31,__SP_H__
 1999 0936 7C01      		adiw r30,1
 2000               		ldi r18,lo8(.LC11)
 2001               		ldi r19,hi8(.LC11)
 2002 0938 0E94 0000 		std Z+1,r19
 2003 093c 8C01      		st Z,r18
 2004               		std Z+2,r9
 2005               		std Z+3,__zero_reg__
 2006 093e 0E94 0000 		call printf
 2008 0944 FEB7      	.LM216:
 2009 0946 3897      		pop __tmp_reg__
 2010 0948 0FB6      		pop __tmp_reg__
 2011 094a F894      		pop __tmp_reg__
 2012 094c FEBF      		pop __tmp_reg__
 2013 094e 0FBE      		lds r24,mode
 2014 0950 EDBF      		cpi r24,lo8(2)
 2015 0952 3196      		brne .L96
 2017 0956 30E0      	.LM217:
 2018 0958 3183      		ldi r19,lo8(3)
 2019 095a 2083      		cp r9,r19
 2020 095c F382      		brne .L93
 2022 0960 1583      	.LM218:
 2023 0962 0483      		ldi r24,lo8(1)
 2024 0964 9783      		call beep
 2025 0966 8683      		clr r9
 2026 0968 0E94 0000 		rjmp .L93
 2027               	.L96:
 2029 096c 8DB7      	.LM219:
 2030 096e 9EB7      		call get_last_slope
 2031 0970 0896      		cp __zero_reg__,r24
 2032 0972 0FB6      		cpc __zero_reg__,r25
 2033 0974 F894      		brge .L97
 2035 0978 0FBE      	.LM220:
 2036 097a 8DBF      		ldi r24,lo8(2)
 2037 097c E016      		cp r24,r9
 2038 097e F106      		brsh .L98
 2040               	.LM221:
 2041               		sts off_counter,r2
 2043               	.LM222:
 2044               		ldi r24,lo8(4)
 2045 0984 00D0      		call beep
 2046 0986 00D0      		clr r9
 2047 0988 EDB7      		set
 2048 098a FEB7      		bld r9,1
 2049 098c 3196      		rjmp .L93
 2050 098e 20E0      	.L98:
 2052 0992 3183      	.LM223:
 2053 0994 2083      		mov r24,r2
 2054 0996 9282      		call beep
 2055 0998 1382      		rjmp .L93
 2056 099a 0E94 0000 	.L97:
 2058               	.LM224:
 2059 099e 0F90      		tst r11
 2060 09a0 0F90      		brge .L93
 2061 09a2 0F90      	.L95:
 2062 09a4 0F90      		clr r9
 2063 09a6 8091 0000 	.L93:
 2065 09ac 01F4      	.LM225:
 2066               		lds r24,off_counter
 2067               		tst r24
 2068 09ae 33E0      		breq .L99
 2070 09b2 01F4      	.LM226:
 2071               		subi r24,lo8(-(-1))
 2072               		sts off_counter,r24
 2074 09b6 0E94 0000 	.LM227:
 2075 09ba 9924      		lds r24,mode
 2076 09bc 00C0      		cpi r24,lo8(1)
 2077               		brne .L100
 2078               		sts mode,r2
 2079               	.L100:
 2081 09c2 1816      	.LM228:
 2082 09c4 1906      		rcall .
 2083 09c6 04F4      		rcall .
 2084               		in r30,__SP_L__
 2085               		in r31,__SP_H__
 2086 09c8 82E0      		adiw r30,1
 2087 09ca 8915      		ldi r18,lo8(.LC12)
 2088 09cc 00F4      		ldi r19,hi8(.LC12)
 2089               		std Z+1,r19
 2090               		st Z,r18
 2091 09ce 2092 0000 		lds r24,off_counter
 2092               		std Z+2,r24
 2093               		std Z+3,__zero_reg__
 2094 09d2 84E0      		call printf
 2095 09d4 0E94 0000 		movw r28,r4
 2096 09d8 9924      		ldi r16,lo8(0)
 2097 09da 6894      		pop __tmp_reg__
 2098 09dc 91F8      		pop __tmp_reg__
 2099 09de 00C0      		pop __tmp_reg__
 2100               		pop __tmp_reg__
 2101               		rjmp .L101
 2102               	.L99:
 2104 09e2 0E94 0000 	.LM229:
 2105 09e6 00C0      		lds r24,mode
 2106               		cpi r24,lo8(3)
 2107               		breq .L102
 2108               		movw r28,r4
 2109 09e8 BB20      		ldi r16,lo8(0)
 2110 09ea 04F4      		rjmp .L101
 2111               	.L102:
 2113               	.LM230:
 2114               		sts mode,__zero_reg__
 2115               		movw r28,r4
 2116 09ee 8091 0000 		ldi r16,lo8(0)
 2117 09f2 8823      		rjmp .L103
 2118 09f4 01F0      	.L91:
 2120               	.LM231:
 2121 09f6 8150      		mov r18,r20
 2122 09f8 8093 0000 		clr r19
 2123               		sbrc r18,7
 2124               		com r19
 2125 09fc 8091 0000 		mov r24,r3
 2126 0a00 8130      		ldi r25,lo8(0)
 2127 0a02 01F4      		cp r18,r24
 2128 0a04 2092 0000 		cpc r19,r25
 2129               		breq .L101
 2131               	.LM232:
 2132 0a08 00D0      		mov r3,r20
 2134 0a0c EDB7      	.LM233:
 2135 0a0e FEB7      		cpi r16,lo8(16)
 2136 0a10 3196      		brsh .L101
 2138 0a14 30E0      	.LM234:
 2139 0a16 3183      		subi r16,lo8(-(1))
 2141 0a1a 8091 0000 	.LM235:
 2142 0a1e 8283      		ldi r24,lo8(7)
 2143 0a20 1382      		call get_temperature
 2144 0a22 0E94 0000 		add r28,r24
 2145 0a26 E201      		adc r29,r25
 2146 0a28 00E0      	.L101:
 2148 0a2c 0F90      	.LM236:
 2149 0a2e 0F90      		lds r24,mode
 2150 0a30 0F90      		cpi r24,lo8(1)
 2151 0a32 00C0      		breq .L105
 2152               		cpi r24,lo8(1)
 2153               		brlo .L103
 2154               		cpi r24,lo8(2)
 2155 0a34 8091 0000 		breq .L106
 2156 0a38 8330      		cpi r24,lo8(3)
 2157 0a3a 01F0      		brne .L111
 2158 0a3c E201      		rjmp .L112
 2159 0a3e 00E0      	.L103:
 2161               	.LM237:
 2162               		ldi r24,lo8(0)
 2163               		call set_relais
 2165 0a46 E201      	.LM238:
 2166 0a48 00E0      		movw r30,r12
 2167 0a4a 00C0      		ld r24,Z
 2168               		ori r24,lo8(16)
 2169               		st Z,r24
 2171 0a4c 242F      	.LM239:
 2172 0a4e 3327      		ld r24,Z
 2173 0a50 27FD      		andi r24,lo8(-9)
 2174 0a52 3095      		st Z,r24
 2176 0a56 90E0      	.LM240:
 2177 0a58 2817      		sts off_counter,__zero_reg__
 2178 0a5a 3907      		clr r9
 2179 0a5c 01F0      		rjmp .L108
 2180               	.L105:
 2182 0a5e 342E      	.LM241:
 2183               		movw r30,r12
 2184               		ld r24,Z
 2185 0a60 0031      		ori r24,lo8(16)
 2186 0a62 00F4      		st Z,r24
 2187               	.L106:
 2189 0a64 0F5F      	.LM242:
 2190               		ldi r24,lo8(1)
 2191               		call set_relais
 2193 0a68 0E94 0000 	.LM243:
 2194 0a6c C80F      		movw r30,r12
 2195 0a6e D91F      		ld r24,Z
 2196               		ori r24,lo8(8)
 2197               		st Z,r24
 2198               		rjmp .L108
 2199 0a70 8091 0000 	.L112:
 2201 0a76 01F0      	.LM244:
 2202 0a78 8130      		ldi r24,lo8(0)
 2203 0a7a 00F0      		call set_relais
 2205 0a7e 01F0      	.LM245:
 2206 0a80 8330      		movw r30,r12
 2207 0a82 01F4      		ld r24,Z
 2208 0a84 00C0      		andi r24,lo8(-17)
 2209               		st Z,r24
 2211               	.LM246:
 2212 0a86 80E0      		ld r24,Z
 2213 0a88 0E94 0000 		ori r24,lo8(8)
 2214               		st Z,r24
 2215               		rjmp .L108
 2216 0a8c F601      	.L111:
 2218 0a90 8061      	.LM247:
 2219 0a92 8083      		sts mode,__zero_reg__
 674:ir_heat.c     **** 			STATUS_LED2_OFF;
 2220               	(8)
 2221               		st Z,r24
 2222 0a94 8081      		rjmp .L108
 2223 0a96 877F      	.L111:
 675:ir_heat.c     **** 			off_counter = 0;
 2225               	22
 2226               	.LM246:
 2227 0a9a 1092 0000 		ld r24,Z
 2228 0a9e 9924      		ori r24,lo8(8)
 2229 0aa0 00C0      		st Z,r24
 2230               		rjmp .L108
 676:ir_heat.c     **** 			on_counter = 0;
 677:ir_heat.c     **** 			break;
 678:ir_heat.c     **** 		case MODE_ON:
 679:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 2231               	)
 2232               		st Z,r24
 2234 0aa4 8081      	.LM246:
 2235 0aa6 8061      		ld r24,Z
 2236 0aa8 8083      		ori r24,lo8(8)
 2237               		st Z,r24
 680:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 681:ir_heat.c     **** 			set_relais(1);
 2238               	i r24,lo8(-17)
 2239               		st Z,r24
 2241 0aac 0E94 0000 	.LM246:
 682:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2242               	22
 2243               	.LM245:
 2244 0ab0 F601      		movw r30,r12
 2245 0ab2 8081      		ld r24,Z
 2246 0ab4 8860      		andi r24,lo8(-17)
 2247 0ab6 8083      		st Z,r24
 2249               	.LM246:
 683:ir_heat.c     **** 			break;
 684:ir_heat.c     **** 		case MODE_TEMP_PROT:
 685:ir_heat.c     **** 			set_relais(0);
 2250               	22
 2251               	.LM245:
 2252 0aba 80E0      		movw r30,r12
 2253 0abc 0E94 0000 		ld r24,Z
 686:ir_heat.c     **** 			STATUS_LED1_OFF;
 2254               	22
 2255               	.LM244:
 2256 0ac0 F601      		ldi r24,lo8(0)
 2257 0ac2 8081      		call set_relais
 2259 0ac6 8083      	.LM245:
 687:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2260               	tabn	68,0,685,.LM244-.LFBB22
 2261               	.LM244:
 2262 0ac8 8081      		ldi r24,lo8(0)
 2263 0aca 8860      		call set_relais
 2265 0ace 00C0      	.LM245:
 2266               		movw r30,r12
 688:ir_heat.c     **** 			slope = 0;
 689:ir_heat.c     **** 			integral = 0;
 690:ir_heat.c     **** 			break;
 691:ir_heat.c     **** 		default:
 692:ir_heat.c     **** 			mode = MODE_OFF;
 2267               	LM244-.LFBB22
 2268               	.LM244:
 2269 0ad0 1092 0000 		ldi r24,lo8(0)
 2270               		call set_relais
 2272               	.LM245:
 2273               		movw r30,r12
 2274               		ld r24,Z
 2275               		andi r24,lo8(-17)
 2276               		st Z,r24
 2278               	.LM246:
 2279 0ad4 C301      		ld r24,Z
 2280               		ori r24,lo8(8)
 2281               		st Z,r24
 2282 0ad6 0197      		rjmp .L108
 2283 0ad8 01F4      	.L111:
 2285               	.LM247:
 2286 0ada 00C0      		sts mode,__zero_reg__
 2287               	.L108:
 2288               	.LBB63:
 2289               	.LBB62:
 2290               	.LBB61:
 2291               	.LBB60:
 2293               	.Ltext13:
 2295               	.LM248:
 2296               		movw r24,r6
 2297               	/* #APP */
 2298               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 2299               		1: sbiw r24,1
 2300               		brne 1b
 2301               	 ;  0 "" 2
 2302               	/* #NOAPP */
 2303               		rjmp .L109
 2304               	.LBE60:
 2305               	.LBE61:
 2306               	.LBE62:
 2307               	.LBE63:
 2320               	.Lscope22:
 2321               	.global	interval
 2322 0001 00        		.data
 2325               	interval:
 2326               		.byte	-12
 2327               	.global	off_counter
 2328 0002 00        	.global	off_counter
 2329               		.section .bss
 2332               	off_counter:
 2333               		.skip 1,0
 2334               	.global	flash_button
 2335               	.global	flash_button
 2338               	flash_button:
 2339               		.skip 1,0
 2340               	.global	flash_LED
 2341               	.global	flash_LED
 2344               	flash_LED:
 2345               		.skip 1,0
 2346               		.lcomm last.2001,1
 2347               		.lcomm last_slope.1889,2
 2348               		.lcomm running.1757,1
 2349               		.lcomm c2.1731,1
 2350               		.lcomm c1.1730,1
 2351               		.comm tbuf,32,1
 2352               		.comm rbuf,32,1
 2353               		.comm t_in,1,1
 2354               		.comm t_out,1,1
 2355               		.comm r_in,1,1
 2356               		.comm r_out,1,1
 2357               		.comm t_array,12,1
 2358               		.comm mode,1,1
 2359               		.comm slope2,2,1
DEFINED SYMBOLS
                            *ABS*:00000000 ir_heat.c
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:2      *ABS*:0000003f __SREG__
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:3      *ABS*:0000003e __SP_H__
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:4      *ABS*:0000003d __SP_L__
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:5      *ABS*:00000034 __CCP__
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:89     .text:00000000 __vector_9
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:2308   .data:000000b5 interval
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:120    .text:00000022 __vector_13
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:153    .text:00000042 __vector_16
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:2332   .bss:00000008 c1.1730
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:2331   .bss:00000007 c2.1731
                            *COM*:00000001 mode
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:274    .text:000000de __vector_18
                            *COM*:00000001 r_in
                            *COM*:00000020 rbuf
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:324    .text:0000011c __vector_19
                            *COM*:00000001 t_in
                            *COM*:00000001 t_out
                            *COM*:00000020 tbuf
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:387    .text:00000176 tbuflen
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:409    .text:00000182 UART_putchar
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:466    .text:000001ce rbuflen
                            *COM*:00000001 r_out
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:487    .text:000001da UART_getchar
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:527    .text:00000200 exp_slope
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:576    .text:00000240 get_slope2
                            *COM*:0000000c t_array
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:2329   .bss:00000004 last_slope.1889
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:621    .text:00000286 add_value
                            *COM*:00000002 slope2
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:736    .text:0000034c get_slope
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:813    .text:000003cc get_last_slope
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:839    .text:000003e6 _beep
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:915    .text:00000424 beep
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:1062   .text:00000498 set_relais
                             .bss:00000003 last.2001
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:1131   .text:000004de __vector_1
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:2330   .bss:00000006 running.1757
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:1397   .text:00000610 get_temperature
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:1493   .text:0000067c print_array
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:1631   .text:00000778 UART_first_init
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:1690   .text:000007a0 main
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:2315   .bss:00000000 off_counter
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:2321   .bss:00000001 flash_button
C:\Users\Thorsten\AppData\Local\Temp/ccoyyf9M.s:2327   .bss:00000002 flash_LED

UNDEFINED SYMBOLS
__divmodhi4
__udivmodhi4
puts
i2c_start
i2c_write
i2c_rep_start
i2c_read_ack
i2c_stop
printf
putchar
fdevopen
i2c_init
__do_copy_data
__do_clear_bss
