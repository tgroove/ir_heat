   1               		.file	"ir_heat.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  87               	.global	__vector_9
  89               	__vector_9:
   1:ir_heat.c     **** // ***********************************************************
   2:ir_heat.c     **** // Project:
   3:ir_heat.c     **** // Author:
   4:ir_heat.c     **** // Module description:
   5:ir_heat.c     **** // ***********************************************************
   6:ir_heat.c     **** 
   7:ir_heat.c     **** #ifndef F_CPU
   8:ir_heat.c     **** #define F_CPU 1000000UL
   9:ir_heat.c     **** #endif
  10:ir_heat.c     **** 
  11:ir_heat.c     **** #include <avr\io.h>              // Most basic include files
  12:ir_heat.c     **** #include <avr\interrupt.h>       // Add the necessary ones
  13:ir_heat.c     **** //#include <avr\signal.h>          // here
  14:ir_heat.c     **** #include <avr\wdt.h>
  15:ir_heat.c     **** 
  16:ir_heat.c     **** #include <stdio.h>
  17:ir_heat.c     **** #include <string.h>
  18:ir_heat.c     **** #include <stdlib.h>
  19:ir_heat.c     **** #include	<util/delay.h>
  20:ir_heat.c     **** 
  21:ir_heat.c     **** #include "i2c_mstr.h"
  22:ir_heat.c     **** #include "ir_heat.h"
  23:ir_heat.c     **** 
  24:ir_heat.c     **** #define 	MLX90614_WRITE	(0x5A<<1)
  25:ir_heat.c     **** #define 	MLX90614_READ	(MLX90614_WRITE+1)
  26:ir_heat.c     **** #define	ADR_T_A			0x06
  27:ir_heat.c     **** #define	ADR_T_OBJ1		0x07
  28:ir_heat.c     **** #define	ADR_T_OBJ2		0x08
  29:ir_heat.c     **** #define	DEFAULT_TEMP	150
  30:ir_heat.c     **** 
  31:ir_heat.c     **** 
  32:ir_heat.c     **** #define __STDIO_FDEVOPEN_COMPAT_12						
  33:ir_heat.c     **** // Buffer sizes must be 2^n
  34:ir_heat.c     **** //
  35:ir_heat.c     **** #define TBUFSIZE			32
  36:ir_heat.c     **** #define RBUFSIZE			32
  37:ir_heat.c     **** 
  38:ir_heat.c     **** #define TMASK				(TBUFSIZE-1)
  39:ir_heat.c     **** #define RMASK				(RBUFSIZE-1)
  40:ir_heat.c     **** 
  41:ir_heat.c     **** #define FLASH_LED			PC3
  42:ir_heat.c     **** #define STATUS_LED1		PD4
  43:ir_heat.c     **** #define STATUS_LED2		PD3
  44:ir_heat.c     **** #define RELAIS				PB6
  45:ir_heat.c     **** #define BUZZER				PB7
  46:ir_heat.c     **** #define SWITCH				PD2
  47:ir_heat.c     **** 
  48:ir_heat.c     **** #define RELAIS_ON			PORTB |= (1<<RELAIS)
  49:ir_heat.c     **** #define RELAIS_OFF		PORTB &=~(1<<RELAIS)
  50:ir_heat.c     **** 
  51:ir_heat.c     **** #define BUZZER_ON			PORTB |= (1<<BUZZER)
  52:ir_heat.c     **** #define BUZZER_OFF		PORTB &=~(1<<BUZZER)
  53:ir_heat.c     **** 
  54:ir_heat.c     **** #define STATUS_LED1_ON	PORTD |= (1<<STATUS_LED1)
  55:ir_heat.c     **** #define STATUS_LED1_OFF	PORTD &=~(1<<STATUS_LED1)
  56:ir_heat.c     **** 
  57:ir_heat.c     **** #define FLASH_LED_ON		PORTC |= (1<<FLASH_LED)
  58:ir_heat.c     **** #define FLASH_LED_OFF	PORTC &=~(1<<FLASH_LED)
  59:ir_heat.c     **** 
  60:ir_heat.c     **** #define STATUS_LED2_ON	PORTD |= (1<<STATUS_LED2)
  61:ir_heat.c     **** #define STATUS_LED2_OFF	PORTD &=~(1<<STATUS_LED2)
  62:ir_heat.c     **** 
  63:ir_heat.c     **** #define OFF_COUNTER		2
  64:ir_heat.c     **** 
  65:ir_heat.c     **** #define TIMER1_STOP		TCCR1B = 0
  66:ir_heat.c     **** #define TIMER1_RUN		TCCR1B = (0<<CS12) | (1<<CS11) | (0<<CS10)
  67:ir_heat.c     **** 
  68:ir_heat.c     **** #define	MODE_OFF				0
  69:ir_heat.c     **** #define	MODE_ON				1
  70:ir_heat.c     **** #define	MODE_ON_NO_PROT	2
  71:ir_heat.c     **** #define	MODE_TEMP_PROT		3
  72:ir_heat.c     **** 
  73:ir_heat.c     **** #define	BEEP_SHORT			1
  74:ir_heat.c     **** #define	BEEP_2SHORT			2
  75:ir_heat.c     **** #define	BEEP_LONG			3
  76:ir_heat.c     **** #define	BEEP_XLONG			4
  77:ir_heat.c     **** #define	BEEP_2LONG			5
  78:ir_heat.c     **** #define	BEEP_SHORT_LONG	6
  79:ir_heat.c     **** 
  80:ir_heat.c     **** // Define here the global static variables
  81:ir_heat.c     **** //
  82:ir_heat.c     **** volatile unsigned char tbuf[TBUFSIZE];  // TX buffer
  83:ir_heat.c     **** volatile unsigned char rbuf[RBUFSIZE];  // RX buffer
  84:ir_heat.c     **** 
  85:ir_heat.c     **** volatile unsigned char t_in;            // TX buffer in index
  86:ir_heat.c     **** volatile unsigned char t_out;           // TX buffer out index
  87:ir_heat.c     **** 
  88:ir_heat.c     **** volatile unsigned char r_in;            // RX buffer in index
  89:ir_heat.c     **** volatile unsigned char r_out;           // RX buffer out index
  90:ir_heat.c     **** 
  91:ir_heat.c     **** int8_t	interval = -12;
  92:ir_heat.c     **** int16_t 	t_array[6];
  93:ir_heat.c     **** uint8_t	off_counter = 0;
  94:ir_heat.c     **** uint8_t	mode;
  95:ir_heat.c     **** int16_t	slope2;
  96:ir_heat.c     **** uint8_t	flash_button = 0;
  97:ir_heat.c     **** uint8_t	flash_LED = 0;
  98:ir_heat.c     **** 
  99:ir_heat.c     **** /*
 100:ir_heat.c     **** uint16_t	t_la_threshold_up 	=  300;
 101:ir_heat.c     **** uint16_t	t_abs_threshold_up 	=  270;
 102:ir_heat.c     **** uint16_t	t_la_threshold_down 	=  250;
 103:ir_heat.c     **** uint16_t	t_abs_threshold_down	=  250;
 104:ir_heat.c     **** */
 105:ir_heat.c     **** 
 106:ir_heat.c     **** 
 107:ir_heat.c     **** // Clock Timer
 108:ir_heat.c     **** SIGNAL(SIG_OVERFLOW2) {
  90               	ush r0
  91               		clr __zero_reg__
  92               		push r24
  93 0000 1F92      	/* prologue: Signal */
  94 0002 0F92      	/* frame size = 0 */
  96 0006 0F92      	.LM1:
  97 0008 1124      		lds r24,interval
  98 000a 8F93      		subi r24,lo8(-(1))
  99               		sts interval,r24
 100               	/* epilogue start */
 109:ir_heat.c     **** 	interval++;
 101               	0,110,.LM2-.LFBB1
 102               	.LM2:
 103 000c 8091 0000 		pop r24
 104 0010 8F5F      		pop r0
 105 0012 8093 0000 		out __SREG__,r0
 106               		pop r0
 110:ir_heat.c     **** }
 107               	_zero_reg__
 108               		reti
 110 0018 0F90      	.Lscope1:
 112 001c 0F90      	.global	__vector_13
 114 0020 1895      	__vector_13:
 116               	.LM3:
 117               	.LFBB2:
 118               		push __zero_reg__
 119               		push r0
 120               		in r0,__SREG__
 111:ir_heat.c     **** 
 112:ir_heat.c     **** SIGNAL(SIG_OVERFLOW1) {
 121               	__zero_reg__
 122               	/* prologue: Signal */
 123               	/* frame size = 0 */
 125 0024 0F92      	.LM4:
 126 0026 0FB6      		sts 129,__zero_reg__
 128 002a 1124      	.LM5:
 129               		sts 133,__zero_reg__
 113:ir_heat.c     **** 	TIMER1_STOP;
 131               	 132,__zero_reg__
 132               	/* epilogue start */
 114:ir_heat.c     **** 	TCNT1H = 0;
 134               	7:
 135               		pop r0
 136 0030 1092 8500 		out __SREG__,r0
 115:ir_heat.c     **** 	TCNT1L = 0;
 137               	p r0
 138               		pop __zero_reg__
 139 0034 1092 8400 		reti
 116:ir_heat.c     **** }
 141               	ope2:
 143 0038 0F90      	.global	__vector_16
 145 003c 0F90      	__vector_16:
 147 0040 1895      	.LM8:
 148               	.LFBB3:
 149               		push __zero_reg__
 150               		push r0
 151               		in r0,__SREG__
 152               		push r0
 153               		clr __zero_reg__
 117:ir_heat.c     **** 
 118:ir_heat.c     **** 
 119:ir_heat.c     **** // LED Flasher
 120:ir_heat.c     **** SIGNAL(SIG_OVERFLOW0) {
 154               	sh r19
 155               		push r20
 156               		push r24
 157 0042 1F92      		push r25
 158 0044 0F92      		push r30
 159 0046 0FB6      		push r31
 160 0048 0F92      	/* prologue: Signal */
 161 004a 1124      	/* frame size = 0 */
 163 004e 3F93      	.LM9:
 164 0050 4F93      		lds r24,c1.1730
 165 0052 8F93      		mov r18,r24
 166 0054 9F93      		subi r18,lo8(-(1))
 167 0056 EF93      		sts c1.1730,r18
 169               	.LM10:
 170               		lds r24,c2.1731
 121:ir_heat.c     **** 	static uint8_t	c1 = 0;
 122:ir_heat.c     **** 	static uint8_t c2 = 0;
 123:ir_heat.c     **** 	uint8_t slow=0;
 124:ir_heat.c     **** 	c1++;
 171               	i r19,lo8(-(1))
 172               		sts c2.1731,r19
 174 005e 282F      	.LM11:
 175 0060 2F5F      		lds r20,mode
 176 0062 2093 0000 		cpi r20,lo8(3)
 125:ir_heat.c     **** 	c2++;
 177               	.L6
 179 0066 8091 0000 	.LM12:
 180 006a 382F      		mov r24,r18
 181 006c 3F5F      		ldi r25,lo8(0)
 182 006e 3093 0000 		sbiw r24,7
 126:ir_heat.c     **** 	
 127:ir_heat.c     **** 	// Tasten LED
 128:ir_heat.c     **** 	if (mode==MODE_TEMP_PROT) {
 183               	.L6
 185 0072 4091 0000 	.LM13:
 186 0076 4330      		ldi r30,lo8(40)
 187 0078 01F4      		ldi r31,hi8(40)
 129:ir_heat.c     **** 		if(c1 > (6<<slow)) {
 188               	24,Z
 189               		ori r24,lo8(8)
 190 007a 822F      		st Z,r24
 191 007c 90E0      	.L6:
 193 0080 04F0      	.LM14:
 130:ir_heat.c     **** 			FLASH_LED_ON;
 194               	24,r18
 195               		ldi r25,lo8(0)
 196 0082 E8E2      		sbiw r24,11
 197 0084 F0E0      		brlt .L7
 199 0088 8860      	.LM15:
 200 008a 8083      		sts c1.1730,__zero_reg__
 131:ir_heat.c     **** 		}
 132:ir_heat.c     **** 	}
 133:ir_heat.c     **** 	if(c1 > (10<<slow)) {
 202               	ldi r30,lo8(40)
 203               		ldi r31,hi8(40)
 204 008c 822F      		ld r24,Z
 205 008e 90E0      		andi r24,lo8(-9)
 206 0090 0B97      		st Z,r24
 207 0092 04F0      	.L7:
 134:ir_heat.c     **** 		c1 = 0;
 208               	n	68,0,139,.LM17-.LFBB3
 209               	.LM17:
 210 0094 1092 0000 		cpi r20,lo8(2)
 135:ir_heat.c     **** 		FLASH_LED_OFF;
 211               	ne .L8
 213 0098 E8E2      	.LM18:
 214 009a F0E0      		cpi r19,lo8(121)
 215 009c 8081      		brlo .L8
 217 00a0 8083      	.LM19:
 218               		ldi r30,lo8(43)
 136:ir_heat.c     **** 	}
 137:ir_heat.c     **** 	
 138:ir_heat.c     **** 	// Status LED
 139:ir_heat.c     **** 	if (mode==MODE_ON_NO_PROT) {
 219               	,hi8(43)
 220               		ld r24,Z
 221 00a2 4230      		andi r24,lo8(-17)
 222 00a4 01F4      		st Z,r24
 140:ir_heat.c     **** 		if(c2 > 120) {
 223               	
 225 00a6 3937      	.LM20:
 226 00a8 00F0      		cpi r19,lo8(-120)
 141:ir_heat.c     **** 			STATUS_LED1_OFF;	// rot
 227               	lo .L10
 229 00aa EBE2      	.LM21:
 230 00ac F0E0      		sts c2.1731,__zero_reg__
 232 00b0 8F7E      	.LM22:
 233 00b2 8083      		ldi r30,lo8(43)
 234               		ldi r31,hi8(43)
 142:ir_heat.c     **** 		}
 143:ir_heat.c     **** 	}
 144:ir_heat.c     **** 	if(c2 > 135) {
 235               	Z
 236               		ori r24,lo8(16)
 237 00b4 3838      		st Z,r24
 238 00b6 00F0      	.L10:
 145:ir_heat.c     **** 		c2 = 0;
 239               	pilogue start */
 241 00b8 1092 0000 	.LM23:
 146:ir_heat.c     **** 		STATUS_LED1_ON; 		// orange
 242               	p r31
 243               		pop r30
 244 00bc EBE2      		pop r25
 245 00be F0E0      		pop r24
 246 00c0 8081      		pop r20
 247 00c2 8061      		pop r19
 248 00c4 8083      		pop r18
 249               		pop r0
 250               		out __SREG__,r0
 147:ir_heat.c     **** 	}	
 148:ir_heat.c     **** }
 251               	pop __zero_reg__
 252               		reti
 258 00d0 3F91      	.Lscope3:
 260 00d4 0F90      	.global	__vector_18
 262 00d8 0F90      	__vector_18:
 264 00dc 1895      	.LM24:
 265               	.LFBB4:
 266               		push __zero_reg__
 267               		push r0
 268               		in r0,__SREG__
 269               		push r0
 270               		clr __zero_reg__
 271               		push r24
 272               		push r30
 273               		push r31
 274               	/* prologue: Signal */
 149:ir_heat.c     **** 
 150:ir_heat.c     **** 
 151:ir_heat.c     **** 
 152:ir_heat.c     **** //*******************************************
 153:ir_heat.c     **** //
 154:ir_heat.c     **** // Taster IQR und Entprellung
 155:ir_heat.c     **** //
 156:ir_heat.c     **** SIGNAL(SIG_INTERRUPT0) {
 157:ir_heat.c     **** 	static uint8_t running = 0;
 158:ir_heat.c     **** 	
 159:ir_heat.c     **** 	if(running | TCNT1H | TCNT1L){
 160:ir_heat.c     **** //		printf("X");
 161:ir_heat.c     **** 		return;
 162:ir_heat.c     **** 	}
 163:ir_heat.c     **** 	running = 1;
 164:ir_heat.c     **** 	wdt_reset();
 165:ir_heat.c     **** 	
 166:ir_heat.c     **** 	uint16_t i;
 167:ir_heat.c     **** 	uint16_t c = 0;
 168:ir_heat.c     **** 	EIMSK = 0;
 169:ir_heat.c     **** 	sei();
 170:ir_heat.c     **** 	//printf("In");
 171:ir_heat.c     **** 	for(i=0;i<1000;i++) if((PIND & (1<<SWITCH))) c++;
 172:ir_heat.c     **** 	//printf(" %i ", c);
 173:ir_heat.c     **** 
 174:ir_heat.c     **** 	if(c < 200) {
 175:ir_heat.c     **** 		TCNT1L = 1;
 176:ir_heat.c     **** 		TIMER1_RUN;
 177:ir_heat.c     **** 		switch(mode) {
 178:ir_heat.c     **** 		case MODE_OFF:
 179:ir_heat.c     **** 			mode = MODE_ON;
 180:ir_heat.c     **** 			set_relais(1);
 181:ir_heat.c     **** 			STATUS_LED1_ON;			// orange
 182:ir_heat.c     **** 			STATUS_LED2_ON;
 183:ir_heat.c     **** 			c = 0;
 184:ir_heat.c     **** 			while((!(PIND & (1<<SWITCH))) && (c < 300)) {
 185:ir_heat.c     **** 				c++;
 186:ir_heat.c     **** 				_delay_ms (10);
 187:ir_heat.c     **** 			}
 188:ir_heat.c     **** 			//printf("c: %i", c);
 189:ir_heat.c     **** 
 190:ir_heat.c     **** 			if(c < 300) {
 191:ir_heat.c     **** 				// normal einnschalten
 192:ir_heat.c     **** 				mode = MODE_ON;
 193:ir_heat.c     **** 			}
 194:ir_heat.c     **** 			else {
 195:ir_heat.c     **** 				// einschalten, aber ohne Hitzeschutz
 196:ir_heat.c     **** 				mode = MODE_ON_NO_PROT;
 197:ir_heat.c     **** 				printf("Temperature Protection Off!\n");
 198:ir_heat.c     **** 				STATUS_LED1_OFF;		// rot
 199:ir_heat.c     **** 				STATUS_LED2_ON;
 200:ir_heat.c     **** 				beep(BEEP_SHORT_LONG);
 201:ir_heat.c     **** 			}
 202:ir_heat.c     **** 			break;
 203:ir_heat.c     **** 		case MODE_ON:
 204:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 205:ir_heat.c     **** 		case MODE_TEMP_PROT:
 206:ir_heat.c     **** 		default:
 207:ir_heat.c     **** 			printf("\nxXx\n");
 208:ir_heat.c     **** 			mode = MODE_OFF;
 209:ir_heat.c     **** 		}
 210:ir_heat.c     **** 	}
 211:ir_heat.c     **** //	printf("Out\n");
 212:ir_heat.c     **** 	EIFR 		= (1<<INTF0);
 213:ir_heat.c     **** 	EIMSK 	= (1<<INT0);
 214:ir_heat.c     **** 	running 	= 0;
 215:ir_heat.c     **** 	//printf("Exit\n");
 216:ir_heat.c     **** }
 217:ir_heat.c     **** 
 218:ir_heat.c     **** 
 219:ir_heat.c     **** 
 220:ir_heat.c     **** SIGNAL(SIG_USART_RECV) {
 275               	tabn	68,0,225,.LM25-.LFBB4
 276               	.LM25:
 277               		lds r24,198
 279 00e0 0F92      	.LM26:
 280 00e2 0FB6      		lds r30,r_in
 281 00e4 0F92      		ldi r31,lo8(0)
 282 00e6 1124      		andi r30,lo8(31)
 283 00e8 8F93      		andi r31,hi8(31)
 284 00ea EF93      		subi r30,lo8(-(rbuf))
 285 00ec FF93      		sbci r31,hi8(-(rbuf))
 286               		st Z,r24
 221:ir_heat.c     **** //******************
 222:ir_heat.c     **** // RX interrupt handler
 223:ir_heat.c     **** //
 224:ir_heat.c     **** 	char c;	
 225:ir_heat.c     **** 	c = UDR0;							// Get received char
 288               	24,r_in
 289               		subi r24,lo8(-(1))
 290 00ee 8091 C600 		sts r_in,r24
 226:ir_heat.c     **** 	rbuf[r_in & RMASK] = c;
 291               	epilogue start */
 293 00f2 E091 0000 	.LM28:
 294 00f6 F0E0      		pop r31
 295 00f8 EF71      		pop r30
 296 00fa F070      		pop r24
 297 00fc E050      		pop r0
 298 00fe F040      		out __SREG__,r0
 299 0100 8083      		pop r0
 227:ir_heat.c     **** 	r_in++;
 300               	ro_reg__
 301               		reti
 228:ir_heat.c     **** }
 306               	e4:
 308 010c FF91      	.global	__vector_19
 310 0110 8F91      	__vector_19:
 312 0114 0FBE      	.LM29:
 313 0116 0F90      	.LFBB5:
 314 0118 1F90      		push __zero_reg__
 315 011a 1895      		push r0
 316               		in r0,__SREG__
 317               		push r0
 318               		clr __zero_reg__
 319               		push r24
 320               		push r25
 321               		push r30
 322               		push r31
 323               	/* prologue: Signal */
 324               	/* frame size = 0 */
 229:ir_heat.c     **** 
 230:ir_heat.c     **** SIGNAL(SIG_USART_DATA) {
 325               	M30-.LFBB5
 326               	.LM30:
 327               		lds r25,t_in
 328 011c 1F92      		lds r24,t_out
 329 011e 0F92      		cp r25,r24
 330 0120 0FB6      		breq .L14
 332 0124 1124      	.LM31:
 333 0126 8F93      		lds r30,t_out
 334 0128 9F93      		ldi r31,lo8(0)
 335 012a EF93      		andi r30,lo8(31)
 336 012c FF93      		andi r31,hi8(31)
 337               		subi r30,lo8(-(tbuf))
 338               		sbci r31,hi8(-(tbuf))
 231:ir_heat.c     **** //*******************
 232:ir_heat.c     **** // Data register empty interrupt handler.
 233:ir_heat.c     **** // Indicates that next char can be transmitted
 234:ir_heat.c     **** //
 235:ir_heat.c     **** 	if(t_in != t_out) {
 339               	 198,r24
 341 012e 9091 0000 	.LM32:
 342 0132 8091 0000 		lds r24,t_out
 343 0136 9817      		subi r24,lo8(-(1))
 344 0138 01F0      		sts t_out,r24
 236:ir_heat.c     **** 		UDR0 = tbuf[t_out & TMASK];
 345               	.L16
 346               	.L14:
 348 013e F0E0      	.LM33:
 349 0140 EF71      		ldi r30,lo8(193)
 350 0142 F070      		ldi r31,hi8(193)
 351 0144 E050      		ld r24,Z
 352 0146 F040      		andi r24,lo8(-33)
 353 0148 8081      		st Z,r24
 354 014a 8093 C600 	.L16:
 237:ir_heat.c     **** 		t_out++;	
 355               	e start */
 357 014e 8091 0000 	.LM34:
 358 0152 8F5F      		pop r31
 359 0154 8093 0000 		pop r30
 360 0158 00C0      		pop r25
 361               		pop r24
 238:ir_heat.c     **** 	}
 239:ir_heat.c     **** 	else {
 240:ir_heat.c     **** 		UCSR0B &= ~(1<<UDRIE0);
 362               	
 363               		out __SREG__,r0
 364 015a E1EC      		pop r0
 365 015c F0E0      		pop __zero_reg__
 366 015e 8081      		reti
 368 0162 8083      	.Lscope5:
 370               	.global	tbuflen
 241:ir_heat.c     **** 	}
 242:ir_heat.c     **** }
 371               	buflen, @function
 372               	tbuflen:
 374 0166 EF91      	.LM35:
 375 0168 9F91      	.LFBB6:
 376 016a 8F91      	/* prologue: function */
 377 016c 0F90      	/* frame size = 0 */
 379 0170 0F90      	.LM36:
 380 0172 1F90      		lds r24,t_in
 381 0174 1895      		lds r25,t_out
 383               	.LM37:
 384               		sub r24,r25
 385               	/* epilogue start */
 386               		ret
 243:ir_heat.c     **** 
 244:ir_heat.c     **** char tbuflen(void) {
 388               		"UART_putchar:F(0,1)",36,0,0,UART_putchar
 391               	.global	UART_putchar
 245:ir_heat.c     **** //****************
 246:ir_heat.c     **** // Retrieve pending chars in TX buffer
 247:ir_heat.c     **** //
 248:ir_heat.c     **** 	return(t_in - t_out);
 393               	putchar:
 395 0176 8091 0000 	.LM38:
 396 017a 9091 0000 	.LFBB7:
 249:ir_heat.c     **** }
 397               	h r17
 398               		push r28
 399 017e 891B      		push r29
 400               	/* prologue: function */
 401 0180 0895      	/* frame size = 0 */
 402               		mov r17,r24
 404               	.LM39:
 405               		ldi r28,lo8(32)
 406               		ldi r29,hi8(32)
 407               	.L20:
 408               		call tbuflen
 409               		movw r18,r28
 250:ir_heat.c     **** 
 251:ir_heat.c     **** int UART_putchar(char c, FILE *stream) {
 410               		sbc r19,__zero_reg__
 411               		cpi r18,3
 412               		cpc r19,__zero_reg__
 413 0182 1F93      		brlt .L20
 415 0186 DF93      	.LM40:
 416               		lds r30,t_in
 417               		ldi r31,lo8(0)
 418 0188 182F      		andi r30,lo8(31)
 252:ir_heat.c     **** //*********************
 253:ir_heat.c     **** // Fills the transmit buffer, if it is full wait
 254:ir_heat.c     **** //
 255:ir_heat.c     **** 	while((TBUFSIZE - tbuflen()) <= 2);  // Wait...
 419               	,hi8(31)
 420               		subi r30,lo8(-(tbuf))
 421 018a C0E2      		sbci r31,hi8(-(tbuf))
 422 018c D0E0      		st Z,r17
 424 018e 0E94 0000 	.LM41:
 425 0192 9E01      		lds r24,t_in
 426 0194 281B      		subi r24,lo8(-(1))
 427 0196 3109      		sts t_in,r24
 429 019a 3105      	.LM42:
 430 019c 04F0      		ldi r30,lo8(193)
 256:ir_heat.c     **** 	
 257:ir_heat.c     **** 	// Add data to the transmit buffer, enable TXCIE
 258:ir_heat.c     **** 	//
 259:ir_heat.c     **** 	tbuf[t_in & TMASK] = c;
 431               	(193)
 432               		ld r24,Z
 433 019e E091 0000 		ori r24,lo8(32)
 434 01a2 F0E0      		st Z,r24
 436 01a6 F070      	.LM43:
 437 01a8 E050      		ldi r24,lo8(0)
 438 01aa F040      		ldi r25,hi8(0)
 439 01ac 1083      	/* epilogue start */
 260:ir_heat.c     **** 	t_in++;	
 440               		pop r28
 441               		pop r17
 442 01ae 8091 0000 		ret
 444 01b4 8093 0000 	.Lscope7:
 261:ir_heat.c     **** 	UCSR0B |= (1<<UDRIE0);			// Enable UDR empty interrupt	
 445               	bs	"rbuflen:F(0,2)",36,0,0,rbuflen
 446               	.global	rbuflen
 448 01ba F0E0      	rbuflen:
 450 01be 8062      	.LM44:
 451 01c0 8083      	.LFBB8:
 262:ir_heat.c     **** 	return(0);
 263:ir_heat.c     **** }
 452               	ogue: function */
 453               	/* frame size = 0 */
 455 01c4 90E0      	.LM45:
 456               		lds r24,r_in
 457 01c6 DF91      		lds r25,r_out
 459 01ca 1F91      	.LM46:
 460 01cc 0895      		sub r24,r25
 461               	/* epilogue start */
 462               		ret
 464               	.Lscope8:
 264:ir_heat.c     **** 
 265:ir_heat.c     **** char rbuflen(void) {
 467               	tchar
 469               	UART_getchar:
 471               	.LM47:
 266:ir_heat.c     **** // ***************
 267:ir_heat.c     **** // Retrive pending chars in RX buffer
 268:ir_heat.c     **** //
 269:ir_heat.c     **** 	return(r_in - r_out);
 472               	9:
 473               	/* prologue: function */
 474 01ce 8091 0000 	/* frame size = 0 */
 475 01d2 9091 0000 	.L26:
 270:ir_heat.c     **** }
 476               	abn	68,0,278,.LM48-.LFBB9
 477               	.LM48:
 478 01d6 891B      		call rbuflen
 479               		tst r24
 480 01d8 0895      		breq .L26
 482               	.LM49:
 483               		lds r30,r_out
 484               		ldi r31,lo8(0)
 485               		andi r30,lo8(31)
 486               		andi r31,hi8(31)
 487               		subi r30,lo8(-(rbuf))
 271:ir_heat.c     **** 
 272:ir_heat.c     **** int UART_getchar(FILE *stream) {
 488               	8(-(rbuf))
 489               		ld r24,Z
 491               	.LM50:
 492               		lds r25,r_out
 493               		subi r25,lo8(-(1))
 273:ir_heat.c     **** //*******************
 274:ir_heat.c     **** // Retieves character from UART. This function is to be passed
 275:ir_heat.c     **** // to fdevopen
 276:ir_heat.c     **** //
 277:ir_heat.c     **** 	unsigned char c;
 278:ir_heat.c     **** 	while(rbuflen() == 0);	  // Wait...
 494               	_out,r25
 496 01da 0E94 0000 	.LM51:
 497 01de 8823      		ldi r25,lo8(0)
 498 01e0 01F0      	/* epilogue start */
 279:ir_heat.c     **** 	c = rbuf[r_out & RMASK];
 503 01e8 EF71      	.Lscope9:
 506 01ee F040      	.global	exp_slope
 280:ir_heat.c     **** 	r_out++;	
 508               	:
 510 01f2 9091 0000 	.LM52:
 511 01f6 9F5F      	.LFBB10:
 512 01f8 9093 0000 	/* prologue: function */
 281:ir_heat.c     **** 	return(c);
 282:ir_heat.c     **** }
 513               	ame size = 0 */
 515 01fc 90E0      	.LM53:
 516               		clr r18
 517 01fe 0895      		clr r19
 518               		sub r18,r24
 519               		sbc r19,r25
 520               		brpl .L30
 521               		subi r18,lo8(-(15))
 522               		sbci r19,hi8(-(15))
 523               	.L30:
 524               		movw r24,r18
 525               		asr r25
 526               		ror r24
 527               		asr r25
 283:ir_heat.c     **** 
 284:ir_heat.c     **** void UART_first_init(void) {
 285:ir_heat.c     **** //***********************
 286:ir_heat.c     **** // The function fdevopen(..) must contain as parameters the
 287:ir_heat.c     **** // corresponding  ..putchar() and  ..getchar() functions, defined before.
 288:ir_heat.c     **** //
 289:ir_heat.c     **** 	UBRR0 = 12;										 		// 4800 BPS
 290:ir_heat.c     **** 	
 291:ir_heat.c     **** 	//UCSR0A |= (1<<U2X0);
 292:ir_heat.c     **** 	UCSR0B = (1<<RXCIE0)|(1<<TXEN0)|(1<<RXEN0);	// 8 Databits, receive and transmit enabled, receive a
 293:ir_heat.c     **** 	UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
 294:ir_heat.c     **** 	
 295:ir_heat.c     **** 	fdevopen(UART_putchar, UART_getchar);
 296:ir_heat.c     **** 	sei();											 		// Global interrupt enable
 297:ir_heat.c     **** }
 298:ir_heat.c     **** 
 299:ir_heat.c     **** 
 300:ir_heat.c     **** 
 301:ir_heat.c     **** 
 302:ir_heat.c     **** int16_t exp_slope(int16_t temp) {
 528               	25
 529               		ror r24
 530               		asr r25
 531               		ror r24
 532               		movw r18,r24
 533               		lsl r18
 534               		rol r19
 535 0200 2227      		lsl r24
 536 0202 3327      		rol r25
 537 0204 281B      		lsl r24
 538 0206 390B      		rol r25
 539 0208 02F4      		lsl r24
 540 020a 215F      		rol r25
 541 020c 3F4F      		add r18,r24
 542               		adc r19,r25
 543 020e C901      		subi r18,lo8(-(335))
 544 0210 9595      		sbci r19,hi8(-(335))
 546 0214 9595      	.LM54:
 547 0216 8795      		mov r24,r18
 548 0218 9595      		mov r25,r19
 549 021a 8795      	/* epilogue start */
 550 021c 9595      		ret
 552 0220 9C01      	.Lscope10:
 554 0224 331F      	.global	get_slope2
 556 0228 991F      	get_slope2:
 558 022c 991F      	.LM55:
 559 022e 880F      	.LFBB11:
 560 0230 991F      	/* prologue: function */
 561 0232 280F      	/* frame size = 0 */
 563 0236 215B      	.LM56:
 564 0238 3E4F      		lds r24,t_array+10
 303:ir_heat.c     **** 	return 10 * (-temp/16 + 32) + 15;
 304:ir_heat.c     **** }
 565               	ray+4
 566               		lds r19,(t_array+4)+1
 567 023a 822F      		sub r24,r18
 568 023c 932F      		sbc r25,r19
 569               		lsl r24
 570 023e 0895      		rol r25
 571               		lsl r24
 572               		rol r25
 573               		lsl r24
 574               		rol r25
 575               		lds r18,last_slope.1889
 576               		lds r19,(last_slope.1889)+1
 305:ir_heat.c     **** 
 306:ir_heat.c     **** 
 307:ir_heat.c     **** int16_t get_slope2() {
 577               	
 578               		adc r25,r19
 579               		lsl r24
 580               		rol r25
 581               		ldi r22,lo8(3)
 308:ir_heat.c     **** 	static int16_t last_slope = 0;
 309:ir_heat.c     **** //	last_slope = (200*(t_array[5]-t_array[2]) / 16 +  2*last_slope) / 3;
 310:ir_heat.c     **** 	last_slope = (16*(t_array[5]-t_array[2]) +  2*last_slope) / 3;
 582               	 r23,hi8(3)
 583               		call __divmodhi4
 584 0240 8091 0000 		mov r24,r22
 585 0244 9091 0000 		mov r25,r23
 586 0248 2091 0000 		sts last_slope.1889,r22
 587 024c 3091 0000 		sts last_slope.1889+1,r23
 588 0250 821B      	/* epilogue start */
 590 0254 880F      	.LM57:
 591 0256 991F      		ret
 596 0260 2091 0000 	.Lscope11:
 598 0268 820F      	.global	add_value
 600 026c 880F      	add_value:
 602 0270 63E0      	.LM58:
 603 0272 70E0      	.LFBB12:
 604 0274 0E94 0000 	/* prologue: function */
 605 0278 862F      	/* frame size = 0 */
 606 027a 972F      		mov r20,r24
 607 027c 6093 0000 		mov r21,r25
 609               	.LM59:
 311:ir_heat.c     **** 	return last_slope;
 312:ir_heat.c     **** }
 610               	_array)+1
 611               		or r24,r25
 612 0284 0895      		brne .L35
 614               	.LM60:
 615               		ldi r30,lo8(t_array+10)
 616               		ldi r31,hi8(t_array+10)
 617               		st Z,r20
 618               		std Z+1,r21
 619               		movw r26,r30
 620               		sbiw r26,2
 621               		st X,r20
 313:ir_heat.c     **** 
 314:ir_heat.c     **** 
 315:ir_heat.c     **** 
 316:ir_heat.c     **** 
 317:ir_heat.c     **** //*********************************************
 318:ir_heat.c     **** //
 319:ir_heat.c     **** // Gibt den Temperatur Ringspeicher
 320:ir_heat.c     **** // über den UART aus
 321:ir_heat.c     **** //
 322:ir_heat.c     **** void print_array(){
 323:ir_heat.c     **** 	uint8_t i;
 324:ir_heat.c     ****   	printf("Array:");
 325:ir_heat.c     **** 	for(i=0;i<6;i++) {
 326:ir_heat.c     ****    	printf(" %i", t_array[i]);
 327:ir_heat.c     **** 	}
 328:ir_heat.c     ****   	printf("\n");
 329:ir_heat.c     **** }
 330:ir_heat.c     **** 
 331:ir_heat.c     **** 
 332:ir_heat.c     **** 
 333:ir_heat.c     **** //*********************************************
 334:ir_heat.c     **** //
 335:ir_heat.c     **** // Fügt einen Meßwert zum Ringspeicher hinzu
 336:ir_heat.c     **** // Der Ringspeicher enthält die letzten 6 Werte
 337:ir_heat.c     **** // t_array[5] ist der neuste Wert
 338:ir_heat.c     **** //
 339:ir_heat.c     **** void add_value(uint16_t value) {
 622               		st X,r21
 623               		movw r26,r30
 624               		sbiw r26,4
 625               		st X,r20
 626               		adiw r26,1
 627 0286 482F      		st X,r21
 628 0288 592F      		movw r26,r30
 340:ir_heat.c     **** 	uint8_t i;
 341:ir_heat.c     **** 	if(t_array[0]==0) {
 629               	26,6
 630               		st X,r20
 631 028a 8091 0000 		adiw r26,1
 632 028e 9091 0000 		st X,r21
 633 0292 892B      		movw r26,r30
 634 0294 01F4      		sbiw r26,8
 342:ir_heat.c     **** 		t_array[0]=t_array[1]=t_array[2]=t_array[3]=t_array[4]=t_array[5]=value;
 635               	r20
 636               		adiw r26,1
 637 0296 E0E0      		st X,r21
 638 0298 F0E0      		sbiw r30,10
 639 029a 4083      		st Z,r20
 640 029c 5183      		std Z+1,r21
 641 029e DF01      		ret
 642 02a0 1297      	.L35:
 643 02a2 4C93      		ldi r30,lo8(t_array)
 644 02a4 1196      		ldi r31,hi8(t_array)
 646 02a8 DF01      	.LM61:
 647 02aa 1497      		ldi r18,lo8(t_array+10)
 648 02ac 4C93      		ldi r19,hi8(t_array+10)
 649 02ae 1196      	.L37:
 651 02b2 DF01      	.LM62:
 652 02b4 1697      		ldd r24,Z+2
 653 02b6 4C93      		ldd r25,Z+3
 654 02b8 1196      		st Z+,r24
 655 02ba 5C93      		st Z+,r25
 657 02be 1897      	.LM63:
 658 02c0 4C93      		cp r30,r18
 659 02c2 1196      		cpc r31,r19
 660 02c4 5C93      		brne .L37
 662 02c8 4083      	.LM64:
 663 02ca 5183      		mov r18,r20
 664 02cc 0895      		mov r19,r21
 665               		sts (t_array+10)+1,r19
 666 02ce E0E0      		sts t_array+10,r18
 343:ir_heat.c     **** 	}
 344:ir_heat.c     **** 	else {
 345:ir_heat.c     **** 		for(i=0;i<5;i++) {
 668               	5,(t_array+8)+1
 669               		sub r18,r24
 670 02d2 20E0      		sbc r19,r25
 671 02d4 30E0      		movw r24,r18
 672               		lsl r24
 346:ir_heat.c     **** 			t_array[i]=t_array[i+1];
 673               	r25
 674               		lsl r18
 675 02d6 8281      		rol r19
 676 02d8 9381      		lsl r18
 677 02da 8193      		rol r19
 678 02dc 9193      		lsl r18
 679               		rol r19
 680               		add r24,r18
 681 02de E217      		adc r25,r19
 682 02e0 F307      		lds r22,slope2
 683 02e2 01F4      		lds r23,(slope2)+1
 347:ir_heat.c     **** 		}
 348:ir_heat.c     **** 		t_array[5] = value;
 684               	22
 685               		lsl r18
 686 02e4 242F      		rol r19
 687 02e6 352F      		movw r20,r18
 688 02e8 3093 0000 		lsl r20
 689 02ec 2093 0000 		rol r21
 349:ir_heat.c     **** 		slope2 = (10*(t_array[5]-t_array[4]) + 19*slope2) / 20;
 690               	20
 691               		rol r21
 692 02f0 8091 0000 		lsl r20
 693 02f4 9091 0000 		rol r21
 694 02f8 281B      		add r18,r20
 695 02fa 390B      		adc r19,r21
 696 02fc C901      		add r18,r22
 697 02fe 880F      		adc r19,r23
 698 0300 991F      		add r24,r18
 699 0302 220F      		adc r25,r19
 700 0304 331F      		ldi r22,lo8(20)
 701 0306 220F      		ldi r23,hi8(20)
 702 0308 331F      		call __divmodhi4
 703 030a 220F      		sts (slope2)+1,r23
 704 030c 331F      		sts slope2,r22
 705 030e 820F      		ret
 707 0312 6091 0000 	.Lscope12:
 709 031a 9B01      	.global	get_slope
 711 031e 331F      	get_slope:
 713 0322 440F      	.LM66:
 714 0324 551F      	.LFBB13:
 715 0326 440F      	/* prologue: function */
 716 0328 551F      	/* frame size = 0 */
 718 032c 551F      	.LM67:
 719 032e 240F      		ldi r26,lo8(t_array+8)
 720 0330 351F      		ldi r27,hi8(t_array+8)
 721 0332 260F      		movw r30,r26
 722 0334 371F      		ld r18,Z+
 723 0336 820F      		ld r19,Z+
 724 0338 931F      		lds r24,t_array+2
 725 033a 64E1      		lds r25,(t_array+2)+1
 726 033c 70E0      		sub r18,r24
 727 033e 0E94 0000 		sbc r19,r25
 728 0342 7093 0000 		movw r24,r18
 729 0346 6093 0000 		lsl r24
 730 034a 0895      		rol r25
 731               		lsl r24
 732               		rol r25
 733               		add r24,r18
 734               		adc r25,r19
 735               		sbiw r26,8
 736               		ld r20,Z
 350:ir_heat.c     **** 	}
 351:ir_heat.c     **** }
 352:ir_heat.c     **** 
 353:ir_heat.c     **** 
 354:ir_heat.c     **** 
 355:ir_heat.c     **** //********************************************
 356:ir_heat.c     **** //
 357:ir_heat.c     **** // Gibt die gemittelte Steigung
 358:ir_heat.c     **** // über die letzten 4 Sekunden zurück
 359:ir_heat.c     **** //
 360:ir_heat.c     **** int16_t get_slope() {
 737               	sub r20,r18
 738               		sbc r21,r19
 739               		movw r18,r20
 740               		lsl r18
 741               		rol r19
 742               		add r18,r20
 743               		adc r19,r21
 744 034c A0E0      		add r24,r18
 745 034e B0E0      		adc r25,r19
 746 0350 FD01      		adiw r26,6
 747 0352 2191      		ld r20,X+
 748 0354 3191      		ld r21,X
 749 0356 8091 0000 		sbiw r26,6+1
 750 035a 9091 0000 		adiw r26,4
 751 035e 281B      		ld r18,X+
 752 0360 390B      		ld r19,X
 753 0362 C901      		sbiw r26,4+1
 754 0364 880F      		sub r20,r18
 755 0366 991F      		sbc r21,r19
 756 0368 880F      		movw r18,r20
 757 036a 991F      		lsl r18
 758 036c 820F      		rol r19
 759 036e 931F      		add r18,r20
 760 0370 1897      		adc r19,r21
 761 0372 4081      		movw r20,r18
 762 0374 5181      		lsl r20
 763 0376 2D91      		rol r21
 764 0378 3C91      		lsl r20
 765 037a 1197      		rol r21
 766 037c 421B      		add r18,r20
 767 037e 530B      		adc r19,r21
 768 0380 9A01      		add r24,r18
 769 0382 220F      		adc r25,r19
 770 0384 331F      		ldi r22,lo8(9)
 771 0386 240F      		ldi r23,hi8(9)
 772 0388 351F      		call __divmodhi4
 773 038a 820F      		mov r24,r22
 774 038c 931F      		mov r25,r23
 775 038e 1696      	/* epilogue start */
 777 0392 5C91      	.LM68:
 778 0394 1797      		ret
 780 0398 2D91      	.Lscope13:
 782 039c 1597      	.global	get_last_slope
 784 03a0 530B      	get_last_slope:
 786 03a4 220F      	.LM69:
 787 03a6 331F      	.LFBB14:
 788 03a8 240F      	/* prologue: function */
 789 03aa 351F      	/* frame size = 0 */
 791 03ae 440F      	.LM70:
 792 03b0 551F      		lds r18,t_array+10
 793 03b2 440F      		lds r19,(t_array+10)+1
 794 03b4 551F      		lds r24,t_array+8
 795 03b6 240F      		lds r25,(t_array+8)+1
 796 03b8 351F      		sub r18,r24
 797 03ba 820F      		sbc r19,r25
 799 03be 69E0      	.LM71:
 800 03c0 70E0      		mov r24,r18
 801 03c2 0E94 0000 		mov r25,r19
 802 03c6 862F      	/* epilogue start */
 803 03c8 972F      		ret
 361:ir_heat.c     **** 	int16_t s1, s2, s3;
 362:ir_heat.c     **** 
 363:ir_heat.c     **** 	s1 = t_array[5] - t_array[0];
 364:ir_heat.c     **** 	s2 = t_array[4] - t_array[1];
 365:ir_heat.c     **** 	s3 = t_array[3] - t_array[2];
 366:ir_heat.c     **** 	
 367:ir_heat.c     **** 	return ((3*s1+5*s2+15*s3)/9);
 368:ir_heat.c     **** }
 805               	:P(4,4)",64,0,0,24
 806               	.global	_beep
 808               	_beep:
 810               	.LM72:
 811               	.LFBB15:
 812               	/* prologue: function */
 813               	/* frame size = 0 */
 369:ir_heat.c     **** 
 370:ir_heat.c     **** 
 371:ir_heat.c     **** 
 372:ir_heat.c     **** //********************************************
 373:ir_heat.c     **** //
 374:ir_heat.c     **** // Gibt die aktuelle Steigung der Temperatur zurück
 375:ir_heat.c     **** // in 0.1°C in 4s
 376:ir_heat.c     **** //
 377:ir_heat.c     **** int16_t	get_last_slope() {
 814               	8,0,418,.LM73-.LFBB15
 815               	.LM73:
 816               		ldi r30,lo8(37)
 817               		ldi r31,hi8(37)
 818               		ld r18,Z
 819               		ori r18,lo8(-128)
 820               		st Z,r18
 822 03d0 3091 0000 	.LM74:
 823 03d4 8091 0000 		ldi r22,lo8(20)
 824 03d8 9091 0000 		ldi r23,hi8(20)
 825 03dc 281B      		call __udivmodhi4
 826 03de 390B      		mov r24,r22
 378:ir_heat.c     ****     return (t_array[5] - t_array[4]);
 379:ir_heat.c     **** }
 827               		sbiw r24,0
 828               		breq .L45
 829 03e0 822F      		ldi r18,lo8(0)
 830 03e2 932F      		ldi r19,hi8(0)
 831               	.LBB36:
 832 03e4 0895      	.LBB37:
 833               	.LBB38:
 834               	.LBB39:
 836               	.Ltext1:
 838               	.LM75:
 839               		ldi r20,lo8(5000)
 380:ir_heat.c     **** 
 381:ir_heat.c     **** 
 382:ir_heat.c     **** 
 383:ir_heat.c     **** //********************************************
 384:ir_heat.c     **** //
 385:ir_heat.c     **** // Liest die vom MLX90614 gemessene Temperatur aus
 386:ir_heat.c     **** // Rückgabe in 0.1°C, also 215 = 21.5°C
 387:ir_heat.c     **** //
 388:ir_heat.c     **** uint16_t get_temperature(uint8_t adr) {
 389:ir_heat.c     **** 	uint16_t raw;
 390:ir_heat.c     **** 	uint8_t 	ret;
 391:ir_heat.c     **** 	uint8_t 	lo, hi, pec;
 392:ir_heat.c     **** 	uint8_t	pec_read[6];
 393:ir_heat.c     **** 
 394:ir_heat.c     **** 	if(i2c_start(MLX90614_WRITE)) return DEFAULT_TEMP;
 395:ir_heat.c     **** 	if(i2c_write(adr)) return DEFAULT_TEMP;
 396:ir_heat.c     **** 	
 397:ir_heat.c     **** 	ret = i2c_rep_start(MLX90614_READ);
 398:ir_heat.c     **** 	if(ret) {
 399:ir_heat.c     **** 		i2c_rep_start(MLX90614_READ);
 400:ir_heat.c     ****    }
 401:ir_heat.c     **** 
 402:ir_heat.c     **** 	lo = i2c_read_ack();
 403:ir_heat.c     **** 	hi = i2c_read_ack();
 404:ir_heat.c     **** 	raw = (uint16_t)(hi<<8)+lo;
 405:ir_heat.c     **** 	pec = i2c_read_ack();
 406:ir_heat.c     **** 	
 407:ir_heat.c     **** 	i2c_stop();
 408:ir_heat.c     **** 	
 409:ir_heat.c     **** 	if(raw & 0x8000) return DEFAULT_TEMP;
 410:ir_heat.c     **** 	
 411:ir_heat.c     **** 	return (raw / 5 - 2731); 					// 1 = 0.1°C
 412:ir_heat.c     **** }
 413:ir_heat.c     **** 
 414:ir_heat.c     **** 
 415:ir_heat.c     **** 
 416:ir_heat.c     **** void _beep(uint16_t duration_ms){
 840               	5000)
 841               	.L46:
 842               		movw r30,r20
 843               	/* #APP */
 844               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 417:ir_heat.c     **** 	uint16_t i;
 418:ir_heat.c     **** 	BUZZER_ON;
 845               	biw r30,1
 846               		brne 1b
 847 03e6 E5E2      	 ;  0 "" 2
 848 03e8 F0E0      	/* #NOAPP */
 849 03ea 2081      	.LBE39:
 850 03ec 2068      	.LBE38:
 851 03ee 2083      	.LBE37:
 419:ir_heat.c     **** 	for(i=0;i<(duration_ms/20);i++) _delay_ms(20);
 852               	
 854 03f0 64E1      	.Ltext2:
 856 03f4 0E94 0000 	.LM76:
 857 03f8 862F      		subi r18,lo8(-(1))
 858 03fa 972F      		sbci r19,hi8(-(1))
 859 03fc 0097      		cp r18,r24
 860 03fe 01F0      		cpc r19,r25
 861 0400 20E0      		brlo .L46
 862 0402 30E0      	.L45:
 864               	.LM77:
 865               		ldi r30,lo8(37)
 866               		ldi r31,hi8(37)
 867               		ld r24,Z
 868               		andi r24,lo8(127)
   1:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   5:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
   8:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  11:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      distribution.
  15:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  16:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  20:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  32:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  34:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  37:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  39:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \file */
  40:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \code
  42:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     \endcode
  44:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  45:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  53:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  60:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  62:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  63:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  64:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** #endif
  68:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  69:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  71:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     register.
  76:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  77:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     can be achieved.
  79:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** */
  80:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
  81:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
  83:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	);
  89:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** }
  90:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  91:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  93:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     counter register pair.
  98:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 
  99:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h ****  */
 102:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** void
 103:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** {
 105:c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 869               	logue start */
 871 0404 48E8      	.LM78:
 872 0406 53E1      		ret
 877 040a 3197      	.Lscope15:
 878 040c 01F4      		.data
 879               	.LC0:
 880               		.string	">>> Relais ON"
 881               	.LC1:
 882               		.string	">>> Relais OFF"
 883               		.text
 886               	.global	set_relais
 888               	set_relais:
 890 0410 3F4F      	.LM79:
 891 0412 2817      	.LFBB16:
 892 0414 3907      		push r17
 893 0416 00F0      	/* prologue: function */
 894               	/* frame size = 0 */
 420:ir_heat.c     **** 	BUZZER_OFF;
 895               	459,.LM80-.LFBB16
 896               	.LM80:
 897 0418 E5E2      		tst r24
 898 041a F0E0      		breq .L50
 900 041e 8F77      	.LM81:
 901 0420 8083      		lds r24,last.2001
 902               		cp r17,r24
 421:ir_heat.c     **** }
 903               	51
 904               		ldi r24,lo8(.LC0)
 905 0422 0895      		ldi r25,hi8(.LC0)
 906               		call puts
 907               	.L51:
 909               	.LM82:
 910               		ldi r30,lo8(37)
 911               		ldi r31,hi8(37)
 912               		ld r24,Z
 913 0000 3E3E 3E20 		ori r24,lo8(64)
 913      5265 6C61 
 913      6973 204F 
 913      4E00 
 914               		st Z,r24
 915 000e 3E3E 3E20 		rjmp .L52
 915      5265 6C61 
 915      6973 204F 
 915      4646 00
 916               	.L50:
 918               	.LM83:
 919               		lds r24,last.2001
 920               		tst r24
 921               		breq .L53
 422:ir_heat.c     **** 
 423:ir_heat.c     **** 
 424:ir_heat.c     **** void	beep(uint8_t type){
 425:ir_heat.c     **** 	cli();
 426:ir_heat.c     **** 	wdt_reset();
 427:ir_heat.c     **** 	switch(type){
 428:ir_heat.c     **** 	case BEEP_SHORT:
 429:ir_heat.c     **** 		_beep(120);
 430:ir_heat.c     **** 		break;
 431:ir_heat.c     **** 	case BEEP_LONG:
 432:ir_heat.c     **** 		_beep(200);
 433:ir_heat.c     **** 		break;
 434:ir_heat.c     **** 	case BEEP_XLONG:
 435:ir_heat.c     **** 		_beep(850);
 436:ir_heat.c     **** 		break;
 437:ir_heat.c     **** 	case BEEP_2SHORT:
 438:ir_heat.c     **** 		_beep(80);
 439:ir_heat.c     **** 		_delay_ms(80);
 440:ir_heat.c     **** 		_beep(80);
 441:ir_heat.c     **** 		break;
 442:ir_heat.c     **** 	case BEEP_SHORT_LONG:
 443:ir_heat.c     **** 		_beep(100);
 444:ir_heat.c     **** 		_delay_ms(180);
 445:ir_heat.c     **** 		_beep(350);		
 446:ir_heat.c     **** 	}
 447:ir_heat.c     **** 	sei();	
 448:ir_heat.c     **** 	printf("Beep\n");
 449:ir_heat.c     **** }
 450:ir_heat.c     **** 
 451:ir_heat.c     **** 
 452:ir_heat.c     **** 
 453:ir_heat.c     **** //***************************************************
 454:ir_heat.c     **** //
 455:ir_heat.c     **** // Relais Ein- und Ausschalen
 456:ir_heat.c     **** //
 457:ir_heat.c     **** void set_relais(uint8_t on) {
 922               		ldi r25,hi8(.LC1)
 923               		call puts
 924               	.L53:
 926               	.LM84:
 927               		ldi r30,lo8(37)
 928 0426 182F      		ldi r31,hi8(37)
 458:ir_heat.c     **** 	static uint8_t last = 0;
 459:ir_heat.c     **** 	if(on) {
 929               	,Z
 930               		andi r24,lo8(-65)
 931 0428 8823      		st Z,r24
 932 042a 01F0      	.L52:
 460:ir_heat.c     **** 		if(on != last) printf(">>> Relais ON\n");
 933               	abn	68,0,467,.LM85-.LFBB16
 934               	.LM85:
 935 042c 8091 0000 		sts last.2001,r17
 936 0430 1817      	/* epilogue start */
 938 0434 80E0      	.LM86:
 939 0436 90E0      		pop r17
 940 0438 0E94 0000 		ret
 461:ir_heat.c     **** 		RELAIS_ON;
 942               	last:V(4,2)",38,0,0,last.2001
 945 043e F0E0      	.Lscope16:
 946 0440 8081      		.data
 947 0442 8064      	.LC2:
 948 0444 8083      		.string	"Beep"
 949 0446 00C0      		.text
 462:ir_heat.c     **** 	}
 463:ir_heat.c     **** 	else {
 464:ir_heat.c     **** 		if(on != last) printf(">>> Relais OFF\n");
 951               	type:P(4,2)",64,0,0,24
 952               	.global	beep
 954 044c 8823      	beep:
 956 0450 80E0      	.LM87:
 957 0452 90E0      	.LFBB17:
 958 0454 0E94 0000 	/* prologue: function */
 959               	/* frame size = 0 */
 465:ir_heat.c     **** 		RELAIS_OFF;
 960               	8,0,425,.LM88-.LFBB17
 961               	.LM88:
 962 0458 E5E2      	/* #APP */
 963 045a F0E0      	 ;  425 "ir_heat.c" 1
 964 045c 8081      		cli
 965 045e 8F7B      	 ;  0 "" 2
 967               	.LM89:
 466:ir_heat.c     **** 	}
 467:ir_heat.c     **** 	last = on;
 968               	"ir_heat.c" 1
 969               		wdr
 970 0462 1093 0000 	 ;  0 "" 2
 468:ir_heat.c     **** }
 972               	0:
 973               	/* #NOAPP */
 974 0466 1F91      		cpi r24,lo8(3)
 975 0468 0895      		breq .L59
 976               		cpi r24,lo8(4)
 977               		brsh .L62
 978               		cpi r24,lo8(1)
 979               		breq .L57
 980               		cpi r24,lo8(2)
 981               		brne .L56
 982               		rjmp .L64
 983 001d 4265 6570 	.L62:
 983      00
 984               		cpi r24,lo8(4)
 985               		breq .L60
 986               		cpi r24,lo8(6)
 987               		brne .L56
 988               		rjmp .L65
 989               	.L57:
 991               	.LM91:
 992               		ldi r24,lo8(120)
 993               		ldi r25,hi8(120)
 994               		call _beep
 995               		rjmp .L56
 996               	.L59:
 998               	.LM92:
 999 046a F894      		ldi r24,lo8(200)
 1000               		ldi r25,hi8(200)
 1001               		call _beep
 1002               		rjmp .L56
 1003               	.L60:
 1005               	.LM93:
 1006               		ldi r24,lo8(850)
 1007               		ldi r25,hi8(850)
 1008               		call _beep
 1009 046e 8330      		rjmp .L56
 1010 0470 01F0      	.L64:
 1012 0474 00F4      	.LM94:
 1013 0476 8130      		ldi r24,lo8(80)
 1014 0478 01F0      		ldi r25,hi8(80)
 1015 047a 8230      		call _beep
 1016 047c 01F4      	.LBB40:
 1017 047e 00C0      	.LBB41:
 1018               	.LBB42:
 1019 0480 8430      	.LBB43:
 1021 0484 8630      	.Ltext3:
 1023 0488 00C0      	.LM95:
 1024               		ldi r24,lo8(20000)
 1025               		ldi r25,hi8(20000)
 1026               	/* #APP */
 1027 048a 88E7      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1028 048c 90E0      		1: sbiw r24,1
 1029 048e 0E94 0000 		brne 1b
 1030 0492 00C0      	 ;  0 "" 2
 1031               	/* #NOAPP */
 1032               	.LBE43:
 1033               	.LBE42:
 1034 0494 88EC      	.LBE41:
 1035 0496 90E0      	.LBE40:
 1037 049c 00C0      	.Ltext4:
 1039               	.LM96:
 1040               		ldi r24,lo8(80)
 1041 049e 82E5      		ldi r25,hi8(80)
 1042 04a0 93E0      		call _beep
 1043 04a2 0E94 0000 		rjmp .L56
 1044 04a6 00C0      	.L65:
 1046               	.LM97:
 1047               		ldi r24,lo8(100)
 1048 04a8 80E5      		ldi r25,hi8(100)
 1049 04aa 90E0      		call _beep
 1050 04ac 0E94 0000 	.LBB44:
 1051               	.LBB45:
 1052               	.LBB46:
 1053               	.LBB47:
 1055               	.Ltext5:
 1057               	.LM98:
 1058               		ldi r24,lo8(-20536)
 1059 04b0 80E2      		ldi r25,hi8(-20536)
 1060 04b2 9EE4      	/* #APP */
 1061               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1062               		1: sbiw r24,1
 1063 04b4 0197      		brne 1b
 1064 04b6 01F4      	 ;  0 "" 2
 1065               	/* #NOAPP */
 1066               	.LBE47:
 1067               	.LBE46:
 1068               	.LBE45:
 1069               	.LBE44:
 1071               	.Ltext6:
 1073               	.LM99:
 1074               		ldi r24,lo8(350)
 1075 04b8 80E5      		ldi r25,hi8(350)
 1076 04ba 90E0      		call _beep
 1077 04bc 0E94 0000 	.L56:
 1079               	.LM100:
 1080               	/* #APP */
 1081               	 ;  447 "ir_heat.c" 1
 1082 04c2 84E6      		sei
 1083 04c4 90E0      	 ;  0 "" 2
 1085               	.LM101:
 1086               	/* #NOAPP */
 1087               		ldi r24,lo8(.LC2)
 1088               		ldi r25,hi8(.LC2)
 1089               		call puts
 1090               	/* epilogue start */
 1092               	.LM102:
 1093 04ca 88EC      		ret
 1095               	.Lscope17:
 1096               		.data
 1097 04ce 0197      	.LC3:
 1098 04d0 01F4      		.string	"Temperature Protection Off!"
 1099               	.LC4:
 1100               		.string	"\nxXx"
 1101               		.text
 1103               	.global	__vector_1
 1105               	__vector_1:
 1107               	.LM103:
 1108               	.LFBB18:
 1109 04d2 8EE5      		push __zero_reg__
 1110 04d4 91E0      		push r0
 1111 04d6 0E94 0000 		in r0,__SREG__
 1112               		push r0
 1113               		clr __zero_reg__
 1114               		push r18
 1115               		push r19
 1116               		push r20
 1117 04da 7894      		push r21
 1118               		push r22
 1119               		push r23
 1120               		push r24
 1121               		push r25
 1122 04dc 80E0      		push r26
 1123 04de 90E0      		push r27
 1124 04e0 0E94 0000 		push r30
 1125               		push r31
 1126               	/* prologue: Signal */
 1127               	/* frame size = 0 */
 1129               	.LM104:
 1130               		lds r24,133
 1131               		lds r18,132
 1132               		lds r25,running.1757
 1133 0022 5465 6D70 		or r24,r25
 1133      6572 6174 
 1133      7572 6520 
 1133      5072 6F74 
 1133      6563 7469 
 1134               		or r24,r18
 1135 003e 0A78 5878 		breq .+2
 1135      00
 1136               		rjmp .L77
 1138               	.LM105:
 1139               		ldi r24,lo8(1)
 1140               		sts running.1757,r24
 1142               	.LM106:
 1143               	/* #APP */
 1144 04e6 1F92      	 ;  164 "ir_heat.c" 1
 1145 04e8 0F92      		wdr
 1146 04ea 0FB6      	 ;  0 "" 2
 1148 04ee 1124      	.LM107:
 1149 04f0 2F93      	/* #NOAPP */
 1150 04f2 3F93      		out 61-32,__zero_reg__
 1152 04f6 5F93      	.LM108:
 1153 04f8 6F93      	/* #APP */
 1154 04fa 7F93      	 ;  169 "ir_heat.c" 1
 1155 04fc 8F93      		sei
 1156 04fe 9F93      	 ;  0 "" 2
 1157 0500 AF93      	/* #NOAPP */
 1158 0502 BF93      		ldi r18,lo8(0)
 1159 0504 EF93      		ldi r19,hi8(0)
 1160 0506 FF93      		ldi r20,lo8(0)
 1161               		ldi r21,hi8(0)
 1163               	.LM109:
 1164               		ldi r30,lo8(41)
 1165 0508 8091 8500 		ldi r31,hi8(41)
 1166 050c 2091 8400 	.L69:
 1167 0510 9091 0000 		ld r24,Z
 1168 0514 892B      		sbrs r24,2
 1169 0516 822B      		rjmp .L68
 1170 0518 01F0      		subi r20,lo8(-(1))
 1171 051a 00C0      		sbci r21,hi8(-(1))
 1172               	.L68:
 1173               		subi r18,lo8(-(1))
 1174 051c 81E0      		sbci r19,hi8(-(1))
 1175 051e 8093 0000 		ldi r24,hi8(1000)
 1176               		cpi r18,lo8(1000)
 1177               		cpc r19,r24
 1178               		brne .L69
 1180 0522 A895      	.LM110:
 1181               		cpi r20,200
 1182               		cpc r21,__zero_reg__
 1183               		brlo .+2
 1184               		rjmp .L70
 1186               	.LM111:
 1187               		ldi r24,lo8(1)
 1188               		sts 132,r24
 1190 0526 7894      	.LM112:
 1191               		ldi r24,lo8(2)
 1192               		sts 129,r24
 1194 052a 30E0      	.LM113:
 1195 052c 40E0      		lds r24,mode
 1196 052e 50E0      		tst r24
 1197               		breq .+2
 1198               		rjmp .L80
 1200 0532 F0E0      	.LM114:
 1201               		ldi r24,lo8(1)
 1202 0534 8081      		sts mode,r24
 1204 0538 00C0      	.LM115:
 1205 053a 4F5F      		call set_relais
 1207               	.LM116:
 1208 053e 2F5F      		ldi r30,lo8(43)
 1209 0540 3F4F      		ldi r31,hi8(43)
 1210 0542 83E0      		ld r24,Z
 1211 0544 283E      		ori r24,lo8(16)
 1212 0546 3807      		st Z,r24
 1214               	.LM117:
 1215               		ld r24,Z
 1216 054a 483C      		ori r24,lo8(8)
 1217 054c 5105      		st Z,r24
 1219 0550 00C0      	.LM118:
 1220               		sbic 41-32,2
 1221               		rjmp .L73
 1222 0552 81E0      		ldi r18,lo8(0)
 1223 0554 8093 8400 		ldi r19,hi8(0)
 1224               	.LBB48:
 1225               	.LBB49:
 1226 0558 82E0      	.LBB50:
 1227 055a 8093 8100 	.LBB51:
 1229               	.Ltext7:
 1231 0562 8823      	.LM119:
 1232 0564 01F0      		ldi r20,lo8(2500)
 1233 0566 00C0      		ldi r21,hi8(2500)
 1234               	.LBE51:
 1235               	.LBE50:
 1236 0568 81E0      	.LBE49:
 1237 056a 8093 0000 	.LBE48:
 1239               	.Ltext8:
 1241               	.LM120:
 1242               		ldi r30,lo8(41)
 1243 0572 EBE2      		ldi r31,hi8(41)
 1244 0574 F0E0      	.L75:
 1246 0578 8061      	.LM121:
 1247 057a 8083      		subi r18,lo8(-(1))
 1248               		sbci r19,hi8(-(1))
 1249               	.LBB55:
 1250 057c 8081      	.LBB54:
 1251 057e 8860      	.LBB53:
 1252 0580 8083      	.LBB52:
 1254               	.Ltext9:
 1256 0584 00C0      	.LM122:
 1257 0586 20E0      		movw r24,r20
 1258 0588 30E0      	/* #APP */
 1259               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 1260               		1: sbiw r24,1
 1261               		brne 1b
 1262               	 ;  0 "" 2
 1263               	/* #NOAPP */
 1264               	.LBE52:
 1265               	.LBE53:
 1266               	.LBE54:
 1267 058a 44EC      	.LBE55:
 1269               	.Ltext10:
 1271               	.LM123:
 1272               		ld r24,Z
 1273               		sbrc r24,2
 1274               		rjmp .L74
 1275               		ldi r24,hi8(300)
 1276               		cpi r18,lo8(300)
 1277 058e E9E2      		cpc r19,r24
 1278 0590 F0E0      		brne .L75
 1279               		rjmp .L76
 1280               	.L74:
 1282 0592 2F5F      	.LM124:
 1283 0594 3F4F      		subi r18,lo8(300)
 1284               		sbci r19,hi8(300)
 1285               		brsh .L76
 1286               	.L73:
 1288               	.LM125:
 1289               		ldi r24,lo8(1)
 1290               		sts mode,r24
 1291               		rjmp .L70
 1292 0596 CA01      	.L76:
 1294               	.LM126:
 1295 0598 0197      		ldi r24,lo8(2)
 1296 059a 01F4      		sts mode,r24
 1298               	.LM127:
 1299               		ldi r24,lo8(.LC3)
 1300               		ldi r25,hi8(.LC3)
 1301               		call puts
 1303               	.LM128:
 1304               		ldi r30,lo8(43)
 1305               		ldi r31,hi8(43)
 1306               		ld r24,Z
 1307 059c 8081      		andi r24,lo8(-17)
 1308 059e 82FD      		st Z,r24
 1310 05a2 81E0      	.LM129:
 1311 05a4 2C32      		ld r24,Z
 1312 05a6 3807      		ori r24,lo8(8)
 1313 05a8 01F4      		st Z,r24
 1315               	.LM130:
 1316               		ldi r24,lo8(6)
 1317               		call beep
 1318 05ac 2C52      		rjmp .L70
 1319 05ae 3140      	.L80:
 1321               	.LM131:
 1322               		ldi r24,lo8(.LC4)
 1323               		ldi r25,hi8(.LC4)
 1324 05b2 81E0      		call puts
 1326 05b8 00C0      	.LM132:
 1327               		sts mode,__zero_reg__
 1328               	.L70:
 1330 05ba 82E0      	.LM133:
 1331 05bc 8093 0000 		ldi r24,lo8(1)
 1332               		out 60-32,r24
 1334 05c0 80E0      	.LM134:
 1335 05c2 90E0      		out 61-32,r24
 1337               	.LM135:
 1338               		sts running.1757,__zero_reg__
 1339 05c8 EBE2      	.L77:
 1340 05ca F0E0      	/* epilogue start */
 1342 05ce 8F7E      	.LM136:
 1343 05d0 8083      		pop r31
 1344               		pop r30
 1345               		pop r27
 1346 05d2 8081      		pop r26
 1347 05d4 8860      		pop r25
 1348 05d6 8083      		pop r24
 1349               		pop r23
 1350               		pop r22
 1351 05d8 86E0      		pop r21
 1352 05da 0E94 0000 		pop r20
 1353 05de 00C0      		pop r19
 1354               		pop r18
 1355               		pop r0
 1356               		out __SREG__,r0
 1357 05e0 80E0      		pop r0
 1358 05e2 90E0      		pop __zero_reg__
 1359 05e4 0E94 0000 		reti
 1366 05ec 81E0      	.Lscope18:
 1369               	.global	get_temperature
 1371               	get_temperature:
 1373 05f2 1092 0000 	.LM137:
 1374               	.LFBB19:
 1375               		push r17
 1376               		push r28
 1377               		push r29
 1378 05f6 FF91      	/* prologue: function */
 1379 05f8 EF91      	/* frame size = 0 */
 1380 05fa BF91      		mov r17,r24
 1382 05fe 9F91      	.LM138:
 1383 0600 8F91      		ldi r24,lo8(-76)
 1384 0602 7F91      		call i2c_start
 1385 0604 6F91      		tst r24
 1386 0606 5F91      		brne .L82
 1388 060a 3F91      	.LM139:
 1389 060c 2F91      		mov r24,r17
 1390 060e 0F90      		call i2c_write
 1391 0610 0FBE      		tst r24
 1392 0612 0F90      		brne .L82
 1394 0616 1895      	.LM140:
 1395               		ldi r24,lo8(-75)
 1396               		call i2c_rep_start
 1398               	.LM141:
 1399               		tst r24
 1400               		breq .L83
 1402               	.LM142:
 1403               		ldi r24,lo8(-75)
 1404               		call i2c_rep_start
 1405               	.L83:
 1407               	.LM143:
 1408               		call i2c_read_ack
 1409               		mov r17,r24
 1411 061a CF93      	.LM144:
 1412 061c DF93      		call i2c_read_ack
 1414               	.LM145:
 1415 061e 182F      		mov r19,r24
 1416               		ldi r18,lo8(0)
 1417               		movw r28,r18
 1418 0620 84EB      		add r28,r17
 1419 0622 0E94 0000 		adc r29,__zero_reg__
 1421 0628 01F4      	.LM146:
 1422               		call i2c_read_ack
 1424 062a 812F      	.LM147:
 1425 062c 0E94 0000 		call i2c_stop
 1427 0632 01F4      	.LM148:
 1428               		tst r29
 1429               		brlt .L82
 1431 0636 0E94 0000 	.LM149:
 1432               		movw r24,r28
 1433               		ldi r22,lo8(5)
 1434 063a 8823      		ldi r23,hi8(5)
 1435 063c 01F0      		call __udivmodhi4
 1436               		subi r22,lo8(-(-2731))
 1437               		sbci r23,hi8(-(-2731))
 1438 063e 85EB      		rjmp .L84
 1439 0640 0E94 0000 	.L82:
 1440               		ldi r22,lo8(150)
 1441               		ldi r23,hi8(150)
 1442               	.L84:
 1444 0648 182F      	.LM150:
 1445               		mov r24,r22
 1446               		mov r25,r23
 1447 064a 0E94 0000 	/* epilogue start */
 1448               		pop r29
 1449               		pop r28
 1450 064e 382F      		pop r17
 1451 0650 20E0      		ret
 1457 0658 0E94 0000 	.Lscope19:
 1458               		.data
 1459               	.LC5:
 1460 065c 0E94 0000 		.string	"Array:"
 1461               	.LC6:
 1462               		.string	" %i"
 1463 0660 DD23      		.text
 1465               	.global	print_array
 1467 0664 CE01      	print_array:
 1469 0668 70E0      	.LM151:
 1470 066a 0E94 0000 	.LFBB20:
 1471 066e 6B5A      		push r12
 1472 0670 7A40      		push r13
 1473 0672 00C0      		push r14
 1474               		push r15
 1475 0674 66E9      		push r16
 1476 0676 70E0      		push r17
 1477               	/* prologue: function */
 1478               	/* frame size = 0 */
 1480 0678 862F      	.LM152:
 1481 067a 972F      		rcall .
 1482               		ldi r24,lo8(.LC5)
 1483 067c DF91      		ldi r25,hi8(.LC5)
 1484 067e CF91      		in r26,__SP_L__
 1485 0680 1F91      		in r27,__SP_H__
 1486 0682 0895      		adiw r26,1+1
 1487               		st X,r25
 1488               		st -X,r24
 1489               		sbiw r26,1
 1490               		call printf
 1492               	.LM153:
 1493               		rcall .
 1494               		in r30,__SP_L__
 1495 0043 4172 7261 		in r31,__SP_H__
 1495      793A 00
 1496               		adiw r30,1
 1497 004a 2025 6900 		mov __tmp_reg__,r31
 1498               		ldi r31,lo8(.LC6)
 1499               		mov r14,r31
 1500               		ldi r31,hi8(.LC6)
 1501               		mov r15,r31
 1502               		mov r31,__tmp_reg__
 1503               		std Z+1,r15
 1504               		st Z,r14
 1505               		mov __tmp_reg__,r31
 1506 0684 CF92      		ldi r31,lo8(t_array)
 1507 0686 DF92      		mov r12,r31
 1508 0688 EF92      		ldi r31,hi8(t_array)
 1509 068a FF92      		mov r13,r31
 1510 068c 0F93      		mov r31,__tmp_reg__
 1511 068e 1F93      		movw r26,r12
 1512               		ld r24,X+
 1513               		ld r25,X+
 1514               		movw r16,r26
 1515               		std Z+3,r25
 1516 0690 00D0      		std Z+2,r24
 1517 0692 80E0      		call printf
 1518 0694 90E0      		in r30,__SP_L__
 1519 0696 ADB7      		in r31,__SP_H__
 1520 0698 BEB7      		adiw r30,1
 1521 069a 1296      		std Z+1,r15
 1522 069c 9C93      		st Z,r14
 1523 069e 8E93      		movw r26,r16
 1524 06a0 1197      		ld r24,X+
 1525 06a2 0E94 0000 		ld r25,X
 1526               		std Z+3,r25
 1527               		std Z+2,r24
 1528 06a6 00D0      		call printf
 1529 06a8 EDB7      		in r30,__SP_L__
 1530 06aa FEB7      		in r31,__SP_H__
 1531 06ac 3196      		adiw r30,1
 1532 06ae 0F2E      		std Z+1,r15
 1533 06b0 F0E0      		st Z,r14
 1534 06b2 EF2E      		movw r26,r12
 1535 06b4 F0E0      		adiw r26,4
 1536 06b6 FF2E      		ld r24,X+
 1537 06b8 F02D      		ld r25,X
 1538 06ba F182      		sbiw r26,4+1
 1539 06bc E082      		std Z+3,r25
 1540 06be 0F2E      		std Z+2,r24
 1541 06c0 F0E0      		call printf
 1542 06c2 CF2E      		in r30,__SP_L__
 1543 06c4 F0E0      		in r31,__SP_H__
 1544 06c6 DF2E      		adiw r30,1
 1545 06c8 F02D      		std Z+1,r15
 1546 06ca D601      		st Z,r14
 1547 06cc 8D91      		movw r26,r12
 1548 06ce 9D91      		adiw r26,6
 1549 06d0 8D01      		ld r24,X+
 1550 06d2 9383      		ld r25,X
 1551 06d4 8283      		sbiw r26,6+1
 1552 06d6 0E94 0000 		std Z+3,r25
 1553 06da EDB7      		std Z+2,r24
 1554 06dc FEB7      		call printf
 1555 06de 3196      		in r30,__SP_L__
 1556 06e0 F182      		in r31,__SP_H__
 1557 06e2 E082      		adiw r30,1
 1558 06e4 D801      		std Z+1,r15
 1559 06e6 8D91      		st Z,r14
 1560 06e8 9C91      		movw r26,r12
 1561 06ea 9383      		adiw r26,8
 1562 06ec 8283      		ld r24,X+
 1563 06ee 0E94 0000 		ld r25,X
 1564 06f2 EDB7      		sbiw r26,8+1
 1565 06f4 FEB7      		std Z+3,r25
 1566 06f6 3196      		std Z+2,r24
 1567 06f8 F182      		call printf
 1568 06fa E082      		in r30,__SP_L__
 1569 06fc D601      		in r31,__SP_H__
 1570 06fe 1496      		adiw r30,1
 1571 0700 8D91      		std Z+1,r15
 1572 0702 9C91      		st Z,r14
 1573 0704 1597      		movw r26,r12
 1574 0706 9383      		adiw r26,10
 1575 0708 8283      		ld r24,X+
 1576 070a 0E94 0000 		ld r25,X
 1577 070e EDB7      		sbiw r26,10+1
 1578 0710 FEB7      		std Z+3,r25
 1579 0712 3196      		std Z+2,r24
 1580 0714 F182      		call printf
 1582 0718 D601      	.LM154:
 1583 071a 1696      		pop __tmp_reg__
 1584 071c 8D91      		pop __tmp_reg__
 1585 071e 9C91      		pop __tmp_reg__
 1586 0720 1797      		pop __tmp_reg__
 1587 0722 9383      		ldi r24,lo8(10)
 1588 0724 8283      		ldi r25,hi8(10)
 1589 0726 0E94 0000 		call putchar
 1590 072a EDB7      	/* epilogue start */
 1592 072e 3196      	.LM155:
 1593 0730 F182      		pop r17
 1594 0732 E082      		pop r16
 1595 0734 D601      		pop r15
 1596 0736 1896      		pop r14
 1597 0738 8D91      		pop r13
 1598 073a 9C91      		pop r12
 1599 073c 1997      		ret
 1601 0740 8283      	.Lscope20:
 1603 0746 EDB7      	.global	UART_first_init
 1605 074a 3196      	UART_first_init:
 1607 074e E082      	.LM156:
 1608 0750 D601      	.LFBB21:
 1609 0752 1A96      	/* prologue: function */
 1610 0754 8D91      	/* frame size = 0 */
 1612 0758 1B97      	.LM157:
 1613 075a 9383      		ldi r24,lo8(12)
 1614 075c 8283      		ldi r25,hi8(12)
 1615 075e 0E94 0000 		sts (196)+1,r25
 1616               		sts 196,r24
 1618 0762 0F90      	.LM158:
 1619 0764 0F90      		ldi r24,lo8(-104)
 1620 0766 0F90      		sts 193,r24
 1622 076a 8AE0      	.LM159:
 1623 076c 90E0      		ldi r24,lo8(6)
 1624 076e 0E94 0000 		sts 194,r24
 1626               	.LM160:
 1627               		ldi r24,lo8(gs(UART_putchar))
 1628 0772 1F91      		ldi r25,hi8(gs(UART_putchar))
 1629 0774 0F91      		ldi r22,lo8(gs(UART_getchar))
 1630 0776 FF90      		ldi r23,hi8(gs(UART_getchar))
 1631 0778 EF90      		call fdevopen
 1633 077c CF90      	.LM161:
 1634 077e 0895      	/* #APP */
 1635               	 ;  296 "ir_heat.c" 1
 1636               		sei
 1637               	 ;  0 "" 2
 1638               	/* epilogue start */
 1640               	.LM162:
 1641               	/* #NOAPP */
 1642               		ret
 1644               	.Lscope21:
 1645               		.data
 1646               	.LC7:
 1647               		.string	"\n\nStart\n"
 1648 0780 8CE0      	.LC8:
 1649 0782 90E0      		.string	"Error Temp=0"
 1650 0784 9093 C500 	.LC9:
 1651 0788 8093 C400 		.string	"Startup %i "
 1652               	.LC10:
 1653               		.string	"Temp: %i, "
 1654 078c 88E9      	.LC11:
 1655 078e 8093 C100 		.string	"exp_s: %i, s2: %i, bc: %i, fx: %i\n"
 1656               	.LC12:
 1657               		.string	"On-Counter: %i; \n"
 1658 0792 86E0      	.LC13:
 1659 0794 8093 C200 		.string	"Off-Counter: %i; \n"
 1660               		.text
 1662 0798 80E0      	.global	main
 1664 079c 60E0      	main:
 1666 07a0 0E94 0000 	.LM163:
 1667               	.LFBB22:
 1668               		push r2
 1669               		push r3
 1670               		push r4
 1671 07a4 7894      		push r5
 1672               		push r6
 1673               		push r7
 1674               		push r8
 1675               		push r9
 1676               		push r10
 1677 07a6 0895      		push r11
 1678               		push r12
 1679               		push r13
 1680               		push r14
 1681               		push r15
 1682 004e 0A0A 5374 		push r16
 1682      6172 740A 
 1682      00
 1683               		push r17
 1684 0057 4572 726F 		push r29
 1684      7220 5465 
 1684      6D70 3D30 
 1684      00
 1685               		push r28
 1686 0064 5374 6172 		rcall .
 1686      7475 7020 
 1686      2569 2000 
 1687               		push __tmp_reg__
 1688 0070 5465 6D70 		in r28,__SP_L__
 1688      3A20 2569 
 1688      2C20 00
 1689               		in r29,__SP_H__
 1690 007b 6578 705F 	/* prologue: function */
 1690      733A 2025 
 1690      692C 2073 
 1690      323A 2025 
 1690      692C 2062 
 1691               	/* frame size = 3 */
 1693               	.LM164:
 1694 00b0 4F66 662D 		ldi r24,lo8(-64)
 1694      436F 756E 
 1694      7465 723A 
 1694      2025 693B 
 1694      200A 00
 1695               		out 36-32,r24
 1697               	.LM165:
 1698               		ldi r24,lo8(8)
 1699               		out 39-32,r24
 469:ir_heat.c     **** 
 470:ir_heat.c     **** 
 471:ir_heat.c     **** 
 472:ir_heat.c     **** 
 473:ir_heat.c     **** // ***********************************************************
 474:ir_heat.c     **** // Main program
 475:ir_heat.c     **** //
 476:ir_heat.c     **** int main(void) {
 1700               	,.LM169-.LFBB22
 1701               	.LM169:
 1702               		ldi r16,lo8(43)
 1703 07a8 2F92      		ldi r17,hi8(43)
 1704 07aa 3F92      		ldi r24,lo8(-25)
 1705 07ac 4F92      		movw r30,r16
 1706 07ae 5F92      		st Z,r24
 1708 07b2 7F92      	.LM170:
 1709 07b4 8F92      		lds r24,100
 1711 07b8 AF92      	.LM171:
 1712 07ba BF92      	/* #APP */
 1713 07bc CF92      	 ;  491 "ir_heat.c" 1
 1714 07be DF92      		wdr
 1715 07c0 EF92      	 ;  0 "" 2
 1717 07c4 0F93      	.LM172:
 1718 07c6 1F93      	/* #NOAPP */
 1719 07c8 DF93      		ldi r18,lo8(41)
 1720 07ca CF93      		ldi r24,lo8(24)
 1721 07cc 00D0      		ldi r25,hi8(24)
 1722 07ce 0F92      	/* #APP */
 1723 07d0 CDB7      	 ;  492 "ir_heat.c" 1
 1724 07d2 DEB7      		in __tmp_reg__,__SREG__
 1725               		cli
 1726               		wdr
 477:ir_heat.c     ****    // Ausgänge definieren
 478:ir_heat.c     **** 	DDRB = 0x00 | (1<<RELAIS) | (1<<BUZZER);
 1727               	_tmp_reg__
 1728               		sts 96,r18
 1729 07d4 80EC      		
 1730 07d6 84B9      	 ;  0 "" 2
 479:ir_heat.c     **** 	DDRC = 0x00 | (1<<FLASH_LED);
 1731               	abn	68,0,495,.LM173-.LFBB22
 1732               	.LM173:
 1733 07d8 88E0      	/* #NOAPP */
 1734 07da 87B9      		ldi r30,lo8(97)
 480:ir_heat.c     **** 	DDRD = 0x00 | (1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED);
 1735               	 r31,hi8(97)
 1736               		ldi r24,lo8(-128)
 1737 07dc 88E1      		st Z,r24
 481:ir_heat.c     **** 
 482:ir_heat.c     **** 	// Ausgänge ausschalten
 483:ir_heat.c     **** 	PORTB = ~((1<<RELAIS) | (1<<BUZZER));
 1739               	74:
 1740               		clr r15
 1741 07e0 8FE3      		set
 1742 07e2 85B9      		bld r15,1
 484:ir_heat.c     **** 	PORTC = ~(1<<FLASH_LED);
 1743               	Z,r15
 1745 07e4 87EF      	.LM175:
 1746 07e6 88B9      		call UART_first_init
 485:ir_heat.c     **** 	PORTD = ~((1<<STATUS_LED1) | (1<<STATUS_LED2) | (1<<FLASH_LED));
 1747               	abn	68,0,500,.LM176-.LFBB22
 1748               	.LM176:
 1749 07e8 0BE2      		call i2c_init
 1751 07ec 87EE      	.LM177:
 1752 07ee F801      		sts interval,__zero_reg__
 486:ir_heat.c     **** 
 487:ir_heat.c     **** 	// TWI aus Energiesparmode rausnehmen
 488:ir_heat.c     **** 	PRR != ~(1<<PRTWI);
 1754               	
 1755               		ldi r24,lo8(7)
 1756 07f2 8091 6400 		sts 177,r24
 489:ir_heat.c     **** 
 490:ir_heat.c     **** 	// Whatchdog initialisieren
 491:ir_heat.c     **** 	wdt_reset();
 1757               	stabn	68,0,506,.LM179-.LFBB22
 1758               	.LM179:
 1759               		ldi r25,lo8(1)
 1760               		sts 112,r25
 1762               	.LM180:
 492:ir_heat.c     **** 	wdt_enable(WDTO_8S);
 1763               	8-32,__zero_reg__
 1765               	.LM181:
 1766 07f8 29E2      		ldi r24,lo8(3)
 1767 07fa 88E1      		out 69-32,r24
 1769               	.LM182:
 1770               		sts 110,r25
 1772 0800 F894      	.LM183:
 1773 0802 A895      		sts 128,__zero_reg__
 1775 0808 0FBE      	.LM184:
 1776 080a 2093 6000 		sts 129,__zero_reg__
 1778               	.LM185:
 493:ir_heat.c     **** 	
 494:ir_heat.c     **** 	// Set clock divider to 4 => 2MHz
 495:ir_heat.c     **** 	CLKPR = (1<<CLKPCE);
 1779               	reg__
 1781               	.LM186:
 1782 080e E1E6      		sts 111,r25
 1784 0812 80E8      	.LM187:
 1785 0814 8083      		sts 105,r15
 496:ir_heat.c     **** 	CLKPR = (0<<CLKPS3) | (0<<CLKPS2) | (1<<CLKPS1) | (0<<CLKPS0);
 1786               		68,0,521,.LM188-.LFBB22
 1787               	.LM188:
 1788 0816 FF24      		out 61-32,r25
 1790 081a F1F8      	.LM189:
 1791 081c F082      		ldi r24,lo8(.LC7)
 497:ir_heat.c     **** 	
 498:ir_heat.c     **** 	// UART initialisieren
 499:ir_heat.c     **** 	UART_first_init();
 1792               	25,hi8(.LC7)
 1793               		call puts
 500:ir_heat.c     **** 	i2c_init();
 1795               	190:
 1796               		movw r30,r16
 1797 0822 0E94 0000 		ld r24,Z
 501:ir_heat.c     **** 	
 502:ir_heat.c     **** 	interval=0;
 1798               	i r24,lo8(16)
 1799               		st Z,r24
 503:ir_heat.c     **** 	
 504:ir_heat.c     **** 	// Timer 2 initialisieren (RTC)
 505:ir_heat.c     ****    TCCR2B = (1<<CS22) | (1<<CS21) | (1<<CS20);	// clk/256
 1801               	191:
 1802               		ld r24,Z
 1803 082a 87E0      		andi r24,lo8(-9)
 1804 082c 8093 B100 		st Z,r24
 506:ir_heat.c     ****    TIMSK2 = (1<<TOIE2);
 1805               	abn	68,0,527,.LM192-.LFBB22
 1806               	.LM192:
 1807 0830 91E0      		ldi r24,lo8(0)
 1808 0832 9093 7000 		call set_relais
 507:ir_heat.c     **** 
 508:ir_heat.c     ****  	// Timer 0 initialisieren (Blinken)
 509:ir_heat.c     **** 	TCCR0A = 0;
 1809               	abn	68,0,528,.LM193-.LFBB22
 1810               	.LM193:
 1811 0836 14BC      		sts mode,__zero_reg__
 510:ir_heat.c     **** 	TCCR0B = (0<<CS02) | (1<<CS01) | (1<<CS00);
 1812               	tabn	68,0,549,.LM194-.LFBB22
 1813               	.LM194:
 1814 0838 83E0      	/* #APP */
 1815 083a 85BD      	 ;  549 "ir_heat.c" 1
 511:ir_heat.c     **** 	TIMSK0 = (1<<TOIE0);
 1816               	
 1817               	 ;  0 "" 2
 1818 083c 9093 6E00 	/* #NOAPP */
 512:ir_heat.c     **** 	
 513:ir_heat.c     **** 	// Timer 1 initialisieren (Entprellen?)
 514:ir_heat.c     **** 	TCCR1A = 0;
 1819               	lr r14
 1820               		clr r15
 1821 0840 1092 8000 		ldi r16,lo8(0)
 515:ir_heat.c     **** 	TIMER1_STOP;
 1822               	i r31,lo8(-1)
 1823               		std Y+1,r31
 1824 0844 1092 8100 		mov __tmp_reg__,r31
 516:ir_heat.c     **** 	TCCR1C = 0;
 1825               	i r31,lo8(3)
 1826               		mov r6,r31
 1827 0848 1092 8200 		mov r31,__tmp_reg__
 517:ir_heat.c     **** 	TIMSK1 = (1<<TOIE1);
 1828               	r r10
 1829               		clr r11
 1830 084c 9093 6F00 		clr r7
 518:ir_heat.c     **** 	
 519:ir_heat.c     **** 	// Interrupt für Taster initialisieren
 520:ir_heat.c     **** 	EICRA = (1<<ISC01);
 1831               	tabn	68,0,704,.LM195-.LFBB22
 1832               	.LM195:
 1833 0850 F092 6900 		mov __tmp_reg__,r31
 521:ir_heat.c     **** 	EIMSK = (1<<INT0);
 1834               	i r31,lo8(43)
 1835               		mov r12,r31
 1836 0854 9DBB      		clr r13
 522:ir_heat.c     **** 	
 523:ir_heat.c     **** 
 524:ir_heat.c     **** 	printf("\n\nStart\n\n");
 1837               	v r31,__tmp_reg__
 1839 0856 80E0      	.LM196:
 1840 0858 90E0      		clr r2
 1841 085a 0E94 0000 		clr r3
 525:ir_heat.c     **** 	STATUS_LED1_ON;		// grüne LED ein
 1842               	6:
 1843               	.LBB57:
 1844 085e F801      	.LBB58:
 1845 0860 8081      	.LBB59:
 1847 0864 8083      	.Ltext11:
 526:ir_heat.c     **** 	STATUS_LED2_OFF;		// rote LED aus
 1848               	n	68,0,105,.LM197-.LFBB22
 1849               	.LM197:
 1850 0866 8081      		mov __tmp_reg__,r31
 1851 0868 877F      		ldi r31,lo8(25000)
 1852 086a 8083      		mov r4,r31
 527:ir_heat.c     **** 	set_relais(0);			// Relais aus
 1853               	r31,hi8(25000)
 1854               		mov r5,r31
 1855 086c 80E0      		mov r31,__tmp_reg__
 1856 086e 0E94 0000 	.L117:
 528:ir_heat.c     **** 	mode = MODE_OFF;
 1857               	59:
 1858               	.LBE58:
 1859 0872 1092 0000 	.LBE57:
 529:ir_heat.c     **** 	
 530:ir_heat.c     **** //	int16_t temp, temp_sum, temp_a;
 531:ir_heat.c     **** //	int16_t	lookahead;
 532:ir_heat.c     **** //	int16_t 	slope, max_slope;
 533:ir_heat.c     **** //	int16_t	slope_raw;
 534:ir_heat.c     **** 	int16_t 	temp, temp_sum = 0;
 535:ir_heat.c     **** 	int16_t	slope_raw, slope = 0, temp_a, max_slope;
 536:ir_heat.c     **** 	uint8_t	count=0;
 537:ir_heat.c     **** 	uint8_t  last_interval = 0xff;
 538:ir_heat.c     **** 	uint8_t	startup = 3;
 539:ir_heat.c     **** 	uint8_t	on_counter = 0;
 540:ir_heat.c     **** 	int8_t	beep_counter = 0;
 541:ir_heat.c     **** 	int16_t	factor;
 542:ir_heat.c     **** 	int16_t	integral = 0;
 543:ir_heat.c     **** 	int8_t	fx = 0;
 544:ir_heat.c     **** 	
 545:ir_heat.c     **** 	int16_t	slope_std = 0;
 546:ir_heat.c     **** 	int16_t	slope_real = 0;
 547:ir_heat.c     **** 		
 548:ir_heat.c     **** 	// Interrupts aktivieren
 549:ir_heat.c     **** 	sei();
 1860               	E56:
 1862               	.Ltext12:
 1864 0876 7894      	.LM198:
 1865               		lds r20,interval
 1866               		cpi r20,lo8(16)
 1867 0878 EE24      		brge .+2
 1868 087a FF24      		rjmp .L91
 1870 087e FFEF      	.LM199:
 1871 0880 F983      	/* #APP */
 1872 0882 0F2E      	 ;  553 "ir_heat.c" 1
 1873 0884 F3E0      		wdr
 1874 0886 6F2E      	 ;  0 "" 2
 1876 088a AA24      	.LM200:
 1877 088c BB24      	/* #NOAPP */
 1878 088e 7724      		movw r24,r14
 550:ir_heat.c     **** 
 551:ir_heat.c     ****    while(1) {
 552:ir_heat.c     ****    	if(!(interval < 16)) { 					// Alle 16x (alle 4 Sekunden) Temperatur checken
 553:ir_heat.c     ****    		wdt_reset();                  	// Whatchdog zurücksetzen
 554:ir_heat.c     **** 
 555:ir_heat.c     **** 			temp = temp_sum / count;				// Mittelwert der 16 Messungen ermitteln
 556:ir_heat.c     **** 
 557:ir_heat.c     ****    		interval=0;
 558:ir_heat.c     ****    		count=0;
 559:ir_heat.c     **** 			temp_sum = 0;
 560:ir_heat.c     **** 	      //printf("Temp: %i\n", temp);
 561:ir_heat.c     **** 	      if(temp==0) {
 562:ir_heat.c     **** 	      	// error!
 563:ir_heat.c     **** 	      	printf("Error Temp=0");
 564:ir_heat.c     **** 	      }
 565:ir_heat.c     **** 	      else {
 566:ir_heat.c     **** 				if (startup>0) {
 567:ir_heat.c     **** 					// wird nur beim ersten Durchlauf, direkt nach Startup ausgeführt
 568:ir_heat.c     **** 					printf("Startup %i ", startup);
 569:ir_heat.c     **** 					startup--;
 570:ir_heat.c     **** 					temp = get_temperature(ADR_T_OBJ1);
 571:ir_heat.c     **** 					slope = 0;
 572:ir_heat.c     **** 				}
 573:ir_heat.c     ****    	   	printf("Temp: %i, ", temp);
 574:ir_heat.c     ****    	   	add_value(temp);									// Neue Temperatur zu Array hinzufügen
 575:ir_heat.c     ****    	   	slope_raw = get_slope();						// Aktuelle Steigung ermitteln
 576:ir_heat.c     ****    	   	if (slope_raw < -100) slope_raw = -100;
 577:ir_heat.c     ****    	   	
 578:ir_heat.c     ****    	   	factor = (temp - 620) / -25;					// Fakort ermitteln
 579:ir_heat.c     ****    	   	temp_a = get_temperature(ADR_T_A);
 580:ir_heat.c     ****    	   	//factor = (temp - 900 + 2*temp_a ) / -25;					// Fakort ermitteln
 581:ir_heat.c     ****    	   	if(factor < 0) factor = 0;
 582:ir_heat.c     ****    	   	   	   	
 583:ir_heat.c     **** 				if(slope_raw > factor) { 						// "Steigungsintegral"
 584:ir_heat.c     **** 					integral = 8*(integral + slope_raw) / factor;
 585:ir_heat.c     **** 					if(integral > 2000) integral = 2000;
 586:ir_heat.c     **** 				}
 587:ir_heat.c     **** 				else {
 588:ir_heat.c     **** 					integral = integral / 4;
 589:ir_heat.c     **** 				}
 590:ir_heat.c     **** 				
 591:ir_heat.c     **** //				slope = (31*slope + 10*slope_raw)/32; 		// Steigung dämpfen
 592:ir_heat.c     **** 
 593:ir_heat.c     **** 				
 594:ir_heat.c     **** 				if(slope_raw < -10) slope_raw = -10;
 595:ir_heat.c     **** 				if(slope_raw<0) {									// Fallende Temperaturen werden stärker gewichtet
 596:ir_heat.c     **** 	   	   	slope = (3*slope + 10*slope_raw)/4;		// Negative Steigung wird mit einer Dämpfung von 8 ge
 597:ir_heat.c     **** 				}
 598:ir_heat.c     **** 				else {
 599:ir_heat.c     **** 	   	   	slope = (31*slope + 10*slope_raw)/32;	// Positive Steigung wird mit einer Dämpfung von 16 
 600:ir_heat.c     **** 	   	   }
 601:ir_heat.c     **** 	   	
 602:ir_heat.c     **** 
 603:ir_heat.c     **** 	   		slope_real = get_slope2();
 604:ir_heat.c     **** 
 605:ir_heat.c     **** 				//printf("bc: %i,sr: %i", beep_counter, slope_real);
 606:ir_heat.c     **** 				if(beep_counter > 0) {
 607:ir_heat.c     **** 					beep_counter++;
 608:ir_heat.c     **** 					if((slope_real < 0)) {
 609:ir_heat.c     **** 						fx = fx+20;
 610:ir_heat.c     **** 						beep_counter = -10;
 611:ir_heat.c     **** 					}
 612:ir_heat.c     **** 				}
 613:ir_heat.c     **** 				
 614:ir_heat.c     **** 				if(fx > 60) fx= 60;
 615:ir_heat.c     **** 
 616:ir_heat.c     **** 	   		slope_std = exp_slope(temp) + fx;
 617:ir_heat.c     **** 	   	
 618:ir_heat.c     **** /*
 619:ir_heat.c     ****    	   	printf("slope_raw: %i, slope: %i ", slope_raw, slope);
 620:ir_heat.c     ****      	   	printf("Ambient: %i\n", get_temperature(ADR_T_A));
 621:ir_heat.c     **** */				
 622:ir_heat.c     **** 
 623:ir_heat.c     **** 				// temp_a 150 -> 45
 624:ir_heat.c     **** 				// temp_a 100 -> 60
 625:ir_heat.c     **** //   	   	max_slope = temp_a * -1.3 + 240;
 626:ir_heat.c     **** //   	   	max_slope = max_slope * (600-temp)/50;
 627:ir_heat.c     **** 				max_slope = (float)temp * -0.8 + 360;
 628:ir_heat.c     **** 
 629:ir_heat.c     **** //   	   	printf("sl_raw: %i, sl: %i, s_max: %i, f: %i, int: %i t_a: %i\n", slope_raw, slope, max_s
 630:ir_heat.c     ****    	   	printf("exp_s: %i, s2: %i, bc: %i, fx: %i\n", slope_std, slope_real, beep_counter, fx);
 631:ir_heat.c     **** 
 632:ir_heat.c     **** //				if((slope > max_slope) || (integral > 500)) {
 633:ir_heat.c     **** 				if(slope_real > slope_std) {
 634:ir_heat.c     **** 					on_counter++;
 635:ir_heat.c     **** 		   		printf("On-Counter: %i; \n", on_counter);
 636:ir_heat.c     **** 	   			if(mode == MODE_ON_NO_PROT){
 637:ir_heat.c     **** 						//on_counter++;
 638:ir_heat.c     **** 	   				if(on_counter==3){
 639:ir_heat.c     **** 	   					beep(BEEP_SHORT);
 640:ir_heat.c     **** 	   					beep_counter=1;
 641:ir_heat.c     **** 	   					on_counter = 0;
 642:ir_heat.c     **** 	   				}
 643:ir_heat.c     ****   					}
 644:ir_heat.c     ****    				else {
 645:ir_heat.c     ****    					if(get_last_slope() > 0) {
 646:ir_heat.c     **** 							//on_counter++;
 647:ir_heat.c     **** 			   			if((on_counter > 11) || (temp > 520)) {
 648:ir_heat.c     ****    							off_counter = OFF_COUNTER+1;
 649:ir_heat.c     ****    							on_counter = 0;
 650:ir_heat.c     ****    							if(mode == MODE_ON) {
 651:ir_heat.c     **** 	   							beep(BEEP_XLONG);
 652:ir_heat.c     ****    								if(temp<500) {
 653:ir_heat.c     **** 				   					beep_counter=1;
 654:ir_heat.c     ****    									//fx = fx+20;
 655:ir_heat.c     ****    								}
 656:ir_heat.c     ****    							}
 657:ir_heat.c     **** 		   				}
 658:ir_heat.c     **** 		   				else {
 659:ir_heat.c     **** 		   					if( ((on_counter > 4) && ((on_counter % 3) == 0)) || (temp > 500) ) {
 660:ir_heat.c     **** 		   						beep(BEEP_LONG);
 661:ir_heat.c     **** 		   						beep_counter = 1;
 662:ir_heat.c     **** 		   					}
 663:ir_heat.c     ****    						}
 664:ir_heat.c     ****    					}
 665:ir_heat.c     ****    					else {
 666:ir_heat.c     ****    						if(slope_raw<0) on_counter=0;
 667:ir_heat.c     ****    					}
 668:ir_heat.c     ****    				}
 669:ir_heat.c     **** 				}			
 670:ir_heat.c     **** 				else {
 671:ir_heat.c     **** 					on_counter = 0;
 672:ir_heat.c     **** 				}					
 673:ir_heat.c     ****    	   }
 674:ir_heat.c     **** 
 675:ir_heat.c     ****    		if(off_counter) {
 676:ir_heat.c     ****    			// Protection Counter läuft
 677:ir_heat.c     ****   				off_counter--;
 678:ir_heat.c     ****   				if(mode == MODE_ON) mode = MODE_TEMP_PROT;
 679:ir_heat.c     **** 				printf("Off-Counter: %i; \n", off_counter);
 680:ir_heat.c     ****    		}
 681:ir_heat.c     ****    		else {
 682:ir_heat.c     ****    			if(mode == MODE_TEMP_PROT) {
 683:ir_heat.c     ****    				slope = 0;
 684:ir_heat.c     ****    				integral = 0;
 685:ir_heat.c     ****    				mode = MODE_OFF;
 686:ir_heat.c     ****    			}
 687:ir_heat.c     ****    		}
 688:ir_heat.c     **** 		}
 689:ir_heat.c     **** 		else if(interval != last_interval) {
 690:ir_heat.c     **** 			// In jedem Interval 1x die Temperatur abrufen
 691:ir_heat.c     **** 			// und für den Mittelwert aufsummieren
 692:ir_heat.c     ****    		last_interval = interval;
 693:ir_heat.c     ****     		if(count<16) {
 694:ir_heat.c     **** 	   		count++;
 695:ir_heat.c     ****    			// Messwerte für den Mittelwert aufsummieren
 696:ir_heat.c     ****    			temp_sum += get_temperature(ADR_T_OBJ1);
 697:ir_heat.c     ****    		}
 698:ir_heat.c     ****    	}
 699:ir_heat.c     **** 
 700:ir_heat.c     **** 		// Je nach Mode Relais und LEDs setzen
 701:ir_heat.c     **** 		switch(mode) {
 702:ir_heat.c     **** 		case MODE_OFF:
 703:ir_heat.c     **** 			set_relais(0);
 704:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 1879               	23,lo8(0)
 1880               		call __divmodhi4
 1881 0890 0F2E      		mov r24,r22
 1882 0892 FBE2      		mov r25,r23
 1883 0894 CF2E      		movw r14,r24
 1885 0898 F02D      	.LM201:
 1886               		sts interval,__zero_reg__
 1888 089a 2224      	.LM202:
 1889 089c 3324      		cp r14,__zero_reg__
 1890               		cpc r15,__zero_reg__
 1891               		brne .L92
 1893               	.LM203:
 1894               		rcall .
 1895               		ldi r24,lo8(.LC8)
 1896               		ldi r25,hi8(.LC8)
 1897               		in r30,__SP_L__
 1898 089e 0F2E      		in r31,__SP_H__
 1899 08a0 F8EA      		std Z+2,r25
 1900 08a2 4F2E      		std Z+1,r24
 1901 08a4 F1E6      		call printf
 1902 08a6 5F2E      		pop __tmp_reg__
 1903 08a8 F02D      		pop __tmp_reg__
 1904               		rjmp .L93
 1905               	.L92:
 1907               	.LM204:
 1908               		tst r6
 1909               		breq .L94
 1911               	.LM205:
 1912               		rcall .
 1913 08aa 4091 0000 		rcall .
 1914 08ae 4031      		in r30,__SP_L__
 1915 08b0 04F4      		in r31,__SP_H__
 1916 08b2 00C0      		adiw r30,1
 1917               		ldi r24,lo8(.LC9)
 1918               		ldi r25,hi8(.LC9)
 1919               		std Z+1,r25
 1920               		st Z,r24
 1921 08b4 A895      		std Z+2,r6
 1922               		std Z+3,__zero_reg__
 1923               		call printf
 1925               	.LM206:
 1926 08b6 C701      		dec r6
 1928 08ba 70E0      	.LM207:
 1929 08bc 0E94 0000 		pop __tmp_reg__
 1930 08c0 862F      		pop __tmp_reg__
 1931 08c2 972F      		pop __tmp_reg__
 1932 08c4 7C01      		pop __tmp_reg__
 1933               		ldi r24,lo8(7)
 1934               		call get_temperature
 1935 08c6 1092 0000 		movw r14,r24
 1936               	.L94:
 1938 08ca E114      	.LM208:
 1939 08cc F104      		rcall .
 1940 08ce 01F4      		rcall .
 1941               		in r30,__SP_L__
 1942               		in r31,__SP_H__
 1943 08d0 00D0      		adiw r30,1
 1944 08d2 80E0      		ldi r24,lo8(.LC10)
 1945 08d4 90E0      		ldi r25,hi8(.LC10)
 1946 08d6 EDB7      		std Z+1,r25
 1947 08d8 FEB7      		st Z,r24
 1948 08da 9283      		std Z+3,r15
 1949 08dc 8183      		std Z+2,r14
 1950 08de 0E94 0000 		call printf
 1952 08e4 0F90      	.LM209:
 1953 08e6 00C0      		pop __tmp_reg__
 1954               		pop __tmp_reg__
 1955               		pop __tmp_reg__
 1956               		pop __tmp_reg__
 1957 08e8 6620      		movw r24,r14
 1958 08ea 01F0      		call add_value
 1960               	.LM210:
 1961 08ec 00D0      		call get_slope
 1962 08ee 00D0      		movw r8,r24
 1964 08f2 FEB7      	.LM211:
 1965 08f4 3196      		ldi r24,lo8(6)
 1966 08f6 80E0      		call get_temperature
 1968 08fa 9183      	.LM212:
 1969 08fc 8083      		call get_slope2
 1970 08fe 6282      		std Y+3,r25
 1971 0900 1382      		std Y+2,r24
 1973               	.LM213:
 1974               		cp __zero_reg__,r11
 1975 0906 6A94      		brge .L95
 1977               	.LM214:
 1978 0908 0F90      		tst r25
 1979 090a 0F90      		brlt .L96
 1981 090e 0F90      	.LM215:
 1982 0910 87E0      		inc r11
 1983 0912 0E94 0000 		rjmp .L95
 1984 0916 7C01      	.L96:
 1986               	.LM216:
 1987               		ldi r25,lo8(20)
 1988 0918 00D0      		add r7,r25
 1989 091a 00D0      		mov __tmp_reg__,r31
 1990 091c EDB7      		ldi r31,lo8(-10)
 1991 091e FEB7      		mov r11,r31
 1992 0920 3196      		mov r31,__tmp_reg__
 1993 0922 80E0      	.L95:
 1994 0924 90E0      		ldi r30,lo8(60)
 1995 0926 9183      		cp r30,r7
 1996 0928 8083      		brge .L97
 1997 092a F382      		mov __tmp_reg__,r31
 1998 092c E282      		ldi r31,lo8(60)
 1999 092e 0E94 0000 		mov r7,r31
 2000               		mov r31,__tmp_reg__
 2001               	.L97:
 2003 0934 0F90      	.LM217:
 2004 0936 0F90      		movw r24,r14
 2005 0938 0F90      		call exp_slope
 2006 093a C701      		mov r18,r7
 2007 093c 0E94 0000 		clr r19
 2008               		sbrc r18,7
 2009               		com r19
 2010 0940 0E94 0000 		movw r16,r18
 2011 0944 4C01      		add r16,r24
 2012               		adc r17,r25
 2014 0946 86E0      	.LM218:
 2015 0948 0E94 0000 		in r24,__SP_L__
 2016               		in r25,__SP_H__
 2017               		sbiw r24,10
 2018 094c 0E94 0000 		in __tmp_reg__,__SREG__
 2019 0950 9B83      		cli
 2020 0952 8A83      		out __SP_H__,r25
 2021               		out __SREG__,__tmp_reg__
 2022               		out __SP_L__,r24
 2023 0954 1B14      		in r30,__SP_L__
 2024 0956 04F4      		in r31,__SP_H__
 2025               		adiw r30,1
 2026               		ldi r24,lo8(.LC11)
 2027 0958 9923      		ldi r25,hi8(.LC11)
 2028 095a 04F0      		std Z+1,r25
 2029               		st Z,r24
 2030               		std Z+3,r17
 2031 095c B394      		std Z+2,r16
 2032 095e 00C0      		ldd r24,Y+2
 2033               		ldd r25,Y+3
 2034               		std Z+5,r25
 2035               		std Z+4,r24
 2036 0960 94E1      		mov r24,r11
 2037 0962 790E      		clr r25
 2038 0964 0F2E      		sbrc r24,7
 2039 0966 F6EF      		com r25
 2040 0968 BF2E      		std Z+7,r25
 2041 096a F02D      		std Z+6,r24
 2042               		std Z+9,r19
 2043 096c ECE3      		std Z+8,r18
 2044 096e E715      		call printf
 2046 0972 0F2E      	.LM219:
 2047 0974 FCE3      		in r30,__SP_L__
 2048 0976 7F2E      		in r31,__SP_H__
 2049 0978 F02D      		adiw r30,10
 2050               		in __tmp_reg__,__SREG__
 2051               		cli
 2052               		out __SP_H__,r31
 2053 097a C701      		out __SREG__,__tmp_reg__
 2054 097c 0E94 0000 		out __SP_L__,r30
 2055 0980 272D      		ldd r24,Y+2
 2056 0982 3327      		ldd r25,Y+3
 2057 0984 27FD      		cp r16,r24
 2058 0986 3095      		cpc r17,r25
 2059 0988 8901      		brlt .+2
 2060 098a 080F      		rjmp .L98
 2062               	.LM220:
 2063               		inc r10
 2065 0990 9EB7      	.LM221:
 2066 0992 0A97      		rcall .
 2067 0994 0FB6      		rcall .
 2068 0996 F894      		in r30,__SP_L__
 2069 0998 9EBF      		in r31,__SP_H__
 2070 099a 0FBE      		adiw r30,1
 2071 099c 8DBF      		ldi r24,lo8(.LC12)
 2072 099e EDB7      		ldi r25,hi8(.LC12)
 2073 09a0 FEB7      		std Z+1,r25
 2074 09a2 3196      		st Z,r24
 2075 09a4 80E0      		std Z+2,r10
 2076 09a6 90E0      		std Z+3,__zero_reg__
 2077 09a8 9183      		call printf
 2079 09ac 1383      	.LM222:
 2080 09ae 0283      		pop __tmp_reg__
 2081 09b0 8A81      		pop __tmp_reg__
 2082 09b2 9B81      		pop __tmp_reg__
 2083 09b4 9583      		pop __tmp_reg__
 2084 09b6 8483      		lds r24,mode
 2085 09b8 8B2D      		cpi r24,lo8(2)
 2086 09ba 9927      		brne .L99
 2088 09be 9095      	.LM223:
 2089 09c0 9783      		ldi r25,lo8(3)
 2090 09c2 8683      		cp r10,r25
 2091 09c4 3187      		breq .+2
 2092 09c6 2087      		rjmp .L93
 2094               	.LM224:
 2095               		ldi r24,lo8(1)
 2096 09cc EDB7      		call beep
 2097 09ce FEB7      		clr r10
 2098 09d0 3A96      		clr r11
 2099 09d2 0FB6      		inc r11
 2100 09d4 F894      		rjmp .L93
 2101 09d6 FEBF      	.L99:
 2103 09da EDBF      	.LM225:
 2104 09dc 8A81      		call get_last_slope
 2105 09de 9B81      		cp __zero_reg__,r24
 2106 09e0 0817      		cpc __zero_reg__,r25
 2107 09e2 1907      		brge .L100
 2109 09e6 00C0      	.LM226:
 2110               		ldi r30,lo8(11)
 2111               		cp r30,r10
 2112 09e8 A394      		brlo .L101
 2113               		ldi r31,lo8(521)
 2114               		cp r14,r31
 2115 09ea 00D0      		ldi r31,hi8(521)
 2116 09ec 00D0      		cpc r15,r31
 2117 09ee EDB7      		brlt .L102
 2118 09f0 FEB7      	.L101:
 2120 09f4 80E0      	.LM227:
 2121 09f6 90E0      		ldi r21,lo8(3)
 2122 09f8 9183      		sts off_counter,r21
 2124 09fc A282      	.LM228:
 2125 09fe 1382      		lds r24,mode
 2126 0a00 0E94 0000 		cpi r24,lo8(1)
 2127               		breq .L103
 2128               		clr r10
 2129 0a04 0F90      		ldi r24,lo8(3)
 2130 0a06 0F90      		rjmp .L104
 2131 0a08 0F90      	.L103:
 2133 0a0c 8091 0000 	.LM229:
 2134 0a10 8230      		ldi r24,lo8(4)
 2135 0a12 01F4      		call beep
 2137               	.LM230:
 2138 0a14 93E0      		ldi r24,lo8(500)
 2139 0a16 A916      		cp r14,r24
 2140 0a18 01F0      		ldi r24,hi8(500)
 2141 0a1a 00C0      		cpc r15,r24
 2142               		brge .L98
 2143               		clr r10
 2144 0a1c 81E0      		clr r11
 2145 0a1e 0E94 0000 		inc r11
 2146 0a22 AA24      		rjmp .L93
 2147 0a24 BB24      	.L102:
 2149 0a28 00C0      	.LM231:
 2150               		ldi r25,lo8(4)
 2151               		cp r25,r10
 2152               		brsh .L105
 2153 0a2a 0E94 0000 		mov r24,r10
 2154 0a2e 1816      		ldi r22,lo8(3)
 2155 0a30 1906      		call __udivmodqi4
 2156 0a32 04F4      		tst r25
 2157               		breq .L106
 2158               	.L105:
 2159 0a34 EBE0      		ldi r30,lo8(501)
 2160 0a36 EA15      		cp r14,r30
 2161 0a38 00F0      		ldi r30,hi8(501)
 2162 0a3a F9E0      		cpc r15,r30
 2163 0a3c EF16      		brlt .L93
 2164 0a3e F2E0      	.L106:
 2166 0a42 04F0      	.LM232:
 2167               		ldi r24,lo8(3)
 2168               		call beep
 2169               		clr r11
 2170 0a44 53E0      		inc r11
 2171 0a46 5093 0000 		rjmp .L93
 2172               	.L100:
 2174 0a4a 8091 0000 	.LM233:
 2175 0a4e 8130      		tst r9
 2176 0a50 01F0      		brge .L93
 2177 0a52 AA24      	.L98:
 2178 0a54 83E0      		clr r10
 2179 0a56 00C0      	.L93:
 2181               	.LM234:
 2182               		lds r24,off_counter
 2183 0a58 84E0      		tst r24
 2184 0a5a 0E94 0000 		breq .L107
 2185               	.L104:
 2187 0a5e 84EF      	.LM235:
 2188 0a60 E816      		subi r24,lo8(-(-1))
 2189 0a62 81E0      		sts off_counter,r24
 2191 0a66 04F4      	.LM236:
 2192 0a68 AA24      		lds r24,mode
 2193 0a6a BB24      		cpi r24,lo8(1)
 2194 0a6c B394      		brne .L108
 2195 0a6e 00C0      		ldi r31,lo8(3)
 2196               		sts mode,r31
 2197               	.L108:
 2199 0a70 94E0      	.LM237:
 2200 0a72 9A15      		rcall .
 2201 0a74 00F4      		rcall .
 2202 0a76 8A2D      		in r30,__SP_L__
 2203 0a78 63E0      		in r31,__SP_H__
 2204 0a7a 0E94 0000 		adiw r30,1
 2205 0a7e 9923      		ldi r24,lo8(.LC13)
 2206 0a80 01F0      		ldi r25,hi8(.LC13)
 2207               		std Z+1,r25
 2208 0a82 E5EF      		st Z,r24
 2209 0a84 EE16      		lds r24,off_counter
 2210 0a86 E1E0      		std Z+2,r24
 2211 0a88 FE06      		std Z+3,__zero_reg__
 2212 0a8a 04F0      		call printf
 2213               		movw r14,r2
 2214               		ldi r16,lo8(0)
 2215               		pop __tmp_reg__
 2216 0a8c 83E0      		pop __tmp_reg__
 2217 0a8e 0E94 0000 		pop __tmp_reg__
 2218 0a92 BB24      		pop __tmp_reg__
 2219 0a94 B394      		rjmp .L109
 2220 0a96 00C0      	.L107:
 2222               	.LM238:
 2223               		lds r24,mode
 2224 0a98 9920      		cpi r24,lo8(3)
 2225 0a9a 04F4      		breq .L110
 2226               		movw r14,r2
 2227 0a9c AA24      		ldi r16,lo8(0)
 2228               		rjmp .L109
 2229               	.L110:
 2231 0a9e 8091 0000 	.LM239:
 2232 0aa2 8823      		sts mode,__zero_reg__
 2233 0aa4 01F0      		movw r14,r2
 2234               		ldi r16,lo8(0)
 2235               		rjmp .L111
 2236               	.L91:
 2238 0aa8 8093 0000 	.LM240:
 2239               		mov r18,r20
 2240               		clr r19
 2241 0aac 8091 0000 		sbrc r18,7
 2242 0ab0 8130      		com r19
 2243 0ab2 01F4      		ldd r30,Y+1
 2244 0ab4 F3E0      		mov r24,r30
 2245 0ab6 F093 0000 		ldi r25,lo8(0)
 2246               		cp r18,r24
 2247               		cpc r19,r25
 2248               		breq .L109
 2250 0abc 00D0      	.LM241:
 2251 0abe EDB7      		std Y+1,r20
 2253 0ac2 3196      	.LM242:
 2254 0ac4 80E0      		cpi r16,lo8(16)
 2255 0ac6 90E0      		brsh .L109
 2257 0aca 8083      	.LM243:
 2258 0acc 8091 0000 		subi r16,lo8(-(1))
 2260 0ad2 1382      	.LM244:
 2261 0ad4 0E94 0000 		ldi r24,lo8(7)
 2262 0ad8 7101      		call get_temperature
 2263 0ada 00E0      		add r14,r24
 2264 0adc 0F90      		adc r15,r25
 2265 0ade 0F90      	.L109:
 2267 0ae2 0F90      	.LM245:
 2268 0ae4 00C0      		lds r24,mode
 2269               		cpi r24,lo8(1)
 2270               		breq .L113
 2271               		cpi r24,lo8(1)
 2272 0ae6 8091 0000 		brlo .L111
 2273 0aea 8330      		cpi r24,lo8(2)
 2274 0aec 01F0      		breq .L114
 2275 0aee 7101      		cpi r24,lo8(3)
 2276 0af0 00E0      		brne .L119
 2277 0af2 00C0      		rjmp .L120
 2278               	.L111:
 2280               	.LM246:
 2281 0af4 1092 0000 		ldi r24,lo8(0)
 2282 0af8 7101      		call set_relais
 2284 0afc 00C0      	.LM247:
 2285               		movw r30,r12
 2286               		ld r24,Z
 2287               		ori r24,lo8(16)
 2288 0afe 242F      		st Z,r24
 2290 0b02 27FD      	.LM248:
 2291 0b04 3095      		ld r24,Z
 2292 0b06 E981      		andi r24,lo8(-9)
 2293 0b08 8E2F      		st Z,r24
 2295 0b0c 2817      	.LM249:
 2296 0b0e 3907      		sts off_counter,__zero_reg__
 2297 0b10 01F0      		clr r10
 2298               		clr r11
 2299               		rjmp .L116
 2300 0b12 4983      	.L113:
 2302               	.LM250:
 2303 0b14 0031      		movw r30,r12
 2304 0b16 00F4      		ld r24,Z
 2305               		ori r24,lo8(16)
 2306               		st Z,r24
 2307 0b18 0F5F      	.L114:
 2309               	.LM251:
 2310 0b1a 87E0      		ldi r24,lo8(1)
 2311 0b1c 0E94 0000 		call set_relais
 2313 0b22 F91E      	.LM252:
 2314               		movw r30,r12
 2315               		ld r24,Z
 2316               		ori r24,lo8(8)
 2317 0b24 8091 0000 		st Z,r24
 2318 0b28 8130      		rjmp .L116
 2319 0b2a 01F0      	.L120:
 2321 0b2e 00F0      	.LM253:
 2322 0b30 8230      		ldi r24,lo8(0)
 2323 0b32 01F0      		call set_relais
 2325 0b36 01F4      	.LM254:
 2326 0b38 00C0      		movw r30,r12
 2327               		ld r24,Z
 2328               		andi r24,lo8(-17)
 2329               		st Z,r24
 2331 0b3c 0E94 0000 	.LM255:
 2332               		ld r24,Z
 2333               		ori r24,lo8(8)
 2334 0b40 F601      		st Z,r24
 2335 0b42 8081      		rjmp .L116
 2336 0b44 8061      	.L119:
 705:ir_heat.c     **** 			STATUS_LED2_OFF;
 2338               	257:
 2339               		movw r24,r4
 2340 0b48 8081      	/* #APP */
 2341 0b4a 877F      	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 2342 0b4c 8083      		1: sbiw r24,1
 706:ir_heat.c     **** 			off_counter = 0;
 2343               	*/
 2344               	 ;  105 "c:/winavr/lib/gcc/../../avr/include/util/delay_basic.h" 1
 2345 0b4e 1092 0000 		1: sbiw r24,1
 2346 0b52 AA24      		brne 1b
 2347 0b54 BB24      	 ;  0 "" 2
 2348 0b56 00C0      	/* #NOAPP */
 2349               		rjmp .L117
 707:ir_heat.c     **** 			on_counter = 0;
 708:ir_heat.c     **** 			beep_counter = 0;
 709:ir_heat.c     **** 			break;
 710:ir_heat.c     **** 		case MODE_ON:
 711:ir_heat.c     **** 			STATUS_LED1_ON;      // Grün
 2350               	til/delay_basic.h" 1
 2351               		1: sbiw r24,1
 2352 0b58 F601      		brne 1b
 2353 0b5a 8081      	 ;  0 "" 2
 2354 0b5c 8061      	/* #NOAPP */
 2355 0b5e 8083      		rjmp .L117
 2356               	.LBE60:
 712:ir_heat.c     **** 		case MODE_ON_NO_PROT:
 713:ir_heat.c     **** 			set_relais(1);
 2357               	_basic.h" 1
 2358               		1: sbiw r24,1
 2359 0b60 81E0      		brne 1b
 2360 0b62 0E94 0000 	 ;  0 "" 2
 714:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2361               	lib/gcc/../../avr/include/util/delay_basic.h" 1
 2362               		1: sbiw r24,1
 2363 0b66 F601      		brne 1b
 2364 0b68 8081      	 ;  0 "" 2
 2365 0b6a 8860      	/* #NOAPP */
 2366 0b6c 8083      		rjmp .L117
 2367 0b6e 00C0      	.LBE60:
 2368               	.LBE61:
 715:ir_heat.c     **** 			break;
 716:ir_heat.c     **** 		case MODE_TEMP_PROT:
 717:ir_heat.c     **** 			set_relais(0);
 2369               	 1
 2370               		1: sbiw r24,1
 2371 0b70 80E0      		brne 1b
 2372 0b72 0E94 0000 	 ;  0 "" 2
 718:ir_heat.c     **** 			STATUS_LED1_OFF;
 2373               	lib/gcc/../../avr/include/util/delay_basic.h" 1
 2374               		1: sbiw r24,1
 2375 0b76 F601      		brne 1b
 2376 0b78 8081      	 ;  0 "" 2
 2377 0b7a 8F7E      	/* #NOAPP */
 2378 0b7c 8083      		rjmp .L117
 719:ir_heat.c     **** 			STATUS_LED2_ON;      // Rot
 2379               	til/delay_basic.h" 1
 2380               		1: sbiw r24,1
 2381 0b7e 8081      		brne 1b
 2382 0b80 8860      	 ;  0 "" 2
 2383 0b82 8083      	/* #NOAPP */
 2384 0b84 00C0      		rjmp .L117
 2385               	.LBE60:
 720:ir_heat.c     **** 			slope = 0;
 721:ir_heat.c     **** 			integral = 0;
 722:ir_heat.c     **** 			break;
 723:ir_heat.c     **** 		default:
 724:ir_heat.c     **** 			mode = MODE_OFF;
 2386               	_basic.h" 1
 2387               		1: sbiw r24,1
 2388 0b86 1092 0000 		brne 1b
 2389               	 ;  0 "" 2
 2390               	/* #NOAPP */
 2391               		rjmp .L117
 2392               	.LBE60:
 2393               	.LBE61:
 2394               	.LBE62:
 2395               	.LBE63:
 2410               	.Lscope22:
 2411               	.global	interval
 2412               		.data
 2415               	interval:
 2416               		.byte	-12
 2417               	.global	off_counter
 2418               	.global	off_counter
 2419               		.section .bss
 2422               	off_counter:
 2423               		.skip 1,0
 2424               	.global	flash_button
 2425               	.global	flash_button
 2428               	flash_button:
 2429               		.skip 1,0
 2430 00c3 F4        	.global	flash_LED
 2431               	.global	flash_LED
 2434               	flash_LED:
 2435               		.skip 1,0
 2436               		.lcomm last.2001,1
 2437 0000 00        		.lcomm last_slope.1889,2
 2438               		.lcomm running.1757,1
 2439               		.lcomm c2.1731,1
 2440               		.lcomm c1.1730,1
 2441               		.comm tbuf,32,1
 2442               		.comm rbuf,32,1
 2443 0001 00        		.comm t_in,1,1
 2444               		.comm t_out,1,1
 2445               		.comm r_in,1,1
 2446               		.comm r_out,1,1
 2447               		.comm t_array,12,1
 2448               		.comm mode,1,1
 2449 0002 00        		.comm slope2,2,1
 2468               		.text
 2470               	.Letext0:
 2471               	.global __do_copy_data
 2472               	.global __do_clear_bss
 2473               	...
DEFINED SYMBOLS
                            *ABS*:00000000 ir_heat.c
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:2      *ABS*:0000003f __SREG__
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:3      *ABS*:0000003e __SP_H__
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:4      *ABS*:0000003d __SP_L__
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:5      *ABS*:00000034 __CCP__
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:89     .text:00000000 __vector_9
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:2429   .data:000000c3 interval
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:120    .text:00000022 __vector_13
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:153    .text:00000042 __vector_16
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:2453   .bss:00000008 c1.1730
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:2452   .bss:00000007 c2.1731
                            *COM*:00000001 mode
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:274    .text:000000de __vector_18
                            *COM*:00000001 r_in
                            *COM*:00000020 rbuf
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:324    .text:0000011c __vector_19
                            *COM*:00000001 t_in
                            *COM*:00000001 t_out
                            *COM*:00000020 tbuf
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:387    .text:00000176 tbuflen
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:409    .text:00000182 UART_putchar
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:466    .text:000001ce rbuflen
                            *COM*:00000001 r_out
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:487    .text:000001da UART_getchar
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:527    .text:00000200 exp_slope
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:576    .text:00000240 get_slope2
                            *COM*:0000000c t_array
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:2450   .bss:00000004 last_slope.1889
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:621    .text:00000286 add_value
                            *COM*:00000002 slope2
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:736    .text:0000034c get_slope
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:813    .text:000003cc get_last_slope
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:839    .text:000003e6 _beep
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:921    .text:00000424 set_relais
                             .bss:00000003 last.2001
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:989    .text:0000046a beep
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:1140   .text:000004e6 __vector_1
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:2451   .bss:00000006 running.1757
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:1406   .text:00000618 get_temperature
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:1502   .text:00000684 print_array
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:1640   .text:00000780 UART_first_init
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:1699   .text:000007a8 main
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:2436   .bss:00000000 off_counter
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:2442   .bss:00000001 flash_button
C:\Users\Thorsten\AppData\Local\Temp/cch4mStT.s:2448   .bss:00000002 flash_LED

UNDEFINED SYMBOLS
__divmodhi4
__udivmodhi4
puts
i2c_start
i2c_write
i2c_rep_start
i2c_read_ack
i2c_stop
printf
putchar
fdevopen
i2c_init
__udivmodqi4
__do_copy_data
__do_clear_bss
