   1               		.file	"i2c_mstr.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  69               	.global	i2c_init
  71               	i2c_init:
   1:i2c_mstr.c    **** #ifndef  F_CPU
   2:i2c_mstr.c    **** #define F_CPU 16000000UL
   3:i2c_mstr.c    **** #endif
   4:i2c_mstr.c    **** 
   5:i2c_mstr.c    **** #include <avr/io.h>
   6:i2c_mstr.c    **** #include <util/twi.h>
   7:i2c_mstr.c    **** 
   8:i2c_mstr.c    **** #include "i2c_mstr.h"
   9:i2c_mstr.c    **** 
  10:i2c_mstr.c    **** #define F_SCL 100000UL // SCL frequency
  11:i2c_mstr.c    **** #define Prescaler 1
  12:i2c_mstr.c    **** #define TWBR_val ((((F_CPU / F_SCL) / Prescaler) - 16 ) / 2)
  13:i2c_mstr.c    **** 
  14:i2c_mstr.c    **** void i2c_init(void)
  15:i2c_mstr.c    **** {
  72               	rame size = 0 */
  74               	.LM1:
  75               		ldi r30,lo8(184)
  76               		ldi r31,hi8(184)
  16:i2c_mstr.c    **** 	TWBR = (uint8_t)TWBR_val;
  77               	r24,lo8(72)
  78               		st Z,r24
  80 0002 F0E0      	.LM2:
  81 0004 88E4      		ldi r24,lo8(10)
  82 0006 8083      		st Z,r24
  17:i2c_mstr.c    **** 	TWBR = 10;
  83               	logue start */
  85 0008 8AE0      	.LM3:
  86 000a 8083      		ret
  18:i2c_mstr.c    **** }
  88               	pe1:
  91               	.global	i2c_start
  93               	i2c_start:
  95               	.LM4:
  96               	.LFBB2:
  97               	/* prologue: function */
  19:i2c_mstr.c    **** 
  20:i2c_mstr.c    **** uint8_t i2c_start(uint8_t address)
  21:i2c_mstr.c    **** {
  98               	ize = 0 */
  99               		mov r25,r24
 101               	.LM5:
 102               		ldi r30,lo8(188)
 103 000e 982F      		ldi r31,hi8(188)
  22:i2c_mstr.c    **** 	// reset TWI control register
  23:i2c_mstr.c    **** 	TWCR = 0;
 104               	__zero_reg__
 106 0010 ECEB      	.LM6:
 107 0012 F0E0      		ldi r24,lo8(-92)
 108 0014 1082      		st Z,r24
  24:i2c_mstr.c    **** 	// transmit START condition
  25:i2c_mstr.c    **** 	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 110               	.LM7:
 111 0016 84EA      		ld r24,Z
 112 0018 8083      		tst r24
 113               		brge .L4
  26:i2c_mstr.c    **** 	// wait for end of transmission
  27:i2c_mstr.c    **** 	while( !(TWCR & (1<<TWINT)) );
 114               	bn	68,0,30,.LM8-.LFBB2
 115               	.LM8:
 116 001a 8081      		lds r24,185
 117 001c 8823      		andi r24,lo8(-8)
 118 001e 04F4      		cpi r24,lo8(8)
  28:i2c_mstr.c    **** 	
  29:i2c_mstr.c    **** 	// check if the start condition was successfully transmitted
  30:i2c_mstr.c    **** 	if((TWSR & 0xF8) != TW_START){ return 1; }
 119               	 .L5
 120               		ldi r24,lo8(1)
 121 0020 8091 B900 		ret
 122 0024 887F      	.L5:
 124 0028 01F0      	.LM9:
 125 002a 81E0      		sts 187,r25
 127               	.LM10:
  31:i2c_mstr.c    **** 	
  32:i2c_mstr.c    **** 	// load slave address into data register
  33:i2c_mstr.c    **** 	TWDR = address;
 128               	lo8(-124)
 129               		sts 188,r24
  34:i2c_mstr.c    **** 	// start transmission of address
  35:i2c_mstr.c    **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 131               	11:
 132               		ldi r30,lo8(188)
 133 0032 84E8      		ldi r31,hi8(188)
 134 0034 8093 BC00 	.L7:
  36:i2c_mstr.c    **** 	// wait for end of transmission
  37:i2c_mstr.c    **** 	while( !(TWCR & (1<<TWINT)) );
 135               	r24,Z
 136               		tst r24
 137 0038 ECEB      		brge .L7
 139               	.LM12:
 140 003c 8081      		lds r24,185
 141 003e 8823      		mov r25,r24
 142 0040 04F4      		andi r25,lo8(-8)
  38:i2c_mstr.c    **** 	
  39:i2c_mstr.c    **** 	// check if the device has acknowledged the READ / WRITE mode
  40:i2c_mstr.c    **** 	uint8_t twst = TW_STATUS & 0xF8;
 143               	68,0,41,.LM13-.LFBB2
 144               	.LM13:
 145 0042 8091 B900 		cpi r25,lo8(24)
 146 0046 982F      		brne .L8
 147 0048 987F      		ldi r24,lo8(0)
  41:i2c_mstr.c    **** 	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
 148               	.L8:
 149               		ldi r24,lo8(0)
 150 004a 9831      		cpi r25,lo8(64)
 151 004c 01F4      		breq .L6
 152 004e 80E0      		ldi r24,lo8(1)
 153 0050 0895      	.L6:
 155 0052 80E0      	.LM14:
 156 0054 9034      		ret
  42:i2c_mstr.c    **** 	
  43:i2c_mstr.c    **** 	return 0;
  44:i2c_mstr.c    **** }
 160               	0,0,.Lscope2-.LFBB2
 161               	.Lscope2:
 164               	.global	i2c_rep_start
 166               	i2c_rep_start:
 168               	.LM15:
 169               	.LFBB3:
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 172               		mov r25,r24
  45:i2c_mstr.c    **** 
  46:i2c_mstr.c    **** 
  47:i2c_mstr.c    **** uint8_t i2c_rep_start(uint8_t address)
  48:i2c_mstr.c    **** {
 173               	52,.LM16-.LFBB3
 174               	.LM16:
 175               		ldi r24,lo8(-92)
 176               		sts 188,r24
 178 005c 982F      	.LM17:
  49:i2c_mstr.c    **** 	// reset TWI control register
  50:i2c_mstr.c    **** 	// TWCR = 0;
  51:i2c_mstr.c    **** 	// transmit START condition
  52:i2c_mstr.c    **** 	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 179               	30,lo8(188)
 180               		ldi r31,hi8(188)
 181 005e 84EA      	.L14:
 182 0060 8093 BC00 		ld r24,Z
  53:i2c_mstr.c    **** 	// wait for end of transmission
  54:i2c_mstr.c    **** 	while( !(TWCR & (1<<TWINT)) );
 183               	 r24
 184               		brge .L14
 186 0066 F0E0      	.LM18:
 187               		lds r24,185
 188 0068 8081      		andi r24,lo8(-8)
 189 006a 8823      		cpi r24,lo8(16)
 190 006c 04F4      		breq .L15
  55:i2c_mstr.c    **** 	
  56:i2c_mstr.c    **** 	// check if the start condition was successfully transmitted
  57:i2c_mstr.c    **** 	if((TWSR & 0xF8) != TW_REP_START){ return 1; }
 191               	,lo8(1)
 192               		ret
 193 006e 8091 B900 	.L15:
 195 0074 8031      	.LM19:
 196 0076 01F0      		sts 187,r25
 198 007a 0895      	.LM20:
 199               		ldi r24,lo8(-124)
  58:i2c_mstr.c    **** 	
  59:i2c_mstr.c    **** 	// load slave address into data register
  60:i2c_mstr.c    **** 	TWDR = address;
 200               	r24
 202 007c 9093 BB00 	.LM21:
  61:i2c_mstr.c    **** 	// start transmission of address
  62:i2c_mstr.c    **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 203               	i r30,lo8(188)
 204               		ldi r31,hi8(188)
 205 0080 84E8      	.L17:
 206 0082 8093 BC00 		ld r24,Z
  63:i2c_mstr.c    **** 	// wait for end of transmission
  64:i2c_mstr.c    **** 	while( !(TWCR & (1<<TWINT)) );
 207               	 r24
 208               		brge .L17
 210 0088 F0E0      	.LM22:
 211               		lds r24,185
 212 008a 8081      		mov r25,r24
 213 008c 8823      		andi r25,lo8(-8)
  65:i2c_mstr.c    **** 	
  66:i2c_mstr.c    **** 	// check if the device has acknowledged the READ / WRITE mode
  67:i2c_mstr.c    **** 	uint8_t twst = TW_STATUS & 0xF8;
 215               	cpi r25,lo8(24)
 216               		brne .L18
 217 0090 8091 B900 		ldi r24,lo8(0)
 218 0094 982F      		ret
 219 0096 987F      	.L18:
  68:i2c_mstr.c    **** 	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
 220               	r24,lo8(0)
 221               		cpi r25,lo8(64)
 222 0098 9831      		breq .L16
 223 009a 01F4      		ldi r24,lo8(1)
 224 009c 80E0      	.L16:
 226               	.LM24:
 227 00a0 80E0      		ret
  69:i2c_mstr.c    **** 	
  70:i2c_mstr.c    **** 	return 0;
  71:i2c_mstr.c    **** }
 232               	stabs	"i2c_write:F(4,2)",36,0,0,i2c_write
 234 00a8 0895      	.global	i2c_write
 236               	i2c_write:
 238               	.LM25:
 239               	.LFBB4:
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 243               	.LM26:
 244               		sts 187,r24
  72:i2c_mstr.c    **** 
  73:i2c_mstr.c    **** 
  74:i2c_mstr.c    **** uint8_t i2c_write(uint8_t data)
  75:i2c_mstr.c    **** {
 245               	79,.LM27-.LFBB4
 246               	.LM27:
 247               		ldi r24,lo8(-124)
 248               		sts 188,r24
  76:i2c_mstr.c    **** 	// load data into data register
  77:i2c_mstr.c    **** 	TWDR = data;
 250               	:
 251               		ldi r30,lo8(188)
 252 00aa 8093 BB00 		ldi r31,hi8(188)
  78:i2c_mstr.c    **** 	// start transmission of data
  79:i2c_mstr.c    **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 253               	4:
 254               		ld r24,Z
 255 00ae 84E8      		tst r24
 256 00b0 8093 BC00 		brge .L24
  80:i2c_mstr.c    **** 	// wait for end of transmission
  81:i2c_mstr.c    **** 	while( !(TWCR & (1<<TWINT)) );
 257               	abn	68,0,83,.LM29-.LFBB4
 258               	.LM29:
 259 00b4 ECEB      		lds r24,185
 260 00b6 F0E0      		ldi r25,lo8(0)
 261               		andi r24,lo8(-8)
 262 00b8 8081      		cpi r24,lo8(40)
 263 00ba 8823      		breq .L25
 264 00bc 04F4      		ldi r25,lo8(1)
  82:i2c_mstr.c    **** 	
  83:i2c_mstr.c    **** 	if( (TWSR & 0xF8) != TW_MT_DATA_ACK ){ return 1; }
 265               	stabn	68,0,86,.LM30-.LFBB4
 266               	.LM30:
 267 00be 8091 B900 		mov r24,r25
 268 00c2 90E0      	/* epilogue start */
 269 00c4 887F      		ret
 271 00c8 01F0      	.Lscope4:
 273               	.global	i2c_read_ack
  84:i2c_mstr.c    **** 	
  85:i2c_mstr.c    **** 	return 0;
  86:i2c_mstr.c    **** }
 274               	c_read_ack, @function
 275               	i2c_read_ack:
 277               	.LM31:
 278 00ce 0895      	.LFBB5:
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 282               	.LM32:
 283               		ldi r24,lo8(-60)
 284               		sts 188,r24
  87:i2c_mstr.c    **** 
  88:i2c_mstr.c    **** uint8_t i2c_read_ack(void)
  89:i2c_mstr.c    **** {
 285               	0,94,.LM33-.LFBB5
 286               	.LM33:
 287               		ldi r30,lo8(188)
 288               		ldi r31,hi8(188)
 289               	.L29:
  90:i2c_mstr.c    **** 	
  91:i2c_mstr.c    **** 	// start TWI module and acknowledge data after reception
  92:i2c_mstr.c    **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
 290               	24,Z
 291               		tst r24
 292 00d0 84EC      		brge .L29
  93:i2c_mstr.c    **** 	// wait for end of transmission
  94:i2c_mstr.c    **** 	while( !(TWCR & (1<<TWINT)) );
 294               	4:
 295               		lds r24,187
 296 00d6 ECEB      	/* epilogue start */
 298               	.LM35:
 299 00da 8081      		ret
 301 00de 04F4      	.Lscope5:
  95:i2c_mstr.c    **** 	// return received data from TWDR
  96:i2c_mstr.c    **** 	return TWDR;
 302               	"i2c_read_nack:F(4,2)",36,0,0,i2c_read_nack
 303               	.global	i2c_read_nack
 305               	i2c_read_nack:
  97:i2c_mstr.c    **** }
 306               	abn	68,0,100,.LM36-.LFBB6
 307               	.LM36:
 308 00e4 0895      	.LFBB6:
 309               	/* prologue: function */
 310               	/* frame size = 0 */
 312               	.LM37:
 313               		ldi r24,lo8(-124)
 314               		sts 188,r24
  98:i2c_mstr.c    **** 
  99:i2c_mstr.c    **** uint8_t i2c_read_nack(void)
 100:i2c_mstr.c    **** {
 315               	8,0,105,.LM38-.LFBB6
 316               	.LM38:
 317               		ldi r30,lo8(188)
 318               		ldi r31,hi8(188)
 319               	.L33:
 101:i2c_mstr.c    **** 	
 102:i2c_mstr.c    **** 	// start receiving without acknowledging reception
 103:i2c_mstr.c    **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 320               	24,Z
 321               		tst r24
 322 00e6 84E8      		brge .L33
 104:i2c_mstr.c    **** 	// wait for end of transmission
 105:i2c_mstr.c    **** 	while( !(TWCR & (1<<TWINT)) );
 324               	9:
 325               		lds r24,187
 326 00ec ECEB      	/* epilogue start */
 328               	.LM40:
 329 00f0 8081      		ret
 331 00f4 04F4      	.Lscope6:
 106:i2c_mstr.c    **** 	// return received data from TWDR
 107:i2c_mstr.c    **** 	return TWDR;
 332               	"i2c_stop:F(0,15)",36,0,0,i2c_stop
 333               	.global	i2c_stop
 335               	i2c_stop:
 108:i2c_mstr.c    **** }
 336               	abn	68,0,175,.LM41-.LFBB7
 337               	.LM41:
 338 00fa 0895      	.LFBB7:
 339               	/* prologue: function */
 340               	/* frame size = 0 */
 342               	.LM42:
 343               		ldi r24,lo8(-108)
 344               		sts 188,r24
 109:i2c_mstr.c    **** 
 110:i2c_mstr.c    **** uint8_t i2c_transmit(uint8_t address, uint8_t* data, uint16_t length)
 111:i2c_mstr.c    **** {
 112:i2c_mstr.c    **** 	if (i2c_start(address | I2C_WRITE)) return 1;
 113:i2c_mstr.c    **** 	
 114:i2c_mstr.c    **** 	for (uint16_t i = 0; i < length; i++)
 115:i2c_mstr.c    **** 	{
 116:i2c_mstr.c    **** 		if (i2c_write(data[i])) return 1;
 117:i2c_mstr.c    **** 	}
 118:i2c_mstr.c    **** 	
 119:i2c_mstr.c    **** 	i2c_stop();
 120:i2c_mstr.c    **** 	
 121:i2c_mstr.c    **** 	return 0;
 122:i2c_mstr.c    **** }
 123:i2c_mstr.c    **** 
 124:i2c_mstr.c    **** uint8_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length)
 125:i2c_mstr.c    **** {
 126:i2c_mstr.c    **** 	if (i2c_start(address | I2C_READ)) return 1;
 127:i2c_mstr.c    **** 	
 128:i2c_mstr.c    **** 	for (uint16_t i = 0; i < (length-1); i++)
 129:i2c_mstr.c    **** 	{
 130:i2c_mstr.c    **** 		data[i] = i2c_read_ack();
 131:i2c_mstr.c    **** 	}
 132:i2c_mstr.c    **** 	data[(length-1)] = i2c_read_nack();
 133:i2c_mstr.c    **** 	
 134:i2c_mstr.c    **** 	i2c_stop();
 135:i2c_mstr.c    **** 	
 136:i2c_mstr.c    **** 	return 0;
 137:i2c_mstr.c    **** }
 138:i2c_mstr.c    **** 
 139:i2c_mstr.c    **** uint8_t i2c_writeReg(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length)
 140:i2c_mstr.c    **** {
 141:i2c_mstr.c    **** 	if (i2c_start(devaddr | 0x00)) return 1;
 142:i2c_mstr.c    **** 
 143:i2c_mstr.c    **** 	i2c_write(regaddr);
 144:i2c_mstr.c    **** 
 145:i2c_mstr.c    **** 	for (uint16_t i = 0; i < length; i++)
 146:i2c_mstr.c    **** 	{
 147:i2c_mstr.c    **** 		if (i2c_write(data[i])) return 1;
 148:i2c_mstr.c    **** 	}
 149:i2c_mstr.c    **** 
 150:i2c_mstr.c    **** 	i2c_stop();
 151:i2c_mstr.c    **** 
 152:i2c_mstr.c    **** 	return 0;
 153:i2c_mstr.c    **** }
 154:i2c_mstr.c    **** 
 155:i2c_mstr.c    **** uint8_t i2c_readReg(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length)
 156:i2c_mstr.c    **** {
 157:i2c_mstr.c    **** 	if (i2c_start(devaddr)) return 1;
 158:i2c_mstr.c    **** 
 159:i2c_mstr.c    **** 	i2c_write(regaddr);
 160:i2c_mstr.c    **** 
 161:i2c_mstr.c    **** 	if (i2c_start(devaddr | 0x01)) return 1;
 162:i2c_mstr.c    **** 
 163:i2c_mstr.c    **** 	for (uint16_t i = 0; i < (length-1); i++)
 164:i2c_mstr.c    **** 	{
 165:i2c_mstr.c    **** 		data[i] = i2c_read_ack();
 166:i2c_mstr.c    **** 	}
 167:i2c_mstr.c    **** 	data[(length-1)] = i2c_read_nack();
 168:i2c_mstr.c    **** 
 169:i2c_mstr.c    **** 	i2c_stop();
 170:i2c_mstr.c    **** 
 171:i2c_mstr.c    **** 	return 0;
 172:i2c_mstr.c    **** }
 173:i2c_mstr.c    **** 
 174:i2c_mstr.c    **** void i2c_stop(void)
 175:i2c_mstr.c    **** {
 345               	ue start */
 347               	.LM43:
 348               		ret
 176:i2c_mstr.c    **** 	// transmit STOP condition
 177:i2c_mstr.c    **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 350               	pe7:
 178:i2c_mstr.c    **** }
 355               	bs	"length:P(4,4)",64,0,0,12
 356               	.global	i2c_readReg
 358               	i2c_readReg:
 360               	.LM44:
 361               	.LFBB8:
 362               		push r12
 363               		push r13
 364               		push r14
 365               		push r15
 366               		push r16
 367               		push r17
 368               		push r28
 369               		push r29
 370               	/* prologue: function */
 371 0104 CF92      	/* frame size = 0 */
 372 0106 DF92      		mov r17,r24
 373 0108 EF92      		mov r16,r22
 374 010a FF92      		movw r14,r20
 375 010c 0F93      		movw r12,r18
 377 0110 CF93      	.LM45:
 378 0112 DF93      		call i2c_start
 379               		tst r24
 380               		brne .L39
 382 0116 062F      	.LM46:
 383 0118 7A01      		mov r24,r16
 384 011a 6901      		call i2c_write
 386               	.LM47:
 387 011c 0E94 0000 		mov r24,r17
 388 0120 8823      		ori r24,lo8(1)
 389 0122 01F4      		call i2c_start
 390               		tst r24
 391               		brne .L39
 392 0124 802F      	.LBB2:
 394               	.LM48:
 395               		movw r16,r12
 396 012a 812F      		subi r16,lo8(-(-1))
 397 012c 8160      		sbci r17,hi8(-(-1))
 398 012e 0E94 0000 		breq .L40
 399 0132 8823      		ldi r28,lo8(0)
 400 0134 01F4      		ldi r29,hi8(0)
 401               	.L41:
 403               	.LM49:
 404 0136 8601      		call i2c_read_ack
 405 0138 0150      		movw r30,r14
 406 013a 1040      		add r30,r28
 407 013c 01F0      		adc r31,r29
 408 013e C0E0      		st Z,r24
 410               	.LM50:
 411               		adiw r28,1
 412               		cp r28,r16
 413 0142 0E94 0000 		cpc r29,r17
 414 0146 F701      		brlo .L41
 415 0148 EC0F      	.L40:
 416 014a FD1F      	.LBE2:
 418               	.LM51:
 419               		call i2c_read_nack
 420 014e 2196      		movw r30,r14
 421 0150 C017      		add r30,r12
 422 0152 D107      		adc r31,r13
 423 0154 00F0      		sbiw r30,1
 424               		st Z,r24
 426               	.LM52:
 427               		call i2c_stop
 428 0156 0E94 0000 		ldi r24,lo8(0)
 429 015a F701      		rjmp .L42
 430 015c EC0D      	.L39:
 432 0160 3197      	.LM53:
 433 0162 8083      		ldi r24,lo8(1)
 434               	.L42:
 435               	/* epilogue start */
 437 0168 80E0      	.LM54:
 438 016a 00C0      		pop r29
 439               		pop r28
 440               		pop r17
 441               		pop r16
 442 016c 81E0      		pop r15
 443               		pop r14
 444               		pop r13
 445               		pop r12
 446               		ret
 451 0176 FF90      	.Lscope8:
 457               	.global	i2c_writeReg
 459               	i2c_writeReg:
 461               	.LM55:
 462               	.LFBB9:
 463               		push r13
 464               		push r14
 465               		push r15
 466               		push r16
 467               		push r17
 468               		push r28
 469               		push r29
 470               	/* prologue: function */
 471               	/* frame size = 0 */
 472 0180 DF92      		mov r13,r22
 473 0182 EF92      		movw r14,r20
 474 0184 FF92      		movw r16,r18
 476 0188 1F93      	.LM56:
 477 018a CF93      		call i2c_start
 478 018c DF93      		tst r24
 479               		brne .L46
 481 018e D62E      	.LM57:
 482 0190 7A01      		mov r24,r13
 483 0192 8901      		call i2c_write
 484               	.LBB3:
 486 0194 0E94 0000 	.LM58:
 487 0198 8823      		cp r16,__zero_reg__
 488 019a 01F4      		cpc r17,__zero_reg__
 489               		breq .L47
 490               		ldi r28,lo8(0)
 491 019c 8D2D      		ldi r29,hi8(0)
 492 019e 0E94 0000 	.L48:
 494               	.LM59:
 495               		movw r30,r14
 496 01a2 0115      		add r30,r28
 497 01a4 1105      		adc r31,r29
 498 01a6 01F0      		ld r24,Z
 499 01a8 C0E0      		call i2c_write
 500 01aa D0E0      		tst r24
 501               		brne .L46
 503               	.LM60:
 504 01ac F701      		adiw r28,1
 505 01ae EC0F      		cp r28,r16
 506 01b0 FD1F      		cpc r29,r17
 507 01b2 8081      		brlo .L48
 508 01b4 0E94 0000 	.L47:
 509 01b8 8823      	.LBE3:
 511               	.LM61:
 512               		call i2c_stop
 513 01bc 2196      		ldi r24,lo8(0)
 514 01be C017      		rjmp .L49
 515 01c0 D107      	.L46:
 517               	.LM62:
 518               		ldi r24,lo8(1)
 519               	.L49:
 520               	/* epilogue start */
 522 01c8 80E0      	.LM63:
 523 01ca 00C0      		pop r29
 524               		pop r28
 525               		pop r17
 526               		pop r16
 527 01cc 81E0      		pop r15
 528               		pop r14
 529               		pop r13
 530               		ret
 535 01d4 0F91      	.Lscope9:
 540               	.global	i2c_receive
 542               	i2c_receive:
 544               	.LM64:
 545               	.LFBB10:
 546               		push r12
 547               		push r13
 548               		push r14
 549               		push r15
 550               		push r16
 551               		push r17
 552               		push r28
 553               		push r29
 554               	/* prologue: function */
 555 01de CF92      	/* frame size = 0 */
 556 01e0 DF92      		movw r14,r22
 557 01e2 EF92      		movw r12,r20
 559 01e6 0F93      	.LM65:
 560 01e8 1F93      		ori r24,lo8(1)
 561 01ea CF93      		call i2c_start
 562 01ec DF93      		tst r24
 563               		breq .L53
 564               		ldi r24,lo8(1)
 565 01ee 7B01      		rjmp .L54
 566 01f0 6A01      	.L53:
 567               	.LBB4:
 569 01f2 8160      	.LM66:
 570 01f4 0E94 0000 		movw r16,r12
 571 01f8 8823      		subi r16,lo8(-(-1))
 572 01fa 01F0      		sbci r17,hi8(-(-1))
 573 01fc 81E0      		breq .L55
 574 01fe 00C0      		ldi r28,lo8(0)
 575               		ldi r29,hi8(0)
 576               	.L56:
 578               	.LM67:
 579 0200 8601      		call i2c_read_ack
 580 0202 0150      		movw r30,r14
 581 0204 1040      		add r30,r28
 582 0206 01F0      		adc r31,r29
 583 0208 C0E0      		st Z,r24
 585               	.LM68:
 586               		adiw r28,1
 587               		cp r28,r16
 588 020c 0E94 0000 		cpc r29,r17
 589 0210 F701      		brlo .L56
 590 0212 EC0F      	.L55:
 591 0214 FD1F      	.LBE4:
 593               	.LM69:
 594               		call i2c_read_nack
 595 0218 2196      		movw r30,r14
 596 021a C017      		add r30,r12
 597 021c D107      		adc r31,r13
 598 021e 00F0      		sbiw r30,1
 599               		st Z,r24
 601               	.LM70:
 602               		call i2c_stop
 603 0220 0E94 0000 		ldi r24,lo8(0)
 604 0224 F701      	.L54:
 605 0226 EC0D      	/* epilogue start */
 607 022a 3197      	.LM71:
 608 022c 8083      		pop r29
 609               		pop r28
 610               		pop r17
 611 022e 0E94 0000 		pop r16
 612 0232 80E0      		pop r15
 613               		pop r14
 614               		pop r13
 615               		pop r12
 616               		ret
 621 023c FF90      	.Lscope10:
 626               	.global	i2c_transmit
 628               	i2c_transmit:
 630               	.LM72:
 631               	.LFBB11:
 632               		push r14
 633               		push r15
 634               		push r16
 635               		push r17
 636               		push r28
 637               		push r29
 638               	/* prologue: function */
 639               	/* frame size = 0 */
 640               		movw r14,r22
 641 0246 EF92      		movw r16,r20
 643 024a 0F93      	.LM73:
 644 024c 1F93      		call i2c_start
 645 024e CF93      		tst r24
 646 0250 DF93      		brne .L60
 647               	.LBB5:
 649 0252 7B01      	.LM74:
 650 0254 8A01      		cp r16,__zero_reg__
 651               		cpc r17,__zero_reg__
 652               		breq .L61
 653 0256 0E94 0000 		ldi r28,lo8(0)
 654 025a 8823      		ldi r29,hi8(0)
 655 025c 01F4      	.L62:
 657               	.LM75:
 658               		movw r30,r14
 659 025e 0115      		add r30,r28
 660 0260 1105      		adc r31,r29
 661 0262 01F0      		ld r24,Z
 662 0264 C0E0      		call i2c_write
 663 0266 D0E0      		tst r24
 664               		brne .L60
 666               	.LM76:
 667 0268 F701      		adiw r28,1
 668 026a EC0F      		cp r28,r16
 669 026c FD1F      		cpc r29,r17
 670 026e 8081      		brlo .L62
 671 0270 0E94 0000 	.L61:
 672 0274 8823      	.LBE5:
 674               	.LM77:
 675               		call i2c_stop
 676 0278 2196      		ldi r24,lo8(0)
 677 027a C017      		rjmp .L63
 678 027c D107      	.L60:
 680               	.LM78:
 681               		ldi r24,lo8(1)
 682               	.L63:
 683               	/* epilogue start */
 685 0284 80E0      	.LM79:
 686 0286 00C0      		pop r29
 687               		pop r28
 688               		pop r17
 689               		pop r16
 690 0288 81E0      		pop r15
 691               		pop r14
 692               		ret
 697 028e 1F91      	.Lscope11:
 699 0292 FF90      	.Letext0:
 700 0294 EF90      	...
DEFINED SYMBOLS
                            *ABS*:00000000 i2c_mstr.c
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:2      *ABS*:0000003f __SREG__
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:3      *ABS*:0000003e __SP_H__
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:4      *ABS*:0000003d __SP_L__
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:5      *ABS*:00000034 __CCP__
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:71     .text:00000000 i2c_init
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:97     .text:0000000e i2c_start
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:172    .text:0000005c i2c_rep_start
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:244    .text:000000aa i2c_write
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:284    .text:000000d0 i2c_read_ack
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:314    .text:000000e6 i2c_read_nack
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:344    .text:000000fc i2c_stop
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:367    .text:00000104 i2c_readReg
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:468    .text:00000180 i2c_writeReg
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:551    .text:000001de i2c_receive
C:\Users\Thorsten\AppData\Local\Temp/ccaZbhec.s:637    .text:00000246 i2c_transmit

NO UNDEFINED SYMBOLS
